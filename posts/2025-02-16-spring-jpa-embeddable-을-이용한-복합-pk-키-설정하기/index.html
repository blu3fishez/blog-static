<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Spring JPA] @Embeddable 을 이용한 복합 PK 키 설정하기 | blog.moozeh</title>
<meta name="keywords" content="Spring, JPA">
<meta name="description" content="Porring 프로젝트를 진행하면서 엔티티 설정을 마치고, 복합키에 관한 지적을 받았다.
AI를 이용해서 만든 코드인데, 미처 검증하지 못한 부분에 대해서 다시 생각해보게 되었고, 복합 PK 키를 JPA 에서 어떻게 설정하는지 한번 알아보려고 한다.

먼저, 복합 키란?
복합키는 말 그대로 여러 개의 컬럼들을 하나로 묶어서 키로 정의한 것을 복합키라고 한다.
기본적으로 복합 인덱스 라고 하면, 여러 컬럼에 대한 인덱스를 뜻할 것이고, 복합 키라고 하면, 외래 키 혹은 기본 키(PK) 에 대해서 복합적인 컬럼이 그 기준이 되는 것을 뜻한다.">
<meta name="author" content="moozeh">
<link rel="canonical" href="https://blog.moozeh.org/posts/2025-02-16-spring-jpa-embeddable-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B3%B5%ED%95%A9-pk-%ED%82%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.moozeh.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.moozeh.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.moozeh.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.moozeh.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.moozeh.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.moozeh.org/posts/2025-02-16-spring-jpa-embeddable-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B3%B5%ED%95%A9-pk-%ED%82%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.moozeh.org/posts/2025-02-16-spring-jpa-embeddable-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B3%B5%ED%95%A9-pk-%ED%82%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/">
  <meta property="og:site_name" content="blog.moozeh">
  <meta property="og:title" content="[Spring JPA] @Embeddable 을 이용한 복합 PK 키 설정하기">
  <meta property="og:description" content="Porring 프로젝트를 진행하면서 엔티티 설정을 마치고, 복합키에 관한 지적을 받았다.
AI를 이용해서 만든 코드인데, 미처 검증하지 못한 부분에 대해서 다시 생각해보게 되었고, 복합 PK 키를 JPA 에서 어떻게 설정하는지 한번 알아보려고 한다.
먼저, 복합 키란? 복합키는 말 그대로 여러 개의 컬럼들을 하나로 묶어서 키로 정의한 것을 복합키라고 한다.
기본적으로 복합 인덱스 라고 하면, 여러 컬럼에 대한 인덱스를 뜻할 것이고, 복합 키라고 하면, 외래 키 혹은 기본 키(PK) 에 대해서 복합적인 컬럼이 그 기준이 되는 것을 뜻한다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-02-16T00:00:00+00:00">
    <meta property="article:tag" content="Spring">
    <meta property="article:tag" content="JPA">
      <meta property="og:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:title" content="[Spring JPA] @Embeddable 을 이용한 복합 PK 키 설정하기">
<meta name="twitter:description" content="Porring 프로젝트를 진행하면서 엔티티 설정을 마치고, 복합키에 관한 지적을 받았다.
AI를 이용해서 만든 코드인데, 미처 검증하지 못한 부분에 대해서 다시 생각해보게 되었고, 복합 PK 키를 JPA 에서 어떻게 설정하는지 한번 알아보려고 한다.

먼저, 복합 키란?
복합키는 말 그대로 여러 개의 컬럼들을 하나로 묶어서 키로 정의한 것을 복합키라고 한다.
기본적으로 복합 인덱스 라고 하면, 여러 컬럼에 대한 인덱스를 뜻할 것이고, 복합 키라고 하면, 외래 키 혹은 기본 키(PK) 에 대해서 복합적인 컬럼이 그 기준이 되는 것을 뜻한다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.moozeh.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[Spring JPA] @Embeddable 을 이용한 복합 PK 키 설정하기",
      "item": "https://blog.moozeh.org/posts/2025-02-16-spring-jpa-embeddable-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B3%B5%ED%95%A9-pk-%ED%82%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Spring JPA] @Embeddable 을 이용한 복합 PK 키 설정하기",
  "name": "[Spring JPA] @Embeddable 을 이용한 복합 PK 키 설정하기",
  "description": "Porring 프로젝트를 진행하면서 엔티티 설정을 마치고, 복합키에 관한 지적을 받았다.\nAI를 이용해서 만든 코드인데, 미처 검증하지 못한 부분에 대해서 다시 생각해보게 되었고, 복합 PK 키를 JPA 에서 어떻게 설정하는지 한번 알아보려고 한다.\n먼저, 복합 키란? 복합키는 말 그대로 여러 개의 컬럼들을 하나로 묶어서 키로 정의한 것을 복합키라고 한다.\n기본적으로 복합 인덱스 라고 하면, 여러 컬럼에 대한 인덱스를 뜻할 것이고, 복합 키라고 하면, 외래 키 혹은 기본 키(PK) 에 대해서 복합적인 컬럼이 그 기준이 되는 것을 뜻한다.\n",
  "keywords": [
    "Spring", "JPA"
  ],
  "articleBody": "Porring 프로젝트를 진행하면서 엔티티 설정을 마치고, 복합키에 관한 지적을 받았다.\nAI를 이용해서 만든 코드인데, 미처 검증하지 못한 부분에 대해서 다시 생각해보게 되었고, 복합 PK 키를 JPA 에서 어떻게 설정하는지 한번 알아보려고 한다.\n먼저, 복합 키란? 복합키는 말 그대로 여러 개의 컬럼들을 하나로 묶어서 키로 정의한 것을 복합키라고 한다.\n기본적으로 복합 인덱스 라고 하면, 여러 컬럼에 대한 인덱스를 뜻할 것이고, 복합 키라고 하면, 외래 키 혹은 기본 키(PK) 에 대해서 복합적인 컬럼이 그 기준이 되는 것을 뜻한다.\nSpring 에서 복합 PK를 설정하는 방법 일단 두가지 방식으로 접근할 수 있다.\n@IdClass 사용하기 @EmbeddedId 사용하기 주의할 점으로는 두 어노테이션 모두 JPA 1.0(JSR-220)부터 존재했다고 하며, 어느 쪽이 더 좋은 쪽은 아니다! 따라서 저마다의 방식이 있기 때문에 장단점을 살펴볼 필요가 있다.\n그럼 각각에 대한 차이를 알아보자.\n@IdClass 백문이불여일견, 해당 예시 코드부터 보자.\n// ID 클래스 정의 public class OrderItemId implements Serializable { private Long orderId; private Long itemId; // 기본 생성자, equals(), hashCode() 구현 필요 } // 엔티티 클래스 @Entity @IdClass(OrderItemId.class) public class OrderItem { @Id private Long orderId; @Id private Long itemId; // 다른 필드들... } 기본적으로 ID 에 해당되는 클래스를 정의하고, @IdClass, 즉 이 키의 기본키는 이렇게 될 것이다. 라고 정의해주는 것이다.\n@IdClass 의 가장 큰 특징은 엔티티 구현 내부에서 데이터베이스 기본키 필드를 한눈에 확인할 수 있다는 점이다.\n사실상 우리가 ERD 로부터 그대로 구현해야하는 상황일 경우 이런 방식이 도움이 될 것이다.\n하지만 단점으로는, Id 클래스를 만들어정해주어야하는 점, 그로 인해 필드 정의가 중복된다는 점이 있다. 다시말해, 내부구현을 바꾸게되면 동일하게 바꿔줘야한다.\n필드 접근 (조작) 하지만 아래 코드처럼, 직접 필드 접근이 가능하여 데이터베이스에 가까운 조작이 필요할 경우 해당 방식이 유리할지 모른다.\nOrderItem orderItem = new OrderItem(); orderItem.setOrderId(1L); // 직접 필드 접근 orderItem.setItemId(2L); // 직접 필드 접근 조회 일반적인 entityManager를 통한 조회는 아래와 같이 할 수 있다.\n@IdClass 를 통해 Id 값이 클래스를 통해 매핑되었기 때문에, 조회역시 동일한 IdClass 로 해주어야한다.\n// 조회 시 OrderItemId id = new OrderItemId(1L, 2L); OrderItem item = em.find(OrderItem.class, id); 하지만 나는 결국 직접 클래스에 필드를 두번 주입해야한다는 점, 직접 필드 접근을 통해 조작에 예상할 수 없는 부작용이 있는 점 등으로 인해 마음에 들지 않았고, 몇가지 방법을 찾은 끝에 @EmbeddedId 라는 어노테이션이 있음을 알게 됐다.\n@EmbeddedId 이번에도 일단 해당 예시부터 보자.\n// 복합키 클래스 @Embeddable public class OrderItemId implements Serializable { private Long orderId; private Long itemId; // 기본 생성자, equals(), hashCode() 구현 필요 } // 엔티티 클래스 @Entity public class OrderItem { @EmbeddedId private OrderItemId id; // 다른 필드들... } 해당 방식의 가장 큰 특징은 복합 키를 하나의 엔티티로 다룬다는 점이다.\n또한 가장 큰 특징은 내부 필드에 바로 OriderItemId 자체를 삽입한다는 것이다. 그래서 Embeddable 인 것이고, 위 예시의 경우 이렇게 데이터베이스가 매핑된다.\nCREATE TABLE order_item ( order_id BIGINT NOT NULL, -- OrderItemId의 orderId item_id BIGINT NOT NULL, -- OrderItemId의 itemId quantity INTEGER, PRIMARY KEY (order_id, item_id) ); 하지만 실제 JPA로 접근 시에는 해당 키를 사용하는 클래스를 바로 가져와서 Id 필드를 지정해주면 되니, 좀 더 자바 객체에 가까운 설계라고 할 수 있다.\n캡슐화 또한 잘 되어 있어 원하는 구현을 직접 참고할 수 있다.\n또한 실제 내부 쿼리도 하나의 테이블 내에서 같이 이루어지기 때문에 자바 객체로써 객체지향적인 설계를 하면서 동시에 JPA 에게 내부 테이블 접근 방식을 맡길 수 있다. 즉, 굳이 최적화할 필요가 없단 의미이다. (일반적인 의미에선.)\n실제 DB 작업시에는 Id를 담당하는 객체를 분리하여 처리하기 때문이다.\nINSERT INTO order_item (order_id, item_id, quantity) VALUES (1, 2, 10); 필드 접근 (조작) 예를 들면 아래와 같이 각각의 복합키 필드에 따로따로 접근할 필요 없이, IdClass 를 새롭게 정의해야한다. 이로 인해 복합키 클래스는 불변성이 있으면 좋을 것이라 판단한다.\nOrderItemId id = new OrderItemId(1L, 2L); OrderItem orderItem = new OrderItem(); orderItem.setId(id); // 복합키 객체를 통해 접근 조회 조회는 @IdClass 와 동일한 방식으로 접근한다.\n주의 점 별도의 주의점이 있는데 아래와 같다.\n기본 생성자가 있어야 함 equals()와 hashCode() 메서드를 올바르게 구현해야 함 변경 불가능한(immutable) 클래스로 만드는 것을 권장 왜 그렇게 해야할까?\n기본 생성자야 당연히 새롭게 정의한다면 필요할 것이다. Generated 된 변수면 이에 대한 어노테이션을 정의해주면 된다.\n다만, Serializable 인터페이스를 구현해주어야하는데, 왜 직렬화가 가능하도록 만들어야할까?\n식별자 클래스에 직렬화가 필요한 이유 이는 JPA 가 엔티티를 저장 및 조회 시 식별자를 직렬화해서 사용하기 때문이다.\n이 뜻은, 당연히 복합 키에 해당되는 컬럼값들을 직렬화해서 DB에 저장한단 의미가 아니고 JPA 구현체(예: Hibernate)가 내부적으로 엔티티를 관리하는 과정에서 사용한다는 의미이다.\n영속성 컨텍스트를 기준으로 보자.\n[!note] 간단히 알아보기 : 영속성 컨텍스트란?\n영속성 컨텍스트(Persistence Context)는 JPA가 엔티티를 관리하는 가상의 환경 또는 컨테이너를 뜻한다.\n알아서 성능 최적화가 되거나 (1차 캐시) 트랜잭션을 지원한다. 영속성 컨텍스트로 인해 데이터의 영속성이 보장된다.\nJPA 는 내부적으로 영속성 컨텍스트에서 내부 맵에서 키로 사용된다.\n그렇기 때문에 이것을 직렬화할 필요가 있는 것이다.\n그렇지 않다면 객체로 저장해야하는데, 할당받은 객체의 식별번호값이 실제 데이터베이스 내 해당되는 복합키와 동일성이 보장되지 않기 때문이다.\n그렇기 때문에 Serializable (직렬화 가능한 것) 을 상속받아야하는 것이고, 이는 곧 성능문제 로 이어질 수 있다. 분산 환경 / 캐시 사용에 문제가 될 수 있기 때문이다. 예를 들면 직렬화 불가능하다고 판단될 경우 Mapping 을 못하게 될 것이고 이는 곧 캐시를 쓰지 못하는 결과로 이어질 것이다.\n식별자 클래스에 equals, hashCode가 필요한 이유 그렇다면 equals, hashCode 메서드를 구현해야하는 이유도 동일하게 이해될 것이다.\n이들은 영속성 컨텍스트에서 \b엔티티 간의 동일성 비교를 위해 요구되며, Serializable 과는 독립된 요구사항이다.\n결국 모두 필수사항은 아니나, 성능에 영향이 생길지도 모르기 때문에 되도록이면 구현하도록 하자.\n",
  "wordCount" : "823",
  "inLanguage": "en",
  "image": "https://blog.moozeh.org/images/papermod-cover.png","datePublished": "2025-02-16T00:00:00Z",
  "dateModified": "2025-02-16T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "moozeh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.moozeh.org/posts/2025-02-16-spring-jpa-embeddable-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B3%B5%ED%95%A9-pk-%ED%82%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.moozeh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.moozeh.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.moozeh.org/" accesskey="h" title="blog.moozeh (Alt + H)">blog.moozeh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.moozeh.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.moozeh.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.moozeh.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      [Spring JPA] @Embeddable 을 이용한 복합 PK 키 설정하기
    </h1>
    <div class="post-meta"><span title='2025-02-16 00:00:00 +0000 UTC'>February 16, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;moozeh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%eb%a8%bc%ec%a0%80-%eb%b3%b5%ed%95%a9-%ed%82%a4%eb%9e%80" aria-label="먼저, 복합 키란?">먼저, 복합 키란?</a></li>
                <li>
                    <a href="#spring-%ec%97%90%ec%84%9c-%eb%b3%b5%ed%95%a9-pk%eb%a5%bc-%ec%84%a4%ec%a0%95%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95" aria-label="Spring 에서 복합 PK를 설정하는 방법">Spring 에서 복합 PK를 설정하는 방법</a><ul>
                        
                <li>
                    <a href="#idclass" aria-label="@IdClass">@IdClass</a><ul>
                        
                <li>
                    <a href="#%ed%95%84%eb%93%9c-%ec%a0%91%ea%b7%bc-%ec%a1%b0%ec%9e%91" aria-label="필드 접근 (조작)">필드 접근 (조작)</a></li>
                <li>
                    <a href="#%ec%a1%b0%ed%9a%8c" aria-label="조회">조회</a></li></ul>
                </li>
                <li>
                    <a href="#embeddedid" aria-label="@EmbeddedId">@EmbeddedId</a><ul>
                        
                <li>
                    <a href="#%ed%95%84%eb%93%9c-%ec%a0%91%ea%b7%bc-%ec%a1%b0%ec%9e%91-1" aria-label="필드 접근 (조작)">필드 접근 (조작)</a></li>
                <li>
                    <a href="#%ec%a1%b0%ed%9a%8c-1" aria-label="조회">조회</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%ec%a3%bc%ec%9d%98-%ec%a0%90" aria-label="주의 점">주의 점</a><ul>
                        
                <li>
                    <a href="#%ec%8b%9d%eb%b3%84%ec%9e%90-%ed%81%b4%eb%9e%98%ec%8a%a4%ec%97%90-%ec%a7%81%eb%a0%ac%ed%99%94%ea%b0%80-%ed%95%84%ec%9a%94%ed%95%9c-%ec%9d%b4%ec%9c%a0" aria-label="식별자 클래스에 직렬화가 필요한 이유">식별자 클래스에 직렬화가 필요한 이유</a></li>
                <li>
                    <a href="#%ec%8b%9d%eb%b3%84%ec%9e%90-%ed%81%b4%eb%9e%98%ec%8a%a4%ec%97%90-equals-hashcode%ea%b0%80-%ed%95%84%ec%9a%94%ed%95%9c-%ec%9d%b4%ec%9c%a0" aria-label="식별자 클래스에 equals, hashCode가 필요한 이유">식별자 클래스에 equals, hashCode가 필요한 이유</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><p><a href="https://github.com/Kolown-kr/porring-server/pull/9">Porring 프로젝트를 진행하면서 엔티티 설정을 마치고,</a> 복합키에 관한 지적을 받았다.</p>
<p>AI를 이용해서 만든 코드인데, 미처 검증하지 못한 부분에 대해서 다시 생각해보게 되었고, 복합 PK 키를 JPA 에서 어떻게 설정하는지 한번 알아보려고 한다.</p>
<!-- more -->
<h2 id="먼저-복합-키란">먼저, 복합 키란?<a hidden class="anchor" aria-hidden="true" href="#먼저-복합-키란">#</a></h2>
<p>복합키는 말 그대로 여러 개의 컬럼들을 하나로 묶어서 키로 정의한 것을 복합키라고 한다.</p>
<p>기본적으로 복합 인덱스 라고 하면, 여러 컬럼에 대한 인덱스를 뜻할 것이고, 복합 키라고 하면, 외래 키 혹은 기본 키(PK) 에 대해서 복합적인 컬럼이 그 기준이 되는 것을 뜻한다.</p>
<h2 id="spring-에서-복합-pk를-설정하는-방법">Spring 에서 복합 PK를 설정하는 방법<a hidden class="anchor" aria-hidden="true" href="#spring-에서-복합-pk를-설정하는-방법">#</a></h2>
<p>일단 두가지 방식으로 접근할 수 있다.</p>
<ol>
<li><code>@IdClass</code> 사용하기</li>
<li><code>@EmbeddedId</code> 사용하기</li>
</ol>
<p>주의할 점으로는 두 어노테이션 모두 JPA 1.0(JSR-220)부터 존재했다고 하며, 어느 쪽이 더 좋은 쪽은 아니다! 따라서 저마다의 방식이 있기 때문에 장단점을 살펴볼 필요가 있다.</p>
<p>그럼 각각에 대한 차이를 알아보자.</p>
<h3 id="idclass"><code>@IdClass</code><a hidden class="anchor" aria-hidden="true" href="#idclass">#</a></h3>
<p>백문이불여일견, 해당 예시 코드부터 보자.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// ID 클래스 정의</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">OrderItemId</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Serializable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">orderId</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">itemId</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 기본 생성자, equals(), hashCode() 구현 필요</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 엔티티 클래스</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Entity</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@IdClass</span><span class="p">(</span><span class="n">OrderItemId</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">OrderItem</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">orderId</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Id</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">itemId</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 다른 필드들...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>기본적으로 <code>ID</code> 에 해당되는 클래스를 정의하고, <code>@IdClass</code>, 즉 <strong>이 키의 기본키는 이렇게 될 것이다.</strong> 라고 정의해주는 것이다.</p>
<p><code>@IdClass</code> 의 가장 큰 특징은 <strong>엔티티 구현 내부에서 데이터베이스 기본키 필드를 한눈에 확인할 수 있다는 점이다.</strong></p>
<p>사실상 우리가 <code>ERD</code> 로부터 그대로 구현해야하는 상황일 경우 이런 방식이 도움이 될 것이다.</p>
<p>하지만 단점으로는, <code>Id</code> 클래스를 만들어정해주어야하는 점, 그로 인해 필드 정의가 중복된다는 점이 있다. 다시말해, 내부구현을 바꾸게되면 동일하게 바꿔줘야한다.</p>
<h4 id="필드-접근-조작">필드 접근 (조작)<a hidden class="anchor" aria-hidden="true" href="#필드-접근-조작">#</a></h4>
<p>하지만 아래 코드처럼, 직접 필드 접근이 가능하여 <strong>데이터베이스에 가까운 조작이 필요할 경우 해당 방식이 유리할지 모른다.</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">OrderItem</span><span class="w"> </span><span class="n">orderItem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderItem</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">orderItem</span><span class="p">.</span><span class="na">setOrderId</span><span class="p">(</span><span class="n">1L</span><span class="p">);</span><span class="w">  </span><span class="c1">// 직접 필드 접근</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">orderItem</span><span class="p">.</span><span class="na">setItemId</span><span class="p">(</span><span class="n">2L</span><span class="p">);</span><span class="w">   </span><span class="c1">// 직접 필드 접근</span><span class="w">
</span></span></span></code></pre></div><h4 id="조회">조회<a hidden class="anchor" aria-hidden="true" href="#조회">#</a></h4>
<p>일반적인 <code>entityManager</code>를 통한 조회는 아래와 같이 할 수 있다.</p>
<p><code>@IdClass</code> 를 통해 <code>Id</code> 값이 클래스를 통해 매핑되었기 때문에, 조회역시 동일한 <code>IdClass</code> 로 해주어야한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 조회 시</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">OrderItemId</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderItemId</span><span class="p">(</span><span class="n">1L</span><span class="p">,</span><span class="w"> </span><span class="n">2L</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">OrderItem</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">em</span><span class="p">.</span><span class="na">find</span><span class="p">(</span><span class="n">OrderItem</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>하지만 나는 결국 직접 클래스에 필드를 두번 주입해야한다는 점, 직접 필드 접근을 통해 조작에 예상할 수 없는 부작용이 있는 점 등으로 인해 마음에 들지 않았고, 몇가지 방법을 찾은 끝에 <code>@EmbeddedId</code> 라는 어노테이션이 있음을 알게 됐다.</p>
<h3 id="embeddedid"><code>@EmbeddedId</code><a hidden class="anchor" aria-hidden="true" href="#embeddedid">#</a></h3>
<p>이번에도 일단 해당 예시부터 보자.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 복합키 클래스</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Embeddable</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">OrderItemId</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Serializable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">orderId</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Long</span><span class="w"> </span><span class="n">itemId</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 기본 생성자, equals(), hashCode() 구현 필요</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 엔티티 클래스</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Entity</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">OrderItem</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@EmbeddedId</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">OrderItemId</span><span class="w"> </span><span class="n">id</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 다른 필드들...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>해당 방식의 가장 큰 특징은 <strong>복합 키를 하나의 엔티티로 다룬다는 점이다.</strong></p>
<p>또한 가장 큰 특징은 <strong>내부 필드에 바로 <code>OriderItemId</code> 자체를 삽입한다는 것이다.</strong> 그래서 Embeddable 인 것이고, 위 예시의 경우 이렇게 데이터베이스가 매핑된다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">order_item</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">order_id</span><span class="w"> </span><span class="nb">BIGINT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">    </span><span class="c1">-- OrderItemId의 orderId
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">item_id</span><span class="w"> </span><span class="nb">BIGINT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">     </span><span class="c1">-- OrderItemId의 itemId
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">quantity</span><span class="w"> </span><span class="nb">INTEGER</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">order_id</span><span class="p">,</span><span class="w"> </span><span class="n">item_id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>하지만 실제 <code>JPA</code>로 접근 시에는 해당 키를 사용하는 클래스를 바로 가져와서 <code>Id</code> 필드를 지정해주면 되니, 좀 더 <strong>자바 객체에 가까운 설계라고 할 수 있다.</strong></p>
<p>캡슐화 또한 잘 되어 있어 원하는 구현을 직접 참고할 수 있다.</p>
<p>또한 실제 내부 쿼리도 하나의 테이블 내에서 같이 이루어지기 때문에 자바 객체로써 객체지향적인 설계를 하면서 동시에 <code>JPA</code> 에게 내부 테이블 접근 방식을 맡길 수 있다. 즉, 굳이 최적화할 필요가 없단 의미이다. (일반적인 의미에선.)</p>
<p>실제 DB 작업시에는 <code>Id</code>를 담당하는 객체를 분리하여 처리하기 때문이다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">order_item</span><span class="w"> </span><span class="p">(</span><span class="n">order_id</span><span class="p">,</span><span class="w"> </span><span class="n">item_id</span><span class="p">,</span><span class="w"> </span><span class="n">quantity</span><span class="p">)</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><h4 id="필드-접근-조작-1">필드 접근 (조작)<a hidden class="anchor" aria-hidden="true" href="#필드-접근-조작-1">#</a></h4>
<p>예를 들면 아래와 같이 각각의 복합키 필드에 따로따로 접근할 필요 없이, <code>IdClass</code> 를 새롭게 정의해야한다. 이로 인해 복합키 클래스는 불변성이 있으면 좋을 것이라 판단한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">OrderItemId</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderItemId</span><span class="p">(</span><span class="n">1L</span><span class="p">,</span><span class="w"> </span><span class="n">2L</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">OrderItem</span><span class="w"> </span><span class="n">orderItem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderItem</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">orderItem</span><span class="p">.</span><span class="na">setId</span><span class="p">(</span><span class="n">id</span><span class="p">);</span><span class="w">  </span><span class="c1">// 복합키 객체를 통해 접근</span><span class="w">
</span></span></span></code></pre></div><h4 id="조회-1">조회<a hidden class="anchor" aria-hidden="true" href="#조회-1">#</a></h4>
<p>조회는 <code>@IdClass</code> 와 동일한 방식으로 접근한다.</p>
<h2 id="주의-점">주의 점<a hidden class="anchor" aria-hidden="true" href="#주의-점">#</a></h2>
<p>별도의 주의점이 있는데 아래와 같다.</p>
<ol>
<li>기본 생성자가 있어야 함</li>
<li><code>equals()</code>와 <code>hashCode()</code> 메서드를 올바르게 구현해야 함</li>
<li>변경 불가능한(immutable) 클래스로 만드는 것을 권장</li>
</ol>
<p>왜 그렇게 해야할까?</p>
<p>기본 생성자야 당연히 새롭게 정의한다면 필요할 것이다. Generated 된 변수면 이에 대한 어노테이션을 정의해주면 된다.</p>
<p>다만, <code>Serializable</code> 인터페이스를 구현해주어야하는데, 왜 직렬화가 가능하도록 만들어야할까?</p>
<h3 id="식별자-클래스에-직렬화가-필요한-이유">식별자 클래스에 직렬화가 필요한 이유<a hidden class="anchor" aria-hidden="true" href="#식별자-클래스에-직렬화가-필요한-이유">#</a></h3>
<p>이는 <code>JPA</code> 가 엔티티를 저장 및 조회 시 식별자를 직렬화해서 사용하기 때문이다.</p>
<p>이 뜻은, 당연히 복합 키에 해당되는 컬럼값들을 직렬화해서 DB에 저장한단 의미가 아니고 JPA 구현체(예: Hibernate)가 내부적으로 엔티티를 관리하는 과정에서 사용한다는 의미이다.</p>
<p>영속성 컨텍스트를 기준으로 보자.</p>
<blockquote>
<p>[!note] 간단히 알아보기 : 영속성 컨텍스트란?</p>
<p>영속성 컨텍스트(Persistence Context)는 JPA가 엔티티를 관리하는 가상의 환경 또는 컨테이너를 뜻한다.</p>
<p>알아서 성능 최적화가 되거나 (1차 캐시) 트랜잭션을 지원한다. 영속성 컨텍스트로 인해 데이터의 영속성이 보장된다.</p></blockquote>
<p>JPA 는 내부적으로 <strong>영속성 컨텍스트에서 내부 맵에서 키로 사용된다.</strong></p>
<p>그렇기 때문에 이것을 직렬화할 필요가 있는 것이다.</p>
<p>그렇지 않다면 객체로 저장해야하는데, 할당받은 객체의 식별번호값이 실제 데이터베이스 내 해당되는 복합키와 동일성이 보장되지 않기 때문이다.</p>
<p>그렇기 때문에 <code>Serializable</code> (직렬화 가능한 것) 을 상속받아야하는 것이고, 이는 곧 <code>성능문제</code> 로 이어질 수 있다.  분산 환경 / 캐시 사용에 문제가 될 수 있기 때문이다. 예를 들면 직렬화 불가능하다고 판단될 경우 <code>Mapping</code> 을 못하게 될 것이고 이는 곧 캐시를 쓰지 못하는 결과로 이어질 것이다.</p>
<h3 id="식별자-클래스에-equals-hashcode가-필요한-이유">식별자 클래스에 <code>equals</code>, <code>hashCode</code>가 필요한 이유<a hidden class="anchor" aria-hidden="true" href="#식별자-클래스에-equals-hashcode가-필요한-이유">#</a></h3>
<p>그렇다면 <code>equals</code>, <code>hashCode</code> 메서드를 구현해야하는 이유도 동일하게 이해될 것이다.</p>
<p>이들은 <strong>영속성 컨텍스트에서 엔티티 간의 동일성 비교를 위해 요구되며, <code>Serializable</code> 과는 독립된 요구사항이다.</strong></p>
<p>결국 모두  <strong>필수사항은 아니나, 성능에 영향이 생길지도 모르기 때문에 되도록이면 구현하도록 하자.</strong></p>


    </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.moozeh.org/tags/spring/">Spring</a></li>
      <li><a href="https://blog.moozeh.org/tags/jpa/">JPA</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.moozeh.org/posts/2025-02-22-spring-jpa-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%80%EC%9E%A5%EB%90%A0%EA%B9%8C-1/">
    <span class="title">« Prev</span>
    <br>
    <span>[Spring JPA] 영속성 컨텍스트 시리즈 (1) - 영속성 컨텍스트와 1차 캐시</span>
  </a>
  <a class="next" href="https://blog.moozeh.org/posts/2025-02-07-spring-jpa-converter-%EB%8A%94-%EC%96%B8%EC%A0%9C-%EC%8D%A8%EC%95%BC%ED%95%98%EB%8A%94%EA%B0%80/">
    <span class="title">Next »</span>
    <br>
    <span>[Spring JPA] Converter 는 언제 써야하는가</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/moozeh">moozeh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
