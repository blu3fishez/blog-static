<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Docker] 도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자 | blog.blu3fishez</title>
<meta name="keywords" content="BaseChest, network">

<meta name="description" content="Docker 자체는 가상화 엔진이다.
하지만 도커가 한번에 하나의 프로그램만 실행시킬 수 있었다면 이렇게까지 인기를 얻진 못했으리라. 여러개의 컨테이너를 올리고, 하나의 컴퓨터 내에서 각각 독립된 환경에서 실행과 네트워킹이 가능하기 때문에 유용하다고 생각했다. 하지만 구체적으로 어떻게 네트워킹하는지에 대해서 생각해보진 못했는데, 이번 기회에 알아보자.
일단, 개개의 컨테이너는 여러가지 환경에 처할 수 있다. 컨테이너가 생성되고 실행되는 환경은 대략적으로 크게 두가지로 정리될 수 있을 것이다.
하나의 Compose 내에서 실행될 때 독립적인 컨테이너로써 실행될 때 개개의 경우의 수에서 각각의 hostname 과 도커 엔진이 제공하는 예약어가 어떻게 작동하는지 기술해보았다.
">
<meta name="author" content="blu3fishez">
<link rel="canonical" href="https://blog.blu3fishez.org/posts/2025/20251030-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EB%B0%8F-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%84-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d3f251795b1b2227fec87dbd9339a39a72025c1e2678c7b78fdbf5213fbef45d.css" integrity="sha256-0/JReVsbIif&#43;yH29kzmjmnICXB4meMe3j9v1IT&#43;&#43;9F0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.blu3fishez.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.blu3fishez.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.blu3fishez.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.blu3fishez.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.blu3fishez.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.blu3fishez.org/posts/2025/20251030-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EB%B0%8F-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%84-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.blu3fishez.org/posts/2025/20251030-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EB%B0%8F-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%84-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/">
  <meta property="og:site_name" content="blog.blu3fishez">
  <meta property="og:title" content="[Docker] 도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자">
  <meta property="og:description" content="Docker 자체는 가상화 엔진이다.
하지만 도커가 한번에 하나의 프로그램만 실행시킬 수 있었다면 이렇게까지 인기를 얻진 못했으리라. 여러개의 컨테이너를 올리고, 하나의 컴퓨터 내에서 각각 독립된 환경에서 실행과 네트워킹이 가능하기 때문에 유용하다고 생각했다. 하지만 구체적으로 어떻게 네트워킹하는지에 대해서 생각해보진 못했는데, 이번 기회에 알아보자.
일단, 개개의 컨테이너는 여러가지 환경에 처할 수 있다. 컨테이너가 생성되고 실행되는 환경은 대략적으로 크게 두가지로 정리될 수 있을 것이다.
하나의 Compose 내에서 실행될 때 독립적인 컨테이너로써 실행될 때 개개의 경우의 수에서 각각의 hostname 과 도커 엔진이 제공하는 예약어가 어떻게 작동하는지 기술해보았다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-30T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-10-30T00:00:00+00:00">
    <meta property="article:tag" content="BaseChest">
    <meta property="article:tag" content="Network">
      <meta property="og:image" content="https://blog.blu3fishez.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.blu3fishez.org/images/papermod-cover.png">
<meta name="twitter:title" content="[Docker] 도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자">
<meta name="twitter:description" content="Docker 자체는 가상화 엔진이다.
하지만 도커가 한번에 하나의 프로그램만 실행시킬 수 있었다면 이렇게까지 인기를 얻진 못했으리라.
여러개의 컨테이너를 올리고, 하나의 컴퓨터 내에서 각각 독립된 환경에서 실행과 네트워킹이 가능하기 때문에 유용하다고 생각했다.
하지만 구체적으로 어떻게 네트워킹하는지에 대해서 생각해보진 못했는데, 이번 기회에 알아보자.
일단, 개개의 컨테이너는 여러가지 환경에 처할 수 있다. 컨테이너가 생성되고 실행되는 환경은 대략적으로 크게 두가지로 정리될 수 있을 것이다.

하나의 Compose  내에서 실행될 때
독립적인 컨테이너로써 실행될 때

개개의 경우의 수에서 각각의 hostname 과 도커 엔진이 제공하는 예약어가 어떻게 작동하는지 기술해보았다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.blu3fishez.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[Docker] 도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자",
      "item": "https://blog.blu3fishez.org/posts/2025/20251030-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EB%B0%8F-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%84-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Docker] 도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자",
  "name": "[Docker] 도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자",
  "description": "Docker 자체는 가상화 엔진이다.\n하지만 도커가 한번에 하나의 프로그램만 실행시킬 수 있었다면 이렇게까지 인기를 얻진 못했으리라. 여러개의 컨테이너를 올리고, 하나의 컴퓨터 내에서 각각 독립된 환경에서 실행과 네트워킹이 가능하기 때문에 유용하다고 생각했다. 하지만 구체적으로 어떻게 네트워킹하는지에 대해서 생각해보진 못했는데, 이번 기회에 알아보자.\n일단, 개개의 컨테이너는 여러가지 환경에 처할 수 있다. 컨테이너가 생성되고 실행되는 환경은 대략적으로 크게 두가지로 정리될 수 있을 것이다.\n하나의 Compose 내에서 실행될 때 독립적인 컨테이너로써 실행될 때 개개의 경우의 수에서 각각의 hostname 과 도커 엔진이 제공하는 예약어가 어떻게 작동하는지 기술해보았다.\n",
  "keywords": [
    "BaseChest", "network"
  ],
  "articleBody": "Docker 자체는 가상화 엔진이다.\n하지만 도커가 한번에 하나의 프로그램만 실행시킬 수 있었다면 이렇게까지 인기를 얻진 못했으리라. 여러개의 컨테이너를 올리고, 하나의 컴퓨터 내에서 각각 독립된 환경에서 실행과 네트워킹이 가능하기 때문에 유용하다고 생각했다. 하지만 구체적으로 어떻게 네트워킹하는지에 대해서 생각해보진 못했는데, 이번 기회에 알아보자.\n일단, 개개의 컨테이너는 여러가지 환경에 처할 수 있다. 컨테이너가 생성되고 실행되는 환경은 대략적으로 크게 두가지로 정리될 수 있을 것이다.\n하나의 Compose 내에서 실행될 때 독립적인 컨테이너로써 실행될 때 개개의 경우의 수에서 각각의 hostname 과 도커 엔진이 제공하는 예약어가 어떻게 작동하는지 기술해보았다.\nlocalhost 로컬 호스트는 명백하다. 어떤 상황이던간에 컨테이너 자신 자체를 가리킨다.\n따라서 localhost 만으로는 다른 컨테이너 혹은 호스트와 제대로 소통할 수 없다.\nhost.docker.internal host.docker.internal 은 도커에서의 환경에서 해당 도커를 실행하는 호스트를 향할 수 있게 해준다.\n예를 들어, 도커에서 호스트에서 실행하는 다른 서버에 접근하고 싶다고 하자.\n![[BaseChest 개발기 1 - host.docker.internal-1761828168099.webp|500]]\n이럴때 어떻게 할까? 앞서 언급된 localhost 라면 컨테이너 그 자체를 가리키기 때문에 실패할 것이다.\n이때, host.docker.internal 내부 도메인을 사용하면 된다. 이는 도커 엔진에서 제공 된다.\n다른 컨테이너를 향할 수 있는가? 두가지의 이슈로 나뉠 수 있다.\n같은 Docker compose 에 속하는 컨테이너일때 아예 무관한 그저 하나의 호스트가 돌리는 연관성 없는 서로 다른 컨테이너일 때 1. 같은 Compose 에 속하는 컨테이너를 찾고싶은 경우 도커 컴포즈는 이를 위해 서비스 명에 대해 호스트 도메인을 할당해준다. 이게 무슨 뜻이냐면\nservices: spring-app: # \u003c-- (1) 이 서비스 이름 build: . # ... nginx-proxy: image: nginx # ... 위와 같이 service 명들이 할당이 되어있다면, 아래와 같이 접근할 수 있다.\nlocation / { # (2) 'spring-app' 서비스 이름을 주소처럼 사용 proxy_pass http://spring-app:8080; } 2. 다른 compose 혹은 관계성이 없는 컨테이너에게 요청을 보내고 싶은 경우 이런 경우 방법이 달라진다. 일반적으로 하나의 Compose 로 묶여있지 않으므로 같은 네트워크로 묶여있지 않다. 방식은 두가지 방법이 있다.\n호스트 경유 방식\n![[도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자-1761830157364.webp|600]]\n이전에 언급된 host.docker.internal 을 이용하는 방법이다.\n조건 : 요청을 받을 컨테이너의 포트가 호스트로 열려있어야 가능하다. 호스트 머신에게 해당 포트로 요청을 하게된다면, 호스트를 경유해서 해당 컨테이너로 요청이 들어가게 된다. 공용 네트워크 방식\n![[도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자-1761830033430.webp|600]]\n도커에서 제공되는 기능인 공용 네트워크를 이용하는 방법이다.\n보다 도커의 기능들을 활용하므로 권장되는 방법일 것이다.\n먼저, 두 컨테이너가 함께 사용할 공용 네트워크를 하나 만들 수 있다. docker network create my-shared-network compose 의 경우, 내가 외부 네트워크에 연결하고자 하는 컴포즈 설정에서 아래와 같이 설정해주면 된다. services: spring-app: # ... networks: - default - my-shared-network # \u003c-- 공용 네트워크 추가 networks: default: my-shared-network: external: true # \u003c-- 외부에서 만든 네트워크라고 알려줌 compose 가 아닌 단일 컨테이너의 경우 명령어를 통해 수동으로 공용 네트워크를 생성하고 두 컨테이너를 해당 네트워크에 연결해주면 된다. 이때, --name service-a 라는 부분이 있는데, 이 이름을 통해 통신할 수 있다. docker run -d --name service-a --network my-shared-network [이미지 1 이름] docker run -d --name service-b --network my-shared-network [이미지 2 이름] 전자의 경우 가장 간단하며, 후자의 경우 네트워크가 깔끔하게 관리될 수 있다는 점에서 일장일단인듯.\n질문 : 컨테이너들은 아예 외부를 향해 네트워크를 요청할 수 있는가? 프로젝트가 커지면 데이터 안정성을 위해 DB 등을 별도의 서버로 분리할 수도 있을 것이다.\n당연히 가능하며, 이때 호스트는 라우터로써 작동된다.\n컨테이너가 외부를 향하는 네트워크 요청을 호스트 머신으로 전달한다. 호스트 머신은 이 요청을 받아 자신의 IP를 사용해 연결된 외부 인터넷으로 요청을 보낸다. (이 과정을 NAT라고 부른다.) 응답을 받고, 호스트 머신은 컨테이너로 결과를 반환해준다. ",
  "wordCount" : "517",
  "inLanguage": "en",
  "image": "https://blog.blu3fishez.org/images/papermod-cover.png","datePublished": "2025-10-30T00:00:00Z",
  "dateModified": "2025-10-30T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "blu3fishez"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.blu3fishez.org/posts/2025/20251030-%EB%8F%84%EC%BB%A4-%EC%BB%B4%ED%8F%AC%EC%A6%88-%EB%B0%8F-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B0%84-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.blu3fishez",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.blu3fishez.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.blu3fishez.org/" accesskey="h" title="blog.blu3fishez (Alt + H)">blog.blu3fishez</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.blu3fishez.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.blu3fishez.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.blu3fishez.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.blu3fishez.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.blu3fishez.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      [Docker] 도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자
    </h1>
    <div class="post-meta"><span title='2025-10-30 00:00:00 +0000 UTC'>October 30, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;blu3fishez

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#localhost" aria-label="localhost">localhost</a></li>
                <li>
                    <a href="#hostdockerinternal" aria-label="host.docker.internal">host.docker.internal</a></li>
                <li>
                    <a href="#%eb%8b%a4%eb%a5%b8-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ed%96%a5%ed%95%a0-%ec%88%98-%ec%9e%88%eb%8a%94%ea%b0%80" aria-label="다른 컨테이너를 향할 수 있는가?">다른 컨테이너를 향할 수 있는가?</a><ul>
                        
                <li>
                    <a href="#1-%ea%b0%99%ec%9d%80-compose-%ec%97%90-%ec%86%8d%ed%95%98%eb%8a%94-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%a5%bc-%ec%b0%be%ea%b3%a0%ec%8b%b6%ec%9d%80-%ea%b2%bd%ec%9a%b0" aria-label="1. 같은 Compose 에 속하는 컨테이너를 찾고싶은 경우">1. 같은 Compose 에 속하는 컨테이너를 찾고싶은 경우</a></li>
                <li>
                    <a href="#2-%eb%8b%a4%eb%a5%b8-compose-%ed%98%b9%ec%9d%80-%ea%b4%80%ea%b3%84%ec%84%b1%ec%9d%b4-%ec%97%86%eb%8a%94-%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%ec%97%90%ea%b2%8c-%ec%9a%94%ec%b2%ad%ec%9d%84-%eb%b3%b4%eb%82%b4%ea%b3%a0-%ec%8b%b6%ec%9d%80-%ea%b2%bd%ec%9a%b0" aria-label="2. 다른 compose 혹은 관계성이 없는 컨테이너에게 요청을 보내고 싶은 경우">2. 다른 compose 혹은 관계성이 없는 컨테이너에게 요청을 보내고 싶은 경우</a></li></ul>
                </li>
                <li>
                    <a href="#%ec%a7%88%eb%ac%b8--%ec%bb%a8%ed%85%8c%ec%9d%b4%eb%84%88%eb%93%a4%ec%9d%80-%ec%95%84%ec%98%88-%ec%99%b8%eb%b6%80%eb%a5%bc-%ed%96%a5%ed%95%b4-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac%eb%a5%bc-%ec%9a%94%ec%b2%ad%ed%95%a0-%ec%88%98-%ec%9e%88%eb%8a%94%ea%b0%80" aria-label="질문 : 컨테이너들은 아예 외부를 향해 네트워크를 요청할 수 있는가?">질문 : 컨테이너들은 아예 외부를 향해 네트워크를 요청할 수 있는가?</a>
                </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><p><code>Docker</code> 자체는 가상화 엔진이다.</p>
<p>하지만 도커가 한번에 하나의 프로그램만 실행시킬 수 있었다면 이렇게까지 인기를 얻진 못했으리라.
여러개의 컨테이너를 올리고, 하나의 컴퓨터 내에서 각각 독립된 환경에서 실행과 네트워킹이 가능하기 때문에 유용하다고 생각했다.
하지만 구체적으로 어떻게 네트워킹하는지에 대해서 생각해보진 못했는데, 이번 기회에 알아보자.</p>
<p>일단, 개개의 컨테이너는 여러가지 환경에 처할 수 있다. 컨테이너가 생성되고 실행되는 환경은 대략적으로 크게 두가지로 정리될 수 있을 것이다.</p>
<ul>
<li>하나의 <code>Compose</code>  내에서 실행될 때</li>
<li>독립적인 컨테이너로써 실행될 때</li>
</ul>
<p>개개의 경우의 수에서 각각의 <code>hostname</code> 과 도커 엔진이 제공하는 예약어가 어떻게 작동하는지 기술해보았다.</p>
<h2 id="localhost"><code>localhost</code><a hidden class="anchor" aria-hidden="true" href="#localhost">#</a></h2>
<p>로컬 호스트는 명백하다. 어떤 상황이던간에 컨테이너 자신 자체를 가리킨다.</p>
<p>따라서 <code>localhost</code> 만으로는 다른 컨테이너 혹은 호스트와 제대로 소통할 수 없다.</p>
<h2 id="hostdockerinternal"><code>host.docker.internal</code><a hidden class="anchor" aria-hidden="true" href="#hostdockerinternal">#</a></h2>
<p><code>host.docker.internal</code> 은 도커에서의 환경에서 해당 도커를 실행하는 호스트를 향할 수 있게 해준다.</p>
<p>예를 들어, 도커에서 호스트에서 실행하는 다른 서버에 접근하고 싶다고 하자.</p>
<img src="/assets/images/BaseChest%20%EA%B0%9C%EB%B0%9C%EA%B8%B0%201%20-%20host.docker.internal-1761828168099.webp" alt="BaseChest 개발기 1 - host.docker.internal-1761828168099" loading="lazy" style="width: 500px;">
<p>이럴때 어떻게 할까? 앞서 언급된 <code>localhost</code> 라면 컨테이너 그 자체를 가리키기 때문에 실패할 것이다.</p>
<p>이때, <code>host.docker.internal</code> 내부 도메인을 사용하면 된다. 이는 도커 엔진에서 제공 된다.</p>
<h2 id="다른-컨테이너를-향할-수-있는가">다른 컨테이너를 향할 수 있는가?<a hidden class="anchor" aria-hidden="true" href="#다른-컨테이너를-향할-수-있는가">#</a></h2>
<p>두가지의 이슈로 나뉠 수 있다.</p>
<ul>
<li>같은 <code>Docker compose</code> 에 속하는 컨테이너일때</li>
<li>아예 무관한 그저 하나의 호스트가 돌리는 연관성 없는 서로 다른 컨테이너일 때</li>
</ul>
<h3 id="1-같은-compose-에-속하는-컨테이너를-찾고싶은-경우">1. 같은 Compose 에 속하는 컨테이너를 찾고싶은 경우<a hidden class="anchor" aria-hidden="true" href="#1-같은-compose-에-속하는-컨테이너를-찾고싶은-경우">#</a></h3>
<p>도커 컴포즈는 이를 위해 서비스 명에 대해 호스트 도메인을 할당해준다. 이게 무슨 뜻이냐면</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">services</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">spring-app</span><span class="p">:</span><span class="w"> </span><span class="c"># &lt;-- (1) 이 서비스 이름</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># ...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">nginx-proxy</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c"># ...</span><span class="w">
</span></span></span></code></pre></div><p>위와 같이 service 명들이 할당이 되어있다면, 아래와 같이 접근할 수 있다.</p>
<pre tabindex="0"><code>location / {
    # (2) &#39;spring-app&#39; 서비스 이름을 주소처럼 사용
    proxy_pass http://spring-app:8080; 
}
</code></pre><h3 id="2-다른-compose-혹은-관계성이-없는-컨테이너에게-요청을-보내고-싶은-경우">2. 다른 compose 혹은 관계성이 없는 컨테이너에게 요청을 보내고 싶은 경우<a hidden class="anchor" aria-hidden="true" href="#2-다른-compose-혹은-관계성이-없는-컨테이너에게-요청을-보내고-싶은-경우">#</a></h3>
<p>이런 경우 방법이 달라진다. 일반적으로 하나의 <code>Compose</code> 로 묶여있지 않으므로 같은 네트워크로 묶여있지 않다. 방식은 두가지 방법이 있다.</p>
<p><strong>호스트 경유 방식</strong></p>
<img src="/assets/images/%EB%8F%84%EC%BB%A4%20%EC%BB%B4%ED%8F%AC%EC%A6%88%20%EB%B0%8F%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%20%EA%B0%84%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9%EC%97%90%20%EB%8C%80%ED%95%B4%EC%84%9C%20%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-1761830157364.webp" alt="도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자-1761830157364" loading="lazy" style="width: 600px;">
<p>이전에 언급된 <code>host.docker.internal</code> 을 이용하는 방법이다.</p>
<ul>
<li>조건 : 요청을 받을 컨테이너의 포트가 호스트로 열려있어야 가능하다.</li>
<li>호스트 머신에게 해당 포트로 요청을 하게된다면, 호스트를 경유해서 해당 컨테이너로 요청이 들어가게 된다.</li>
</ul>
<p><strong>공용 네트워크 방식</strong></p>
<img src="/assets/images/%EB%8F%84%EC%BB%A4%20%EC%BB%B4%ED%8F%AC%EC%A6%88%20%EB%B0%8F%20%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%20%EA%B0%84%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9%EC%97%90%20%EB%8C%80%ED%95%B4%EC%84%9C%20%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90-1761830033430.webp" alt="도커 컴포즈 및 컨테이너 간 네트워킹에 대해서 알아보자-1761830033430" loading="lazy" style="width: 600px;">
<p>도커에서 제공되는 기능인 공용 네트워크를 이용하는 방법이다.</p>
<p>보다 도커의 기능들을 활용하므로 권장되는 방법일 것이다.</p>
<ul>
<li>먼저, 두 컨테이너가 함께 사용할 공용 네트워크를 하나 만들 수 있다.</li>
</ul>
<pre tabindex="0"><code>docker network create my-shared-network
</code></pre><ul>
<li><code>compose</code> 의 경우, 내가 외부 네트워크에 연결하고자 하는 컴포즈 설정에서 아래와 같이 설정해주면 된다.</li>
</ul>
<pre tabindex="0"><code>services:
  spring-app:
    # ...
    networks:
      - default
      - my-shared-network # &lt;-- 공용 네트워크 추가

networks:
  default:
  my-shared-network:
    external: true # &lt;-- 외부에서 만든 네트워크라고 알려줌
</code></pre><ul>
<li><code>compose</code> 가 아닌 단일 컨테이너의 경우 명령어를 통해 수동으로 공용 네트워크를 생성하고 두 컨테이너를 해당 네트워크에 연결해주면 된다.</li>
<li>이때, <code>--name service-a</code> 라는 부분이 있는데, 이 이름을 통해 통신할 수 있다.</li>
</ul>
<pre tabindex="0"><code>docker run -d --name service-a --network my-shared-network [이미지 1 이름]
docker run -d --name service-b --network my-shared-network [이미지 2 이름]
</code></pre><p>전자의 경우 가장 간단하며, 후자의 경우 네트워크가 깔끔하게 관리될 수 있다는 점에서 일장일단인듯.</p>
<h2 id="질문--컨테이너들은-아예-외부를-향해-네트워크를-요청할-수-있는가">질문 : 컨테이너들은 아예 외부를 향해 네트워크를 요청할 수 있는가?<a hidden class="anchor" aria-hidden="true" href="#질문--컨테이너들은-아예-외부를-향해-네트워크를-요청할-수-있는가">#</a></h2>
<p>프로젝트가 커지면 데이터 안정성을 위해 DB 등을 별도의 서버로 분리할 수도 있을 것이다.</p>
<p>당연히 가능하며, 이때 호스트는 라우터로써 작동된다.</p>
<ol>
<li>컨테이너가 외부를 향하는 네트워크 요청을 호스트 머신으로 전달한다.</li>
<li>호스트 머신은 이 요청을 받아 자신의 IP를 사용해 연결된 외부 인터넷으로 요청을 보낸다. (이 과정을 NAT라고 부른다.)</li>
<li>응답을 받고, 호스트 머신은 컨테이너로 결과를 반환해준다.</li>
</ol>


    </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.blu3fishez.org/tags/basechest/">BaseChest</a></li>
      <li><a href="https://blog.blu3fishez.org/tags/network/">Network</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://blog.blu3fishez.org/posts/2025/20250827-%EC%83%81%EB%B0%98%EA%B8%B0-%ED%9A%8C%EA%B3%A0/">
    <span class="title">Next »</span>
    <br>
    <span>2025년 상반기 회고</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/blu3fishez">blu3fishez</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
