<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[ 백준 25402 ] 트리와 쿼리 : C&#43;&#43; 풀이 | blog.moozeh</title>
<meta name="keywords" content="">
<meta name="description" content="트리의 특성을 이용한 연결그래프 탐색문제입니다.">
<meta name="author" content="moozeh">
<link rel="canonical" href="https://blog.moozeh.org/posts/2023/2023-11-12-query-tree/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.moozeh.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.moozeh.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.moozeh.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.moozeh.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.moozeh.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.moozeh.org/posts/2023/2023-11-12-query-tree/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.moozeh.org/posts/2023/2023-11-12-query-tree/">
  <meta property="og:site_name" content="blog.moozeh">
  <meta property="og:title" content="[ 백준 25402 ] 트리와 쿼리 : C&#43;&#43; 풀이">
  <meta property="og:description" content="트리의 특성을 이용한 연결그래프 탐색문제입니다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-12T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-11-12T00:00:00+00:00">
      <meta property="og:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:title" content="[ 백준 25402 ] 트리와 쿼리 : C&#43;&#43; 풀이">
<meta name="twitter:description" content="트리의 특성을 이용한 연결그래프 탐색문제입니다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.moozeh.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[ 백준 25402 ] 트리와 쿼리 : C++ 풀이",
      "item": "https://blog.moozeh.org/posts/2023/2023-11-12-query-tree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[ 백준 25402 ] 트리와 쿼리 : C++ 풀이",
  "name": "[ 백준 25402 ] 트리와 쿼리 : C\u002b\u002b 풀이",
  "description": "트리의 특성을 이용한 연결그래프 탐색문제입니다.",
  "keywords": [
    
  ],
  "articleBody": "내가 생각한 솔루션 1. 분리집합 문제를 보자마자 일단 아! 분리집합 문제구나 라고 생각은 했음.\n각 영역의 분리집합을 구한 후, 분리집합의 개수 별로 nC2의 값을 표현하기 가 구현내용이 아닐지.. 하고.\n예를들면, 문제 예시의 트리와, K = 6, S_k = { 1,2,3,4,5,6 } 인 경우\n{ 1, 2, 3, 5 } 와 {4, 6}으로 두 영역이 나뉘므로,\n4C2 + 2C2 = 6 + 1 = 7 가 정답인 것이다.\n각 영역별로 수행한다고 치면 최악의 경우 O(N) 만큼 걸릴 것임.\n이렇게 단순하게 생각하면 사실 풀 수 있지만, 애로사항이 있다.\n위의 시간 복잡도는 정확하지 않다. 쿼리가 있기 때문이다.\n2. DFS 그래서 DFS로 해볼까? 하고 생각해봤다.\nS_K 마다 탐색을 한다.\n자식노드가 없는 경우는 스킵한다.\n이미 방문한 점도 스킵한다.\n방문 수 : O(N) 이기 때문에 이 방법도 사실상 최적화엔 실패다.\n해설을 통한 솔루션 위 방식대로하면 결국 각 노드에서 모든 간선 을 둘러보게 되는 단점이 있고, 이는 O(N) 만큼 소모되게 만드는 단점이 있다.\n쿼리가 하나면 상관없지만 쿼리가 10만개나 되니, 결국 전체 쿼리에 등장하는 K의 개수가 최대 백만인 점을 이용해 O(쿼리중 나오는 전체 K 집합의 원소 수)로 단순화시켜야한다.\nN의 크기에 영향을 받지 않고 순수하게 K만 살펴보기 위해서는 트리의 구조를 이용해야한다.\n트리가 가지는 성질은 자신 노드가 루트가 아니라면, 부모노드는 오로지 하나라는 점이다. 이렇게 되면 순전히 K개의 노드와, 그의 부모노드만 확인하면 되게 되므로, O(N + 쿼리중 나오는 전체 K집합의 원소 수)가 되게 된다.\n각 K의 부모노드를 확인해가면서, 분리집합으로 어떤 트리에 어떻게 속하는지 기록을 하며 루트노드가 될 노드에게 노드의 개수를 전달해주면 해결이다.\n트리의 특성을 활용하는 문제였다. 많이 나에겐 어려운 것 같으니 골드 하위 트리문제를 좀 더 풀어봐야할 것 같다.\n소스코드 s[] 배열을 memset() 을 통해 초기화 하지 않고, 쓰고 난 후 다시 false 값으로 되돌려 주면 AC 시간을 많이 단축 시킬 수 있습니다.\n#include #include using namespace std; vector\u003cint\u003e tree[250001]; bool visit[250001]; int parent[250001]; // 분리집합 int cnt[250001]; // 각 지점을 루트로 하는 트리의 노드 개수 입니다. bool s[250001]; int tree_parent[250001]; void process(int node) { // dfs로 전처리 하는 과정 visit[node] = true; for (int i : tree[node]) { if (!visit[i]) { process(i); tree_parent[i] = node; } } } int find(int t) { if (parent[t] == t) return t; return parent[t] = find(parent[t]); } void uni(int a, int b) { if (a \u003e b) { int swp; swp = a; a = b; b = swp; } parent[b] = a; cnt[a] += cnt[b]; cnt[b] = -1; } int main() { cin.tie(0); cout.tie(0)-\u003esync_with_stdio(0); int n, q; cin \u003e\u003e n; for (int i = 0; i \u003c n - 1; ++i) { int a, b; cin \u003e\u003e a \u003e\u003e b; tree[a].push_back(b); tree[b].push_back(a); } process(1); // 최소 노드의 개수는 1일테니 1을 루트로 정의한다. cin \u003e\u003e q; while (q--) { int k; cin \u003e\u003e k; vector\u003cint\u003e arr; for (int i = 0; i \u003c k; ++i) { int t; cin \u003e\u003e t; parent[t] = t; cnt[t] = 1; s[t] = true; arr.push_back(t); } long long ans = 0; for (int t : arr) { if (s[tree_parent[t]]) { uni(find(t), find(tree_parent[t])); } } for (int t : arr) { s[t] = false; // 쓰고 바로 마킹을 지우면 memset을 할 필요가 없어짐. if (cnt[t] \u003e 1) { ans += (long long)cnt[t] * (cnt[t] - 1) / 2; } } cout \u003c\u003c ans \u003c\u003c '\\n'; } } ",
  "wordCount" : "518",
  "inLanguage": "en",
  "image": "https://blog.moozeh.org/images/papermod-cover.png","datePublished": "2023-11-12T00:00:00Z",
  "dateModified": "2023-11-12T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "moozeh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.moozeh.org/posts/2023/2023-11-12-query-tree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.moozeh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.moozeh.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.moozeh.org/" accesskey="h" title="blog.moozeh (Alt + H)">blog.moozeh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.moozeh.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.moozeh.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.moozeh.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      [ 백준 25402 ] 트리와 쿼리 : C&#43;&#43; 풀이
    </h1>
    <div class="post-description">
      트리의 특성을 이용한 연결그래프 탐색문제입니다.
    </div>
    <div class="post-meta"><span title='2023-11-12 00:00:00 +0000 UTC'>November 12, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;moozeh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%eb%82%b4%ea%b0%80-%ec%83%9d%ea%b0%81%ed%95%9c-%ec%86%94%eb%a3%a8%ec%85%98" aria-label="내가 생각한 솔루션">내가 생각한 솔루션</a><ul>
                        
                <li>
                    <a href="#1-%eb%b6%84%eb%a6%ac%ec%a7%91%ed%95%a9" aria-label="1. 분리집합">1. 분리집합</a></li>
                <li>
                    <a href="#2-dfs" aria-label="2. DFS">2. DFS</a></li></ul>
                </li>
                <li>
                    <a href="#%ed%95%b4%ec%84%a4%ec%9d%84-%ed%86%b5%ed%95%9c-%ec%86%94%eb%a3%a8%ec%85%98" aria-label="해설을 통한 솔루션">해설을 통한 솔루션</a></li>
                <li>
                    <a href="#%ec%86%8c%ec%8a%a4%ec%bd%94%eb%93%9c" aria-label="소스코드">소스코드</a>
                </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><h2 id="내가-생각한-솔루션">내가 생각한 솔루션<a hidden class="anchor" aria-hidden="true" href="#내가-생각한-솔루션">#</a></h2>
<h3 id="1-분리집합">1. 분리집합<a hidden class="anchor" aria-hidden="true" href="#1-분리집합">#</a></h3>
<p>문제를 보자마자 일단 아! 분리집합 문제구나 라고 생각은 했음.</p>
<p>각 영역의 분리집합을 구한 후, 분리집합의 개수 별로 nC2의 값을 표현하기 가 구현내용이 아닐지.. 하고.</p>
<p>예를들면, 문제 예시의 트리와, <code>K = 6, S_k = { 1,2,3,4,5,6 }</code> 인 경우</p>
<p><code>{ 1, 2, 3, 5 }</code> 와 <code>{4, 6}</code>으로 두 영역이 나뉘므로,</p>
<p><code>4C2 + 2C2 = 6 + 1 = 7</code> 가 정답인 것이다.</p>
<p>각 영역별로 수행한다고 치면 최악의 경우 O(N) 만큼 걸릴 것임.</p>
<p>이렇게 단순하게 생각하면 사실 풀 수 있지만, 애로사항이 있다.</p>
<p>위의 시간 복잡도는 정확하지 않다. <strong>쿼리가 있기 때문이다.</strong></p>
<h3 id="2-dfs">2. DFS<a hidden class="anchor" aria-hidden="true" href="#2-dfs">#</a></h3>
<p>그래서 DFS로 해볼까? 하고 생각해봤다.</p>
<blockquote>
<p>S_K 마다 탐색을 한다.</p>
<p>자식노드가 없는 경우는 스킵한다.</p>
<p>이미 방문한 점도 스킵한다.</p></blockquote>
<p>방문 수 : <code>O(N)</code> 이기 때문에 이 방법도 사실상 최적화엔 실패다.</p>
<h2 id="해설을-통한-솔루션">해설을 통한 솔루션<a hidden class="anchor" aria-hidden="true" href="#해설을-통한-솔루션">#</a></h2>
<p>위 방식대로하면 결국 각 노드에서 모든 간선 을 둘러보게 되는 단점이 있고, 이는 <code>O(N)</code> 만큼 소모되게 만드는 단점이 있다.</p>
<p>쿼리가 하나면 상관없지만 쿼리가 10만개나 되니, 결국 전체 쿼리에 등장하는 K의 개수가 최대 백만인 점을 이용해 <code>O(쿼리중 나오는 전체 K 집합의 원소 수)</code>로 단순화시켜야한다.</p>
<p>N의 크기에 영향을 받지 않고 순수하게 K만 살펴보기 위해서는 트리의 구조를 이용해야한다.</p>
<p>트리가 가지는 성질은 자신 노드가 루트가 아니라면, 부모노드는 오로지 하나라는 점이다.
이렇게 되면 순전히 K개의 노드와, 그의 부모노드만 확인하면 되게 되므로, <code>O(N + 쿼리중 나오는 전체 K집합의 원소 수)</code>가 되게 된다.</p>
<p>각 K의 부모노드를 확인해가면서, 분리집합으로 어떤 트리에 어떻게 속하는지 기록을 하며 루트노드가 될 노드에게 노드의 개수를 전달해주면 해결이다.</p>
<p>트리의 특성을 활용하는 문제였다. 많이 나에겐 어려운 것 같으니 골드 하위 트리문제를 좀 더 풀어봐야할 것 같다.</p>
<h2 id="소스코드">소스코드<a hidden class="anchor" aria-hidden="true" href="#소스코드">#</a></h2>
<p><code>s[]</code> 배열을 <code>memset()</code> 을 통해 초기화 하지 않고, 쓰고 난 후 다시 <code>false</code> 값으로 되돌려 주면 AC 시간을 많이 단축 시킬 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;vector&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="mi">250001</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">visit</span><span class="p">[</span><span class="mi">250001</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">parent</span><span class="p">[</span><span class="mi">250001</span><span class="p">];</span> <span class="c1">// 분리집합
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">250001</span><span class="p">];</span> <span class="c1">// 각 지점을 루트로 하는 트리의 노드 개수 입니다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">s</span><span class="p">[</span><span class="mi">250001</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">tree_parent</span><span class="p">[</span><span class="mi">250001</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// dfs로 전처리 하는 과정
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">visit</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">process</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="n">tree_parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">t</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">uni</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">swp</span><span class="p">;</span> <span class="n">swp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">swp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">parent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cnt</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">cnt</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">tree</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">process</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 최소 노드의 개수는 1일테니 1을 루트로 정의한다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">k</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">t</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">parent</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">cnt</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">arr</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kt">long</span> <span class="kt">long</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">tree_parent</span><span class="p">[</span><span class="n">t</span><span class="p">]])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">uni</span><span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">find</span><span class="p">(</span><span class="n">tree_parent</span><span class="p">[</span><span class="n">t</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">t</span> <span class="p">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 쓰고 바로 마킹을 지우면 memset을 할 필요가 없어짐.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">ans</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cnt</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

    </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.moozeh.org/posts/2023/2023-11-15-text-underline/">
    <span class="title">« Prev</span>
    <br>
    <span>[ CSS ] text underline 의 높이 조절, 굵기 설정하기</span>
  </a>
  <a class="next" href="https://blog.moozeh.org/posts/2023/2023-11-03-typescript-interface/">
    <span class="title">Next »</span>
    <br>
    <span>[ TS ] 타입스크립트에서 타이핑 하기 귀찮은데요 (Typescript as 키워드)</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/moozeh">moozeh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
