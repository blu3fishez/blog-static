<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[ 백준 1006 ] 습격자 초라기 : C&#43;&#43; 풀이 | blog.moozeh</title>
<meta name="keywords" content="">
<meta name="description" content="백준 1006번 문제 풀이 입니다.">
<meta name="author" content="moozeh">
<link rel="canonical" href="https://blog.moozeh.org/posts/2023/2023-12-26-boj1006/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.moozeh.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.moozeh.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.moozeh.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.moozeh.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.moozeh.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.moozeh.org/posts/2023/2023-12-26-boj1006/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.moozeh.org/posts/2023/2023-12-26-boj1006/">
  <meta property="og:site_name" content="blog.moozeh">
  <meta property="og:title" content="[ 백준 1006 ] 습격자 초라기 : C&#43;&#43; 풀이">
  <meta property="og:description" content="백준 1006번 문제 풀이 입니다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-26T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-12-26T00:00:00+00:00">
      <meta property="og:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:title" content="[ 백준 1006 ] 습격자 초라기 : C&#43;&#43; 풀이">
<meta name="twitter:description" content="백준 1006번 문제 풀이 입니다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.moozeh.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[ 백준 1006 ] 습격자 초라기 : C++ 풀이",
      "item": "https://blog.moozeh.org/posts/2023/2023-12-26-boj1006/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[ 백준 1006 ] 습격자 초라기 : C++ 풀이",
  "name": "[ 백준 1006 ] 습격자 초라기 : C\u002b\u002b 풀이",
  "description": "백준 1006번 문제 풀이 입니다.",
  "keywords": [
    
  ],
  "articleBody": "문제 접근 원형 타일채우기 DP 라고 생각하면 쉽다. 발상이 어려워서 플레티넘3 이 아닌가 조심스레 추측한다.\n해결방법 타일 채우기 문제와 같이 생각을 해보자. 타일을 채우거나 그렇지 않거나만을 따져서 DP 테이블을 잘 짰다면, 경계선에 대한 부분은 경우의 수로 아예 나누어 선형 DP 로 바꾸어 풀어보도록 하자. 타일을 나누는 법? 내가 이부분을 생각못해서, 다른 블로그를 참고했다.\n타일을 나누는 방법에는 총 3가지 경우의 수가 있을 것이다.\n현재 열을 기준으로 윗쪽만 채웠을 경우 (1행만) - a 현재 열을 기준으로 아랫쪽만 채웠을 경우 (2행만) - b 현재 열을 기준으로 윗쪽 아랫쪽 둘다 채웠을 경우 (둘다) - c 이런식으로 열을 1부터 N열 까지 채워나가다보면 선형적으로 풀 수가 있다.\na 경우의 점화식은 이렇게 될 것이다. 이때 a_n 은 n번째 행의 a 값이라는 뜻이다.\na_n = c_n-1 + 1 // 그냥 n행의 윗부분 한칸만 점령한 경우 if (n, 0) + (n-1, 0) \u003c= w // 현재 열의 윗쪽 + 해당 칸의 왼쪽 칸을 같이 점령할 수 있는 경우 a_n = min(a_n, b_n-1 + 1) // if 문의 점령을 하게 딱 맞추면 남은 칸은 b_n-1 이 된다. 위의 경우를 그림으로 표현해보면 아래와 같다.\n![[2023-12-26-boj1006-20241220150420110.webp]]\na는 N행에 위에만 칠해져야한다. 기본적인 경우는 이렇게 될 것이다. 한칸만 칠하면 되니까 근데 이제 (n-1, 0) 과 (n, 0) 을 한번에 같이 칠할 수(나누어 점령) 있다면 이렇게 될 것이다.\n![[2023-12-26-boj1006-20241220150428269.webp]]\nb 경우도 점화식은 a와 크게 다르지 않다. 위의 경우와 뒤집어 생각할 수 있을 것이다.\nb_n = c_n-1 + 1 // 이 경우도 그냥 n행의 밑부분을 점령한 경우 if (n, 1) + (n-1, 1) \u003c= w b_n = min(b_n, a_n-1 + 1) c의 경우는 쫌 다른데, 일단은 a_n 과 b_n 을 먼저 구하고 나중에 구해야한다. 왜냐하면 c_n 이 a_n + 1 (그냥 나머지칸을 칠하는 경우) 가 최소 값이 될 수도 있기 때문이다.\n또는 그냥 한번에 N행의 두칸을 한번에 점령할수도 있다.\n또는 (N, 0) 과 (N-1, 0) / (N, 1) 과 (N-1, 1) 을 각각 한 부대가 점령할 수도 있을 것이다.\n// 본 코드는 의사 코드다. c_n = min(c_n-1 + 2, a_n + 1, b_n + 1) if (n, 1) + (n, 0) \u003c= w c_n = min(c_n-1 + 1, c_n) if (n, 1) + (n, 0) \u003c= w and (n-1, 1) + (n-1, 0) \u003c= w c_n = min(c_n, c_n-2 + 2) ![[2023-12-26-boj1006-20241220150436218.webp]]\n![[2023-12-26-boj1006-20241220150450303.webp]]\n![[2023-12-26-boj1006-20241220150501121.webp]]\n![[2023-12-26-boj1006-20241220150524902.webp]]\n원형 구조는 어떻게 해결하나요? 타일을 나누는 방법을 올바르게 생각했다면 원형 구조도 자연스레 해결이 된다.\n끝부분과 처음부분을 걸쳐서 생각해보는 것이다.\n어쨌던 입력으로 받은 배열은 선형적이니 선형적으로 생각할 때, 처음과 끝부분이 있겠다.\n이 처음과 끝 부분에 걸쳐서 나누어 점령을 할 수 있는지 경우의 수를 나누는 것이다.\n그렇게한다면 총 4개의 경우의 수가 생긴다.\n처음 - 끝 부분에 걸쳐서 점령하지 않는 경우 처음 - 끝 부분 열의 첫번째 행 칸 두곳을 한 부대가 점령하는 경우 처음 - 끝 부분 열의 두번째 행 칸 두곳을 한 부대가 점령하는 경우 2, 3 모두가 해당되는 경우. 해당 되는 경우를 모두 생각하게 되면 각각의 경우에 적용해야할 초기 값이 다르단 걸 인지할 것이다.\n1의 경우의 수 a_1(맨앞) 과 b_1 모두 1이고, c_1은 (1, 0), (1, 1) 의 값에 따라(두 곳을 한 부대만으로 점령이 가능한지를 생각.) 2 또는 1이 결정된다.\n이후 점화식에 따라 DP 테이블을 채우고, c_n 값이 정답의 후보값이 됩니다.\n2의 경우의 수 a_1은 0이다. 시작 시 미리 점령한 타일은 나중에 더해줄 것이다.\nb_1의 경우의 수는 존재하지 않음. 이미 (1, 0) 이 점령되었기 때문에.\nc_1은 1이 된다. 이 또한 (1, 0) 이 점령 되었기 때문에, c_1은 이곳에 (1, 1)만을 채우는 경우 밖에 존재하지 않는다.\n이후 점화식에 따라 DP 테이블을 채우게 되면, (n, 0) 이 이미 점령 되어 있기 때문에, b_n + 1 의 값이 후보값이 됩니다! (+1을 하는 이유는 시작 시 미리 점령한 타일을 나중에 더해주기 때문입니다.)\n3의 경우의 수 2와 동일하다.\na_1은 존재할 수 없고, b_1은 0이다. 시작 시 미리 점령한 타일은 나중에 더해준다고 가정한다.\nc_1은 1이된다. 이또한 위와 같은 이유에서다.\n2와 마찬가지로 a_n + 1 의 값이 후보값이 됩니다.\n4의 경우의 수 a_1과 b_1은 존재할 수 없고, c_1이 0이 된다.\n(1, 1) 과 (1, 0) 이 모두 시작 시 점령되었기 때문이다.\n정답의 후보값은 c_n-1 + 2 가 됩니다.\n내가 생각하지 못한 것 1. 타일을 채우는 경우의 수를 잘못 나누었다. 이게 무슨 소리냐면, 해당 타일이 하나만 차지하는지, 다른 타일과 나누어서 차지하고 있는지를 내가 나누었다.\n위와 같은 타일채우기 문제에서는 이미 차지하고 있는가 여부를 생각하고, 한번에 채울 때 나누어 채우는 방식으로 DP 테이블을 채워 나가야함을 인지하자!\n2. 원형 DP라고 생각하고 여러번 DP를 돌려야한다고 생각했다. 이는 1번 문제와 같이 대응되는데, 원형 DP이고 아니고 간에, 타일을 이미 채웠다면 이를 생각할 필요 없이 그냥 경우의 수로 나누어서 풀면 되는 문제였다.\n소스 코드 #include #include #include using namespace std; int dp[3][10001]; // 타일 문제 처럼 해당 행에 어느부분을 채우는가로 나누어야한다. int map[10001][2]; int n, w; const int INF = 987654321; void solve() { // 2열부터 시작해야함. // 그러려면 1열까진 내용을 다 채워놔야겠지 for (int i = 2; i \u003c= n; ++i) { // 기본값 세팅 dp[0][i] = dp[2][i - 1] + 1; dp[1][i] = dp[2][i - 1] + 1; if (map[i][0] + map[i][1] \u003c= w) { dp[2][i] = dp[2][i - 1] + 1; } else dp[2][i] = dp[2][i - 1] + 2; if (map[i - 1][0] + map[i][0] \u003c= w \u0026\u0026 map[i - 1][1] + map[i][1] \u003c= w) { dp[2][i] = min(dp[2][i], dp[2][i - 2] + 2); } if (map[i][0] + map[i - 1][0] \u003c= w) { dp[0][i] = min(dp[0][i], dp[1][i - 1] + 1); } if (map[i][1] + map[i - 1][1] \u003c= w) { dp[1][i] = min(dp[1][i], dp[0][i - 1] + 1); } dp[2][i] = min(dp[2][i], min(dp[1][i] + 1, dp[0][i] + 1)); } } int main() { cout.tie(0); cin.tie(0)-\u003esync_with_stdio(0); int tc; cin \u003e\u003e tc; while (tc--) { cin \u003e\u003e n \u003e\u003e w; for (int j = 0; j \u003c 2; ++j) { for (int i = 1; i \u003c= n; ++i) { cin \u003e\u003e map[i][j]; } } int ans; // 시작 case 4개. // 끝 - 시작 부분에 특수부대를 걸치지 않은 경우 for (int i = 0; i \u003c 3; ++i) memset(dp[i], 0, sizeof(dp[i])); dp[1][1] = dp[0][1] = 1; // 쌩으로 하나 채운 경우 if (map[1][0] + map[1][1] \u003c= w) { dp[2][1] = 1; } else dp[2][1] = 2; solve(); ans = dp[2][n]; // 위에 만 걸친 경우 if (map[1][0] + map[n][0] \u003c= w) { for (int i = 0; i \u003c 3; ++i) memset(dp[i], 0, sizeof(dp[i])); dp[0][1] = 0; // 초기 상태가 이미 dp[0][1] 이다. dp[1][1] = INF; // 이곳을 참조할 경우의 수가 없다. dp[2][1] = 1; solve(); ans = min(ans, dp[1][n] + 1); } if (map[1][1] + map[n][1] \u003c= w) { for (int i = 0; i \u003c 3; ++i) memset(dp[i], 0, sizeof(dp[i])); dp[0][1] = INF; // 불가능 dp[1][1] = 0; dp[2][1] = 1; solve(); ans = min(ans, dp[0][n] + 1); } if (map[1][0] + map[n][0] \u003c= w \u0026\u0026 map[1][1] + map[n][1] \u003c= w) { for (int i = 0; i \u003c 3; ++i) memset(dp[i], 0, sizeof(dp[i])); dp[0][1] = dp[1][1] = INF; // 불가능 dp[2][1] = 0; solve(); ans = min(ans, dp[2][n - 1] + 2); } cout \u003c\u003c ans \u003c\u003c '\\n'; } } ",
  "wordCount" : "1122",
  "inLanguage": "en",
  "image": "https://blog.moozeh.org/images/papermod-cover.png","datePublished": "2023-12-26T00:00:00Z",
  "dateModified": "2023-12-26T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "moozeh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.moozeh.org/posts/2023/2023-12-26-boj1006/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.moozeh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.moozeh.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.moozeh.org/" accesskey="h" title="blog.moozeh (Alt + H)">blog.moozeh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.moozeh.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.moozeh.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.moozeh.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      [ 백준 1006 ] 습격자 초라기 : C&#43;&#43; 풀이
    </h1>
    <div class="post-description">
      백준 1006번 문제 풀이 입니다.
    </div>
    <div class="post-meta"><span title='2023-12-26 00:00:00 +0000 UTC'>December 26, 2023</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;moozeh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%eb%ac%b8%ec%a0%9c-%ec%a0%91%ea%b7%bc" aria-label="문제 접근">문제 접근</a></li>
                <li>
                    <a href="#%ed%95%b4%ea%b2%b0%eb%b0%a9%eb%b2%95" aria-label="해결방법">해결방법</a></li>
                <li>
                    <a href="#%ed%83%80%ec%9d%bc%ec%9d%84-%eb%82%98%eb%88%84%eb%8a%94-%eb%b2%95" aria-label="타일을 나누는 법?">타일을 나누는 법?</a><ul>
                        
                <li>
                    <a href="#%ec%9b%90%ed%98%95-%ea%b5%ac%ec%a1%b0%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%ed%95%b4%ea%b2%b0%ed%95%98%eb%82%98%ec%9a%94" aria-label="원형 구조는 어떻게 해결하나요?">원형 구조는 어떻게 해결하나요?</a></li>
                <li>
                    <a href="#1%ec%9d%98-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ec%88%98" aria-label="1의 경우의 수">1의 경우의 수</a></li>
                <li>
                    <a href="#2%ec%9d%98-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ec%88%98" aria-label="2의 경우의 수">2의 경우의 수</a></li>
                <li>
                    <a href="#3%ec%9d%98-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ec%88%98" aria-label="3의 경우의 수">3의 경우의 수</a></li>
                <li>
                    <a href="#4%ec%9d%98-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ec%88%98" aria-label="4의 경우의 수">4의 경우의 수</a></li></ul>
                </li>
                <li>
                    <a href="#%eb%82%b4%ea%b0%80-%ec%83%9d%ea%b0%81%ed%95%98%ec%a7%80-%eb%aa%bb%ed%95%9c-%ea%b2%83" aria-label="내가 생각하지 못한 것">내가 생각하지 못한 것</a><ul>
                        
                <li>
                    <a href="#1-%ed%83%80%ec%9d%bc%ec%9d%84-%ec%b1%84%ec%9a%b0%eb%8a%94-%ea%b2%bd%ec%9a%b0%ec%9d%98-%ec%88%98%eb%a5%bc-%ec%9e%98%eb%aa%bb-%eb%82%98%eb%88%84%ec%97%88%eb%8b%a4" aria-label="1. 타일을 채우는 경우의 수를 잘못 나누었다.">1. 타일을 채우는 경우의 수를 잘못 나누었다.</a></li>
                <li>
                    <a href="#2-%ec%9b%90%ed%98%95-dp%eb%9d%bc%ea%b3%a0-%ec%83%9d%ea%b0%81%ed%95%98%ea%b3%a0-%ec%97%ac%eb%9f%ac%eb%b2%88-dp%eb%a5%bc-%eb%8f%8c%eb%a0%a4%ec%95%bc%ed%95%9c%eb%8b%a4%ea%b3%a0-%ec%83%9d%ea%b0%81%ed%96%88%eb%8b%a4" aria-label="2. 원형 DP라고 생각하고 여러번 DP를 돌려야한다고 생각했다.">2. 원형 DP라고 생각하고 여러번 DP를 돌려야한다고 생각했다.</a></li></ul>
                </li>
                <li>
                    <a href="#%ec%86%8c%ec%8a%a4-%ec%bd%94%eb%93%9c" aria-label="소스 코드">소스 코드</a>
                </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><h2 id="문제-접근">문제 접근<a hidden class="anchor" aria-hidden="true" href="#문제-접근">#</a></h2>
<p>원형 타일채우기 DP 라고 생각하면 쉽다. 발상이 어려워서 플레티넘3 이 아닌가 조심스레 추측한다.</p>
<h2 id="해결방법">해결방법<a hidden class="anchor" aria-hidden="true" href="#해결방법">#</a></h2>
<ol>
<li>타일 채우기 문제와 같이 생각을 해보자.</li>
<li>타일을 채우거나 그렇지 않거나만을 따져서 DP 테이블을 잘 짰다면, 경계선에 대한 부분은 경우의 수로 아예 나누어 선형 DP 로 바꾸어 풀어보도록 하자.</li>
</ol>
<h2 id="타일을-나누는-법">타일을 나누는 법?<a hidden class="anchor" aria-hidden="true" href="#타일을-나누는-법">#</a></h2>
<p>내가 이부분을 생각못해서, 다른 블로그를 참고했다.</p>
<p>타일을 나누는 방법에는 총 3가지 경우의 수가 있을 것이다.</p>
<ul>
<li>현재 열을 기준으로 윗쪽만 채웠을 경우 (1행만)  - a</li>
<li>현재 열을 기준으로 아랫쪽만 채웠을 경우 (2행만) - b</li>
<li>현재 열을 기준으로 윗쪽 아랫쪽 둘다 채웠을 경우 (둘다) - c</li>
</ul>
<p>이런식으로 열을 1부터 N열 까지 채워나가다보면 선형적으로 풀 수가 있다.</p>
<p>a 경우의 점화식은 이렇게 될 것이다. 이때 <code>a_n</code> 은 n번째 행의 a 값이라는 뜻이다.</p>
<pre tabindex="0"><code>a_n = c_n-1 + 1  // 그냥 n행의 윗부분 한칸만 점령한 경우
if (n, 0) + (n-1, 0) &lt;= w // 현재 열의 윗쪽 + 해당 칸의 왼쪽 칸을 같이 점령할 수 있는 경우
		a_n = min(a_n, b_n-1 + 1) // if 문의 점령을 하게 딱 맞추면 남은 칸은 b_n-1 이 된다.
</code></pre><p>위의 경우를 그림으로 표현해보면 아래와 같다.</p>
<img src="/assets/images/2023-12-26-boj1006-20241220150420110.webp" alt="2023-12-26-boj1006-20241220150420110" loading="lazy">
<p>a는 N행에 위에만 칠해져야한다. 기본적인 경우는 이렇게 될 것이다. 한칸만 칠하면 되니까 근데 이제 (n-1, 0) 과 (n, 0) 을 한번에 같이 칠할 수(나누어 점령) 있다면 이렇게 될 것이다.</p>
<img src="/assets/images/2023-12-26-boj1006-20241220150428269.webp" alt="2023-12-26-boj1006-20241220150428269" loading="lazy">
<p>b 경우도 점화식은 a와 크게 다르지 않다. 위의 경우와 뒤집어 생각할 수 있을 것이다.</p>
<pre tabindex="0"><code>b_n = c_n-1 + 1 // 이 경우도 그냥 n행의 밑부분을 점령한 경우
if (n, 1) + (n-1, 1) &lt;= w
		b_n = min(b_n, a_n-1 + 1)
</code></pre><p>c의 경우는 쫌 다른데, 일단은 <code>a_n</code> 과 <code>b_n</code> 을 먼저 구하고 나중에 구해야한다. 왜냐하면 <code>c_n</code> 이 <code>a_n + 1</code> (그냥 나머지칸을 칠하는 경우) 가 최소 값이 될 수도 있기 때문이다.</p>
<p>또는 그냥 한번에 N행의 두칸을 한번에 점령할수도 있다.</p>
<p>또는 (N, 0) 과 (N-1, 0) / (N, 1) 과 (N-1, 1) 을 각각 한 부대가 점령할 수도 있을 것이다.</p>
<pre tabindex="0"><code>// 본 코드는 의사 코드다.
c_n = min(c_n-1 + 2, a_n + 1, b_n + 1)
if (n, 1) + (n, 0) &lt;= w
		c_n = min(c_n-1 + 1, c_n)
if (n, 1) + (n, 0) &lt;= w and (n-1, 1) + (n-1, 0) &lt;= w
		c_n = min(c_n, c_n-2 + 2)
</code></pre><img src="/assets/images/2023-12-26-boj1006-20241220150436218.webp" alt="2023-12-26-boj1006-20241220150436218" loading="lazy">
<img src="/assets/images/2023-12-26-boj1006-20241220150450303.webp" alt="2023-12-26-boj1006-20241220150450303" loading="lazy">
<img src="/assets/images/2023-12-26-boj1006-20241220150501121.webp" alt="2023-12-26-boj1006-20241220150501121" loading="lazy">
<img src="/assets/images/2023-12-26-boj1006-20241220150524902.webp" alt="2023-12-26-boj1006-20241220150524902" loading="lazy">
<h3 id="원형-구조는-어떻게-해결하나요">원형 구조는 어떻게 해결하나요?<a hidden class="anchor" aria-hidden="true" href="#원형-구조는-어떻게-해결하나요">#</a></h3>
<p>타일을 나누는 방법을 올바르게 생각했다면 원형 구조도 자연스레 해결이 된다.</p>
<p>끝부분과 처음부분을 걸쳐서 생각해보는 것이다.</p>
<p>어쨌던 입력으로 받은 배열은 선형적이니 선형적으로 생각할 때, 처음과 끝부분이 있겠다.</p>
<p>이 처음과 끝 부분에 걸쳐서 나누어 점령을 할 수 있는지 경우의 수를 나누는 것이다.</p>
<p>그렇게한다면 총 4개의 경우의 수가 생긴다.</p>
<ol>
<li>처음 - 끝 부분에 걸쳐서 점령하지 않는 경우</li>
<li>처음 - 끝 부분 열의 첫번째 행 칸 두곳을 한 부대가 점령하는 경우</li>
<li>처음 - 끝 부분 열의 두번째 행 칸 두곳을 한 부대가 점령하는 경우</li>
<li>2, 3 모두가 해당되는 경우.</li>
</ol>
<p>해당 되는 경우를 모두 생각하게 되면 각각의 경우에 적용해야할 초기 값이 다르단 걸 인지할 것이다.</p>
<h3 id="1의-경우의-수">1의 경우의 수<a hidden class="anchor" aria-hidden="true" href="#1의-경우의-수">#</a></h3>
<p>a_1(맨앞) 과 b_1 모두 1이고, c_1은 (1, 0), (1, 1) 의 값에 따라(두 곳을 한 부대만으로 점령이 가능한지를 생각.) 2 또는 1이 결정된다.</p>
<p>이후 점화식에 따라 DP 테이블을 채우고, <code>c_n</code> 값이 정답의 후보값이 됩니다.</p>
<h3 id="2의-경우의-수">2의 경우의 수<a hidden class="anchor" aria-hidden="true" href="#2의-경우의-수">#</a></h3>
<p>a_1은 0이다. 시작 시 미리 점령한 타일은 나중에 더해줄 것이다.</p>
<p>b_1의 경우의 수는 존재하지 않음. 이미 (1, 0) 이 점령되었기 때문에.</p>
<p>c_1은 1이 된다. 이 또한 (1, 0) 이 점령 되었기 때문에, c_1은 이곳에 (1, 1)만을 채우는 경우 밖에 존재하지 않는다.</p>
<p>이후 점화식에 따라 DP 테이블을 채우게 되면, (n, 0) 이 이미 점령 되어 있기 때문에, <code>b_n + 1</code> 의 값이 후보값이 됩니다! (+1을 하는 이유는 시작 시 미리 점령한 타일을 나중에 더해주기 때문입니다.)</p>
<h3 id="3의-경우의-수">3의 경우의 수<a hidden class="anchor" aria-hidden="true" href="#3의-경우의-수">#</a></h3>
<p>2와 동일하다.</p>
<p>a_1은 존재할 수 없고, b_1은 0이다. 시작 시 미리 점령한 타일은 나중에 더해준다고 가정한다.</p>
<p>c_1은 1이된다. 이또한 위와 같은 이유에서다.</p>
<p>2와 마찬가지로 <code>a_n + 1</code> 의 값이 후보값이 됩니다.</p>
<h3 id="4의-경우의-수">4의 경우의 수<a hidden class="anchor" aria-hidden="true" href="#4의-경우의-수">#</a></h3>
<p>a_1과 b_1은 존재할 수 없고, c_1이 0이 된다.</p>
<p>(1, 1) 과 (1, 0) 이 모두 시작 시 점령되었기 때문이다.</p>
<p>정답의 후보값은 <code>c_n-1 + 2</code> 가 됩니다.</p>
<h2 id="내가-생각하지-못한-것">내가 생각하지 못한 것<a hidden class="anchor" aria-hidden="true" href="#내가-생각하지-못한-것">#</a></h2>
<h3 id="1-타일을-채우는-경우의-수를-잘못-나누었다">1. 타일을 채우는 경우의 수를 잘못 나누었다.<a hidden class="anchor" aria-hidden="true" href="#1-타일을-채우는-경우의-수를-잘못-나누었다">#</a></h3>
<p>이게 무슨 소리냐면, 해당 타일이 하나만 차지하는지, 다른 타일과 나누어서 차지하고 있는지를 내가 나누었다.</p>
<p>위와 같은 타일채우기 문제에서는 이미 차지하고 있는가 여부를 생각하고, 한번에 채울 때 나누어 채우는 방식으로 DP 테이블을 채워 나가야함을 인지하자!</p>
<h3 id="2-원형-dp라고-생각하고-여러번-dp를-돌려야한다고-생각했다">2. 원형 DP라고 생각하고 여러번 DP를 돌려야한다고 생각했다.<a hidden class="anchor" aria-hidden="true" href="#2-원형-dp라고-생각하고-여러번-dp를-돌려야한다고-생각했다">#</a></h3>
<p>이는 1번 문제와 같이 대응되는데, 원형 DP이고 아니고 간에, 타일을 이미 채웠다면 이를 생각할 필요 없이 그냥 경우의 수로 나누어서 풀면 되는 문제였다.</p>
<h2 id="소스-코드">소스 코드<a hidden class="anchor" aria-hidden="true" href="#소스-코드">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include&lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;algorithm&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include&lt;cstring&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">10001</span><span class="p">];</span> <span class="c1">// 타일 문제 처럼 해당 행에 어느부분을 채우는가로 나누어야한다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">map</span><span class="p">[</span><span class="mi">10001</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mi">987654321</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 2열부터 시작해야함.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 그러려면 1열까진 내용을 다 채워놔야겠지
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 기본값 세팅
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">cout</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">tc</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">tc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">tc</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">w</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 시작 case 4개.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		
</span></span><span class="line"><span class="cl">		<span class="c1">// 끝 - 시작 부분에 특수부대를 걸치지 않은 경우
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">memset</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">		<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 쌩으로 하나 채운 경우
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="n">ans</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// 위에 만 걸친 경우
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="n">memset</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 초기 상태가 이미 dp[0][1] 이다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span> <span class="c1">// 이곳을 참조할 경우의 수가 없다.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="n">memset</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span> <span class="c1">// 불가능
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">map</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="n">memset</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">			<span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span> <span class="c1">// 불가능
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="n">ans</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">dp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

    </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.moozeh.org/posts/2023/2023-12-30-linear-algebra-2/">
    <span class="title">« Prev</span>
    <br>
    <span>[ 선형대수 ] 2. 행렬 대수</span>
  </a>
  <a class="next" href="https://blog.moozeh.org/posts/2023/2023-12-25-darkmode-flickering/">
    <span class="title">Next »</span>
    <br>
    <span>다크모드 테마 시 깜빡거리는 증상</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/moozeh">moozeh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
