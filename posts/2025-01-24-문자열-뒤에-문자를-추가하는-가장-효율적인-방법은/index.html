<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>문자열 뒤에 문자를 추가하는 가장 효율적인 방법은 | blog.moozeh</title>
<meta name="keywords" content="Java, String">
<meta name="description" content="
현재 Java 로 코딩테스트 준비를 해보고 있습니다. 2025년의 목표가 아무래도 Java 와 Spring 에 대해서 깊게 알아보기 이기 때문에 가벼운 문제가 많은 Leetcode 문제들을 위주로 한번씩 풀어보고 있습니다.
아무래도 Java 에서는 문자열 처리가 최적화로 인해서 생기는 문제가 많다보니 이번 기회에 String 에 대해서 깊게 알아볼 생각 입니다.
String
단순히 문자열 이라고 합니다. 문자들의 배열 을 줄여서 이렇게 부르죠.
그렇다면, 이 자체로 배열이라는 뜻이 됩니다.
생각해봅시다. 배열을 따로 원시 자료형으로 둘 수 있을까요? 아닙니다. 그래서 C&#43;&#43;, Java 모두 자체적으로 원시타입이 아닙니다.">
<meta name="author" content="moozeh">
<link rel="canonical" href="http://localhost:1313/posts/2025-01-24-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%97%90-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%B0%A9%EB%B2%95%EC%9D%80/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/2025-01-24-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%97%90-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%B0%A9%EB%B2%95%EC%9D%80/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/2025-01-24-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%97%90-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%B0%A9%EB%B2%95%EC%9D%80/">
  <meta property="og:site_name" content="blog.moozeh">
  <meta property="og:title" content="문자열 뒤에 문자를 추가하는 가장 효율적인 방법은">
  <meta property="og:description" content=" 현재 Java 로 코딩테스트 준비를 해보고 있습니다. 2025년의 목표가 아무래도 Java 와 Spring 에 대해서 깊게 알아보기 이기 때문에 가벼운 문제가 많은 Leetcode 문제들을 위주로 한번씩 풀어보고 있습니다.
아무래도 Java 에서는 문자열 처리가 최적화로 인해서 생기는 문제가 많다보니 이번 기회에 String 에 대해서 깊게 알아볼 생각 입니다.
String 단순히 문자열 이라고 합니다. 문자들의 배열 을 줄여서 이렇게 부르죠.
그렇다면, 이 자체로 배열이라는 뜻이 됩니다.
생각해봅시다. 배열을 따로 원시 자료형으로 둘 수 있을까요? 아닙니다. 그래서 C&#43;&#43;, Java 모두 자체적으로 원시타입이 아닙니다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-01-24T19:31:37+09:00">
    <meta property="article:modified_time" content="2025-01-24T19:31:37+09:00">
    <meta property="article:tag" content="Java">
    <meta property="article:tag" content="String">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="문자열 뒤에 문자를 추가하는 가장 효율적인 방법은">
<meta name="twitter:description" content="
현재 Java 로 코딩테스트 준비를 해보고 있습니다. 2025년의 목표가 아무래도 Java 와 Spring 에 대해서 깊게 알아보기 이기 때문에 가벼운 문제가 많은 Leetcode 문제들을 위주로 한번씩 풀어보고 있습니다.
아무래도 Java 에서는 문자열 처리가 최적화로 인해서 생기는 문제가 많다보니 이번 기회에 String 에 대해서 깊게 알아볼 생각 입니다.
String
단순히 문자열 이라고 합니다. 문자들의 배열 을 줄여서 이렇게 부르죠.
그렇다면, 이 자체로 배열이라는 뜻이 됩니다.
생각해봅시다. 배열을 따로 원시 자료형으로 둘 수 있을까요? 아닙니다. 그래서 C&#43;&#43;, Java 모두 자체적으로 원시타입이 아닙니다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "문자열 뒤에 문자를 추가하는 가장 효율적인 방법은",
      "item": "http://localhost:1313/posts/2025-01-24-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%97%90-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%B0%A9%EB%B2%95%EC%9D%80/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "문자열 뒤에 문자를 추가하는 가장 효율적인 방법은",
  "name": "문자열 뒤에 문자를 추가하는 가장 효율적인 방법은",
  "description": " 현재 Java 로 코딩테스트 준비를 해보고 있습니다. 2025년의 목표가 아무래도 Java 와 Spring 에 대해서 깊게 알아보기 이기 때문에 가벼운 문제가 많은 Leetcode 문제들을 위주로 한번씩 풀어보고 있습니다.\n아무래도 Java 에서는 문자열 처리가 최적화로 인해서 생기는 문제가 많다보니 이번 기회에 String 에 대해서 깊게 알아볼 생각 입니다.\nString 단순히 문자열 이라고 합니다. 문자들의 배열 을 줄여서 이렇게 부르죠.\n그렇다면, 이 자체로 배열이라는 뜻이 됩니다.\n생각해봅시다. 배열을 따로 원시 자료형으로 둘 수 있을까요? 아닙니다. 그래서 C++, Java 모두 자체적으로 원시타입이 아닙니다.\n",
  "keywords": [
    "Java", "String"
  ],
  "articleBody": " 현재 Java 로 코딩테스트 준비를 해보고 있습니다. 2025년의 목표가 아무래도 Java 와 Spring 에 대해서 깊게 알아보기 이기 때문에 가벼운 문제가 많은 Leetcode 문제들을 위주로 한번씩 풀어보고 있습니다.\n아무래도 Java 에서는 문자열 처리가 최적화로 인해서 생기는 문제가 많다보니 이번 기회에 String 에 대해서 깊게 알아볼 생각 입니다.\nString 단순히 문자열 이라고 합니다. 문자들의 배열 을 줄여서 이렇게 부르죠.\n그렇다면, 이 자체로 배열이라는 뜻이 됩니다.\n생각해봅시다. 배열을 따로 원시 자료형으로 둘 수 있을까요? 아닙니다. 그래서 C++, Java 모두 자체적으로 원시타입이 아닙니다.\n그렇기에 실제로 모든 문자열은 원시타입에서 떠나 이보다 더욱 복잡한 처리가 필요합니다.\nC 에서의 문자열 C언어의 경우 이를 배열로 처리 하기 때문에, 최적화를 위해서 “abcd” 라는게 있다면 “abcd” 자체를 저장해서 처리합니다. C언어는 문자열을 const char* 또는 char[]로 처리합니다.\n문자열 리터럴은 읽기 전용 데이터 영역에 저장됩니다. 따라서 수정이 필요한 경우 char 배열을 사용해야 합니다.\n그래서 이를 통해 문자열을 처리하거나 제어하는 함수를 포함한 라이브러리 를 사용해야 합니다.\nJava 에서의 String Java 또한, String은 불변 객체로써 저장 됩니다.\n하지만, 프로그램의 데이터영역에 저장되는 C와는 달리, 문자열 리터럴은 String Pool에 저장되어 재사용됩니다.\nString Pool String Pool 은 JVM 에서 문자열을 관리해주는 매커니즘입니다.\n컴파일 시 프로그램 내 문자열 리터럴들을 클래스 파일의 상수 풀 (Constant Pool) 에 저장하며, JVM이 클래스를 로딩할 때 String Pool 에 문자열 객체로써 생성합니다.\n중요한 점은 상수 풀이 런타임 영역이 아니라는 점입니다. Java 7 이후 버전 기준으로, 실제 String Pool 은 힙 영역에 저장하며, 클래스 로딩 시 해당 리터럴을 바탕으로 String 객체를 생성 후, String Pool에 저장하는 방식을 사용 중입니다.\n// 소스코드 String str = \"hello\"; // 바이트코드 ldc #2 // #2는 상수 풀 인덱스 astore_1 String Pool 을 이용해 동일한 문자열 리터럴은 재사용을 하여 메모리를 절약할 수 있습니다.\n문자열 리터럴에 대해서만 저장되고, 실제로 동적으로 생성되는 문자열은 힙 메모리에 저장됩니다.\n단, intern() 메소드를 사용하면, 동적으로 생성한 문자열도 String Pool 에 저장 가능합니다. intern() 메소드는 String Pool 에서 리터럴 문자열이 이미 존재하는지 체크하고, 존재하면 해당 문자열을 반환함으로써 다시 메모리 절약을 실행할 수도 있습니다.\n1. 단순 합산 연산 가장 일반적인 방법은 아래처럼 단순히 합연산을 시켜주면 됩니다.\nString s = \"aaa\" + \"b\"; 2. StringBuilder 두번째로, StringBuilder 를 사용하는 방식이 있습니다.\nStringBuilder 는 말그대로, 문자열을 만들어주는 객체입니다.\n// String -\u003e StringBuilder -\u003e String 변환 예시 String original = \"Hello\"; StringBuilder sb = new StringBuilder(original); // String -\u003e StringBuilder sb.append(\" World\"); // 수정 작업 String result = sb.toString(); // StringBuilder -\u003e String // 체이닝 예시 String result2 = new StringBuilder(\"Hello\") .append(\" \") .append(\"World\") .reverse() .toString(); // 문자열 처리 예시 String text = \"Hello World\"; String processed = new StringBuilder(text) .reverse() .delete(0, 2) .insert(0, \"Hi\") .toString(); char[] 배열을 사용해 문자열 저장 배열이 가득 차면 더 큰 배열로 자동 확장 (보통 2배) 수정 가능한 문자 시퀀스 제공 toString() 호출 시 최종 문자 배열로 불변 String 객체 생성 3. StringBuffer 문자열과 관련된 다른 객체로 StringBuffer 가 있습니다.\nStringBuilder 와의 큰 차이점으로는 스레딩 지원 여부입니다.\nStringBuilder 를 사용할 경우, 동기화를 지원하지 않고 비동기로 처리하므로, 단일 스레드만 사용하는 일반적인 환경에서는 더 빠른 편입니다. 동기화 오버헤드가 없기 때문입니다.\n반대로 StringBuffer 는 동기화를 지원하며, 멀티스레딩 환경에서 사용됩니다. 아래 예시처럼 실제로 buffer 에 더하거나 하는 작업을 병렬로 수행할때 사용합니다.\n// 멀티스레드 환경 StringBuffer buffer = new StringBuffer(); Thread t1 = new Thread(() -\u003e buffer.append(\"Hello\")); Thread t2 = new Thread(() -\u003e buffer.append(\"World\")); // 단일스레드 환경 StringBuilder builder = new StringBuilder(); builder.append(\"Hello\").append(\"World\"); 놀라운 사실 모든 문자열 연산은 StringBuilder 로 컴파일 하지만, C++ 과는 달리, Java 에서는 Operator 에 대한 연산 함수를 만들 수가 없습니다.\n그렇다면, “aaa” + “b” 와 같은 문자열 에 대한 합산 연산은 어떻게 이루어지는 걸까요?\n놀랍게도, String 연산자는 컴파일러가 자동으로 StringBuilder로 최적화 해줍니다. 컴파일러가 알아서 StringBuilder/StringBuffer 로 효율적인 문자열 수정 지원이 가능하므로 일반적으로 이렇게 사용하면 됩니다.\n하지만, JIT 컴파일러가 반복적인 문자열 연산을 추가 최적화해주므로 일반적인 상황에서는 딱히 크게 신경쓰지 않아도 됩니다.\n결론 아무거나 사용해도 상관없습니다. 컴파일 단에서 모두 StringBuilder로 최적화 해주기 때문입니다.\n다만, 경우의 수에 따라 아래와 같이 다양하게 활용하면 좋을 것입니다.\n단순 문자열 연결: + 연산자가 가독성 좋음 반복문 내 문자열 조작: 명시적 StringBuilder 가 성능상 유리 (객체 재사용) ",
  "wordCount" : "636",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2025-01-24T19:31:37+09:00",
  "dateModified": "2025-01-24T19:31:37+09:00",
  "author":{
    "@type": "Person",
    "name": "moozeh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/2025-01-24-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%97%90-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EC%B6%94%EA%B0%80%ED%95%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EB%B0%A9%EB%B2%95%EC%9D%80/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.moozeh",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="blog.moozeh (Alt + H)">blog.moozeh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      문자열 뒤에 문자를 추가하는 가장 효율적인 방법은
    </h1>
    <div class="post-meta"><span title='2025-01-24 19:31:37 +0900 KST'>January 24, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;moozeh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#string" aria-label="String">String</a></li>
                <li>
                    <a href="#c-%ec%97%90%ec%84%9c%ec%9d%98-%eb%ac%b8%ec%9e%90%ec%97%b4" aria-label="C 에서의 문자열">C 에서의 문자열</a></li>
                <li>
                    <a href="#java-%ec%97%90%ec%84%9c%ec%9d%98-string" aria-label="Java 에서의 String">Java 에서의 String</a><ul>
                        
                <li>
                    <a href="#string-pool" aria-label="String Pool">String Pool</a></li>
                <li>
                    <a href="#1-%eb%8b%a8%ec%88%9c-%ed%95%a9%ec%82%b0-%ec%97%b0%ec%82%b0" aria-label="1. 단순 합산 연산">1. 단순 합산 연산</a></li>
                <li>
                    <a href="#2-stringbuilder" aria-label="2. StringBuilder">2. StringBuilder</a></li>
                <li>
                    <a href="#3-stringbuffer" aria-label="3. StringBuffer">3. StringBuffer</a></li></ul>
                </li>
                <li>
                    <a href="#%eb%86%80%eb%9d%bc%ec%9a%b4-%ec%82%ac%ec%8b%a4" aria-label="놀라운 사실">놀라운 사실</a><ul>
                        
                <li>
                    <a href="#%eb%aa%a8%eb%93%a0-%eb%ac%b8%ec%9e%90%ec%97%b4-%ec%97%b0%ec%82%b0%ec%9d%80-stringbuilder-%eb%a1%9c-%ec%bb%b4%ed%8c%8c%ec%9d%bc" aria-label="모든 문자열 연산은 StringBuilder 로 컴파일">모든 문자열 연산은 StringBuilder 로 컴파일</a></li></ul>
                </li>
                <li>
                    <a href="#%ea%b2%b0%eb%a1%a0" aria-label="결론">결론</a>
                </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><!-- truncate -->
<p>현재 <code>Java</code> 로 코딩테스트 준비를 해보고 있습니다. 2025년의 목표가 아무래도 <code>Java</code> 와 <code>Spring</code> 에 대해서 깊게 알아보기 이기 때문에 가벼운 문제가 많은 <code>Leetcode</code> 문제들을 위주로 한번씩 풀어보고 있습니다.</p>
<p>아무래도 <code>Java</code> 에서는 문자열 처리가 최적화로 인해서 생기는 문제가 많다보니 이번 기회에 <code>String</code> 에 대해서 깊게 알아볼 생각 입니다.</p>
<h2 id="string">String<a hidden class="anchor" aria-hidden="true" href="#string">#</a></h2>
<p>단순히 <strong>문자열</strong> 이라고 합니다. 문자들의 배열 을 줄여서 이렇게 부르죠.</p>
<p>그렇다면, 이 자체로 배열이라는 뜻이 됩니다.</p>
<p>생각해봅시다. 배열을 따로 원시 자료형으로 둘 수 있을까요? 아닙니다. 그래서 <code>C++</code>, <code>Java</code> 모두 자체적으로 원시타입이 아닙니다.</p>
<p>그렇기에 실제로 모든 문자열은 원시타입에서 떠나 이보다 더욱 복잡한 처리가 필요합니다.</p>
<h2 id="c-에서의-문자열">C 에서의 문자열<a hidden class="anchor" aria-hidden="true" href="#c-에서의-문자열">#</a></h2>
<p>C언어의 경우 이를 배열로 처리 하기 때문에, 최적화를 위해서 &ldquo;abcd&rdquo; 라는게 있다면 &ldquo;abcd&rdquo; 자체를 저장해서 처리합니다. C언어는 문자열을 const char* 또는 char[]로 처리합니다.</p>
<p>문자열 리터럴은 읽기 전용 데이터 영역에 저장됩니다. 따라서 수정이 필요한 경우 char 배열을 사용해야 합니다.</p>
<p>그래서 이를 통해 문자열을 처리하거나 제어하는 함수를 포함한 라이브러리 <code>&lt;string.h&gt;</code> 를 사용해야 합니다.</p>
<h2 id="java-에서의-string">Java 에서의 String<a hidden class="anchor" aria-hidden="true" href="#java-에서의-string">#</a></h2>
<p>Java 또한, String은 불변 객체로써 저장 됩니다.</p>
<p>하지만, 프로그램의 데이터영역에 저장되는 C와는 달리, 문자열 리터럴은 <strong>String Pool에 저장되어 재사용됩니다.</strong></p>
<h3 id="string-pool">String Pool<a hidden class="anchor" aria-hidden="true" href="#string-pool">#</a></h3>
<p><code>String Pool</code> 은 JVM 에서 문자열을 관리해주는 매커니즘입니다.</p>
<p>컴파일 시 프로그램 내 문자열 리터럴들을 클래스 파일의 상수 풀 (Constant Pool) 에 저장하며, JVM이 클래스를 로딩할 때 String Pool 에 문자열 객체로써 생성합니다.</p>
<p>중요한 점은 상수 풀이 런타임 영역이 아니라는 점입니다. <code>Java 7</code> 이후 버전 기준으로, 실제 String Pool 은 <strong>힙 영역에 저장하며,</strong>  클래스 로딩 시 해당 리터럴을 바탕으로 String 객체를 생성 후, String Pool에 저장하는 방식을 사용 중입니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 소스코드</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 바이트코드</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">ldc</span><span class="w"> </span><span class="err">#</span><span class="n">2</span><span class="w">  </span><span class="c1">// #2는 상수 풀 인덱스</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">astore_1</span><span class="w">
</span></span></span></code></pre></div><p><code>String Pool</code> 을 이용해 동일한 문자열 리터럴은 재사용을 하여 메모리를 절약할 수 있습니다.</p>
<p>문자열 리터럴에 대해서만 저장되고, 실제로 동적으로 생성되는 문자열은 <strong>힙 메모리</strong>에 저장됩니다.</p>
<p>단, <code>intern()</code> 메소드를 사용하면, 동적으로 생성한 문자열도 String Pool 에 저장 가능합니다. <code>intern()</code> 메소드는 String Pool 에서 리터럴 문자열이 이미 존재하는지 체크하고, 존재하면 해당 문자열을 반환함으로써 다시 메모리 절약을 실행할 수도 있습니다.</p>
<h3 id="1-단순-합산-연산">1. 단순 합산 연산<a hidden class="anchor" aria-hidden="true" href="#1-단순-합산-연산">#</a></h3>
<p>가장 일반적인 방법은 아래처럼 단순히 합연산을 시켜주면 됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;aaa&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;b&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h3 id="2-stringbuilder">2. StringBuilder<a hidden class="anchor" aria-hidden="true" href="#2-stringbuilder">#</a></h3>
<p>두번째로,  <code>StringBuilder</code> 를 사용하는 방식이 있습니다.</p>
<p><code>StringBuilder</code> 는 말그대로, 문자열을 만들어주는 객체입니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// String -&gt; StringBuilder -&gt; String 변환 예시</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Hello&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">StringBuilder</span><span class="w"> </span><span class="n">sb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="p">(</span><span class="n">original</span><span class="p">);</span><span class="w">  </span><span class="c1">// String -&gt; StringBuilder</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">sb</span><span class="p">.</span><span class="na">append</span><span class="p">(</span><span class="s">&#34; World&#34;</span><span class="p">);</span><span class="w">  </span><span class="c1">// 수정 작업</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sb</span><span class="p">.</span><span class="na">toString</span><span class="p">();</span><span class="w">  </span><span class="c1">// StringBuilder -&gt; String</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 체이닝 예시</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">result2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">.</span><span class="na">append</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">.</span><span class="na">append</span><span class="p">(</span><span class="s">&#34;World&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">.</span><span class="na">reverse</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">.</span><span class="na">toString</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 문자열 처리 예시</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Hello World&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">processed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">.</span><span class="na">reverse</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">.</span><span class="na">delete</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="n">2</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">.</span><span class="na">insert</span><span class="p">(</span><span class="n">0</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Hi&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">.</span><span class="na">toString</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>char[] 배열을 사용해 문자열 저장</li>
<li>배열이 가득 차면 더 큰 배열로 자동 확장 (보통 2배)</li>
<li>수정 가능한 문자 시퀀스 제공</li>
<li>toString() 호출 시 최종 문자 배열로 불변 String 객체 생성</li>
</ul>
<h3 id="3-stringbuffer">3. StringBuffer<a hidden class="anchor" aria-hidden="true" href="#3-stringbuffer">#</a></h3>
<p>문자열과 관련된 다른 객체로 <code>StringBuffer</code> 가 있습니다.</p>
<p><code>StringBuilder</code> 와의 큰 차이점으로는 <strong>스레딩 지원 여부</strong>입니다.</p>
<p><code>StringBuilder</code> 를 사용할 경우, 동기화를 지원하지 않고 비동기로 처리하므로, 단일 스레드만 사용하는 일반적인 환경에서는 더 빠른 편입니다. 동기화 오버헤드가 없기 때문입니다.</p>
<p>반대로 <code>StringBuffer</code> 는 동기화를 지원하며, 멀티스레딩 환경에서 사용됩니다. 아래 예시처럼 실제로 buffer 에 더하거나 하는 작업을 병렬로 수행할때 사용합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 멀티스레드 환경</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">StringBuffer</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StringBuffer</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Thread</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="na">append</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Thread</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Thread</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="na">append</span><span class="p">(</span><span class="s">&#34;World&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 단일스레드 환경</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">StringBuilder</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">builder</span><span class="p">.</span><span class="na">append</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">).</span><span class="na">append</span><span class="p">(</span><span class="s">&#34;World&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><h2 id="놀라운-사실">놀라운 사실<a hidden class="anchor" aria-hidden="true" href="#놀라운-사실">#</a></h2>
<h3 id="모든-문자열-연산은-stringbuilder-로-컴파일">모든 문자열 연산은 StringBuilder 로 컴파일<a hidden class="anchor" aria-hidden="true" href="#모든-문자열-연산은-stringbuilder-로-컴파일">#</a></h3>
<p>하지만, <code>C++</code> 과는 달리, Java 에서는 Operator 에 대한 연산 함수를 만들 수가 없습니다.</p>
<p>그렇다면, &ldquo;aaa&rdquo; + &ldquo;b&rdquo; 와 같은 문자열 에 대한 합산 연산은 어떻게 이루어지는 걸까요?</p>
<p>놀랍게도, String 연산자는 컴파일러가 자동으로 StringBuilder로 최적화 해줍니다. 컴파일러가 알아서 <code>StringBuilder</code>/<code>StringBuffer</code> 로 효율적인 문자열 수정 지원이 가능하므로 일반적으로 이렇게 사용하면 됩니다.</p>
<p>하지만, JIT 컴파일러가 반복적인 문자열 연산을 추가 최적화해주므로 일반적인 상황에서는 딱히 크게 신경쓰지 않아도 됩니다.</p>
<h2 id="결론">결론<a hidden class="anchor" aria-hidden="true" href="#결론">#</a></h2>
<p>아무거나 사용해도 상관없습니다. <strong>컴파일 단에서 모두 StringBuilder로 최적화 해주기 때문입니다.</strong></p>
<p>다만,  경우의 수에 따라 아래와 같이 다양하게 활용하면 좋을 것입니다.</p>
<ul>
<li>단순 문자열 연결: + 연산자가 가독성 좋음</li>
<li>반복문 내 문자열 조작: 명시적 <code>StringBuilder</code> 가 성능상 유리 (객체 재사용)</li>
</ul>


    </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/java/">Java</a></li>
      <li><a href="http://localhost:1313/tags/string/">String</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/2025-01-25-erd-%EC%8A%88%ED%8D%BC%ED%83%80%EC%9E%85-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/">
    <span class="title">« Prev</span>
    <br>
    <span>ERD 슈퍼타입-서브타입 관계에 대해서 알아보자</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/2025-01-19-java-string-for-each-%EC%88%9C%ED%9A%8C-%EB%B0%A9%EB%B2%95/">
    <span class="title">Next »</span>
    <br>
    <span>[Java] String for-each 순회 방법</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/moozeh">moozeh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
