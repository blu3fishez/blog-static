<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[알고리즘] Chapter 1 &amp; 2 | blog.moozeh</title>
<meta name="keywords" content="">
<meta name="description" content="알고리즘 정리">
<meta name="author" content="moozeh">
<link rel="canonical" href="http://localhost:1313/posts/2024/2024-03-24-algorithm-1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/2024/2024-03-24-algorithm-1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/2024/2024-03-24-algorithm-1/">
  <meta property="og:site_name" content="blog.moozeh">
  <meta property="og:title" content="[알고리즘] Chapter 1 & 2">
  <meta property="og:description" content="알고리즘 정리">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-03-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-03-24T00:00:00+00:00">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="[알고리즘] Chapter 1 &amp; 2">
<meta name="twitter:description" content="알고리즘 정리">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[알고리즘] Chapter 1 \u0026 2",
      "item": "http://localhost:1313/posts/2024/2024-03-24-algorithm-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[알고리즘] Chapter 1 \u0026 2",
  "name": "[알고리즘] Chapter 1 \u0026 2",
  "description": "알고리즘 정리",
  "keywords": [
    
  ],
  "articleBody": "알고리즘이란 무엇인가? 알고리즘이란 정확히 정의된 계산 문제를 풀기 위한 특정 절차이다.\n유한한 단계로 이루어진 절차이다.\n실행될 액션들과 그 액션들의 순서를 나타낸다.\n모호하지 않은 명령들이 순차적으로 나열된 것이다. 이들은 정당한 입력에 대해 요구되는 출력을 유한한 시간 내에 내놓아야한다.\n알고리즘과 머신러닝의 차이 알고리즘은 입력이 주어지고, 그에 맞는 출력을 얻기 위해 문제를 해결하는 과정이다. 또한 문제가 엄밀하게 정의 되어 있다.\n그에 반해 머신러닝은 이미 입력 과 정답을 바탕으로 알고리즘을 학습하는 것이다. 또한, 문제가 엄밀히 정의되어 있지 않아, 정확한 출력이 요구되지 않을 수도 있다.\n따라서 알고리즘은 명백하게 정의된 수행절차들이고, 입출력 간의 관계를 정확하게 정의한다.\n예를들어, 소수 구하기, 정렬하기 는 알고리즘 을 정의할 수 있는 문제이다.\n알고리즘을 공부하는 절차 알고리즘은 두가지의 접근 방향이 있는데,\n문제 기반 : 같은 문제를 해결하는 여러가지 방법에 대해 연구할 수 있거나, (정렬)\n설계 기반 : 여러 문제를 한가지 방법으로 해결하는 방법에 대해 연구할 수 있다. (분할정복)\n예시 : GCD 구하기 GCD 는 Greatest Common Divisor 의 약자로 한국어로 최대 공약수를 뜻한다.\n이에 대해서는 유클리드 호제법을 이용할 수도 있고, 그냥 브루트 포스를 사용할 수도 있지만, 브루트 포스도 하나의 방법이며 이 자체로 알고리즘일 수도 있다는 사실을 알면 좋겠다.\n실제로 의사코드를 제작하는 과정을 통해 직접 의사코드로 의사를 표현해보자.\nGCD(m, n) while n != 0 do r \u003c- m%n // m mod(n), m이 n보다 크다 가정. m \u003c- n n \u003c- r 이 의사코드가 맞는 지 증명을 하기 위해서는, 위에 반복문이 수행되는 반복 작업이 다른 error 나 argument 에 대해서 맞다는 것을 증명을 해야할 것이다.\n알고리즘의 설계-분석 과정 알고리즘을 설계-분석하는 과정은 아래와 같다.\n문제를 이해하기\n상황 분석하기\n2-1. 연산 장치가 현실적으로 계산 가능한 양인가?\n2-2. 정확하게 풀 것인가? 근사치를 구할 것인가? (소수)\n2-3. 어떤 알고리즘 디자인 기술을 정할 것인가?\n2-4. 어떤 자료구조를 사용할 것인가?\n알고리즘 설계하기\n정확함을 증명하기\n4-1. 정확하지 않다면, 2번 항목과 3번 항목으로 돌아갈 수 있다.\n알고리즘을 분석하기 (얼마나 빠른지 등)\n5-1. 빠르지 않다면, 2번 항목과 3번 항목으로 돌아갈 수도 있다.\n알고리즘을 구현(Code) 하기\n알고리즘을 증명하는 방법 알고리즘을 증명하는 방법은 수학에서 많이 가져올 수 있다. 필자는 애초에 알고리즘 자체가 수학의 일종이라고 생각한다.\n이번 강의는 그 중 자주 사용되는 방법으로 몇가지를 소개한다.\n일반적으로 두가지 경우를 먼저 소개한다.\n정확하지 않음을 증명하기 대표적으로 반례를 찾는 것이다. 반례를 찾으면 알고리즘은 실패한 알고리즘이다.\n정확함을 증명하기 모든 입력에 대해 정확함을 증명하기란 몇가지의 입력 예시만으론 쉽지가 않다. 이에 대해서는 수학적 귀납법을 활용한다.\n증명하기 연역적 증명 (Deductive reasoning) 이란, 대전제를 이용해서 소전제가 맞음을 증명하는 방법이 있다.\n귀납적 증명 (Inductive reasoning) 소전제를 모아서 하나의 증명을 하는 방법이다.\n귀류법이란, 대전제가 틀렸음을 가정했을 때, 반례가 생김을 찾아서 증명하는 방법이다.\n수학적 귀납법을 이용한 증명 과정 실제로 하나하나의 예시를 모아서 증명하기란 말이 되지 않는다. 따라서 이를 수학적으로 증명할 수 있는 방법이 있는데, 이것이 수학적 귀납법 이다.\n수학적 귀납법은 도미노와 같다고 생각하면 된다.\n첫번째 사례 (P_1, basis) 가 옳다고 증명한다.\n1번째부터 k 번째 사례 (P_k, n \u003e= k, P_1 … P_k) 가 옳다고 가정 한다.\n이때, 첫번째 사례부터 k번째 사례로 k + 1 번째 사례가 옳다고 증명하면, 이는 수학적으로 증명이 된다.\n가우스 공식이 맞음을 증명하는 방법도 위 방법을 통해서 증명이 가능하다.\n예시 : 정렬 알고리즘 정렬 문제란, 입력으로 특정 숫자의 나열에 대해 증가하는 순서의 순열로 출력하게 만드는 문제를 뜻한다.\n삽입 정렬이 무엇인가? 삽입 정렬은 정렬 문제를 푸는 알고리즘 중에 하나이다.\nA[] 는 입력된 배열 for j \u003c- 2 to N do key \u003c- A[j] i \u003c- j-1 // i는 j-1부터 1까지 순회를 할 것이다. while i \u003e 0 and A[i] \u003e key do A[i + 1] \u003c- A[i] i \u003c- i-1 A[i+1] \u003c- key 위 예시를 잘 보면, j번째 순회에서 앞의 원소들을 하나하나씩 읽으며, j번째 값보다 i번째 값이 크면 하나씩 뒤로 넘겨준다.\n그러다가, 작거나 같은 순간이 온다면, 그자리에 j번째 원소를 집어넣어주는 작업을 한다.\n알고리즘 분석하기 해당 알고리즘이 빠른가? -\u003e 걸리는 시간이 얼마나 되는가?\n알고리즘이 좋은가? -\u003e 어떻게 판별할 것인가?\n알고리즘이 정확한가? -\u003e 어떻게 증명할 것인가?\n위의 사항들에 대해서 말할 수 있어야할 것이다.\n분석에 대해서는 아래 3가지 경우의 수로 나뉠 수 있다.\nworst case : 가장 최악의 경우의 수를 뜻합니다. 시간이 가장 오래걸리는 경우를 뜻하지요.\naverage case : 평균적인 경우의 수를 뜻합니다. 모든 경우의 수에 대해 평균으로 나누어 계산을 하므로 구하기 어렵습니다.\nbest-case : 가장 빠르게 될 경우의 수를 뜻합니다. 시간이 가장 안걸리므로 너무 편향적인 결과를 보여주기도 합니다.\n정확한 속도를 계산할 수 없어서 점근 표기법 (Asymptotic Analysis) 을 활용한다.\n삽입정렬에서는 worst-case 는 역순으로 정렬된 배열이 주어졌을 때 일 것이고, best-case 는 이미 정렬된 배열이 주어졌을 때일 것이다. 그리고 average-case 는 best와 worst 만큼 역순과 정렬된 배열이 주어진 경우일 것이다.\n따라서, worst case는 O(n^2), best case는 O(n), average case는 O(n^2 / 2) = O(n^2) 일 것이다.\n이 표기법에 관해서는 이후 문서에서 상세하게 표시할 것이다.\n",
  "wordCount" : "726",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-03-24T00:00:00Z",
  "dateModified": "2024-03-24T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "moozeh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/2024/2024-03-24-algorithm-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.moozeh",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="blog.moozeh (Alt + H)">blog.moozeh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      [알고리즘] Chapter 1 &amp; 2
    </h1>
    <div class="post-description">
      알고리즘 정리
    </div>
    <div class="post-meta"><span title='2024-03-24 00:00:00 +0000 UTC'>March 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;moozeh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%b4%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80" aria-label="알고리즘이란 무엇인가?">알고리즘이란 무엇인가?</a></li>
                <li>
                    <a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ea%b3%bc-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d%ec%9d%98-%ec%b0%a8%ec%9d%b4" aria-label="알고리즘과 머신러닝의 차이">알고리즘과 머신러닝의 차이</a></li>
                <li>
                    <a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%84-%ea%b3%b5%eb%b6%80%ed%95%98%eb%8a%94-%ec%a0%88%ec%b0%a8" aria-label="알고리즘을 공부하는 절차">알고리즘을 공부하는 절차</a></li>
                <li>
                    <a href="#%ec%98%88%ec%8b%9c--gcd-%ea%b5%ac%ed%95%98%ea%b8%b0" aria-label="예시 : GCD 구하기">예시 : GCD 구하기</a></li>
                <li>
                    <a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%84%a4%ea%b3%84-%eb%b6%84%ec%84%9d-%ea%b3%bc%ec%a0%95" aria-label="알고리즘의 설계-분석 과정">알고리즘의 설계-분석 과정</a></li>
                <li>
                    <a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%84-%ec%a6%9d%eb%aa%85%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95" aria-label="알고리즘을 증명하는 방법">알고리즘을 증명하는 방법</a><ul>
                        
                <li>
                    <a href="#%ec%a0%95%ed%99%95%ed%95%98%ec%a7%80-%ec%95%8a%ec%9d%8c%ec%9d%84-%ec%a6%9d%eb%aa%85%ed%95%98%ea%b8%b0" aria-label="정확하지 않음을 증명하기">정확하지 않음을 증명하기</a></li>
                <li>
                    <a href="#%ec%a0%95%ed%99%95%ed%95%a8%ec%9d%84-%ec%a6%9d%eb%aa%85%ed%95%98%ea%b8%b0" aria-label="정확함을 증명하기">정확함을 증명하기</a></li></ul>
                </li>
                <li>
                    <a href="#%ec%a6%9d%eb%aa%85%ed%95%98%ea%b8%b0" aria-label="증명하기">증명하기</a><ul>
                        
                <li>
                    <a href="#%ec%88%98%ed%95%99%ec%a0%81-%ea%b7%80%eb%82%a9%eb%b2%95%ec%9d%84-%ec%9d%b4%ec%9a%a9%ed%95%9c-%ec%a6%9d%eb%aa%85-%ea%b3%bc%ec%a0%95" aria-label="수학적 귀납법을 이용한 증명 과정">수학적 귀납법을 이용한 증명 과정</a></li></ul>
                </li>
                <li>
                    <a href="#%ec%98%88%ec%8b%9c--%ec%a0%95%eb%a0%ac-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98" aria-label="예시 : 정렬 알고리즘">예시 : 정렬 알고리즘</a><ul>
                        
                <li>
                    <a href="#%ec%82%bd%ec%9e%85-%ec%a0%95%eb%a0%ac%ec%9d%b4-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80" aria-label="삽입 정렬이 무엇인가?">삽입 정렬이 무엇인가?</a></li>
                <li>
                    <a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%eb%b6%84%ec%84%9d%ed%95%98%ea%b8%b0" aria-label="알고리즘 분석하기">알고리즘 분석하기</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><h2 id="알고리즘이란-무엇인가">알고리즘이란 무엇인가?<a hidden class="anchor" aria-hidden="true" href="#알고리즘이란-무엇인가">#</a></h2>
<p>알고리즘이란 정확히 정의된 계산 문제를 풀기 위한 <code>특정 절차</code>이다.</p>
<ul>
<li>
<p><code>유한한</code> 단계로 이루어진 절차이다.</p>
</li>
<li>
<p>실행될 액션들과 그 액션들의 순서를 나타낸다.</p>
</li>
<li>
<p><code>모호하지 않은</code> 명령들이 순차적으로 나열된 것이다. 이들은 <code>정당한 입력</code>에 대해 <code>요구되는 출력</code>을 <code>유한한 시간</code> 내에 내놓아야한다.</p>
</li>
</ul>
<h2 id="알고리즘과-머신러닝의-차이">알고리즘과 머신러닝의 차이<a hidden class="anchor" aria-hidden="true" href="#알고리즘과-머신러닝의-차이">#</a></h2>
<p>알고리즘은 <code>입력</code>이 주어지고, 그에 맞는 <code>출력</code>을 얻기 위해 문제를 해결하는 과정이다. 또한 문제가 엄밀하게 정의 되어 있다.</p>
<p>그에 반해 머신러닝은 이미 <code>입력</code> 과 <code>정답</code>을 바탕으로 <code>알고리즘</code>을 학습하는 것이다. 또한, 문제가 엄밀히 정의되어 있지 않아, 정확한 출력이 요구되지 않을 수도 있다.</p>
<p>따라서 알고리즘은 <code>명백하게</code> 정의된 수행절차들이고, 입출력 간의 관계를 정확하게 정의한다.</p>
<p>예를들어, <em>소수 구하기, 정렬하기</em> 는 알고리즘 을 정의할 수 있는 문제이다.</p>
<h2 id="알고리즘을-공부하는-절차">알고리즘을 공부하는 절차<a hidden class="anchor" aria-hidden="true" href="#알고리즘을-공부하는-절차">#</a></h2>
<p>알고리즘은 두가지의 접근 방향이 있는데,</p>
<ol>
<li>
<p>문제 기반 : 같은 문제를 해결하는 여러가지 방법에 대해 연구할 수 있거나, (정렬)</p>
</li>
<li>
<p>설계 기반 : 여러 문제를 한가지 방법으로 해결하는 방법에 대해 연구할 수 있다. (분할정복)</p>
</li>
</ol>
<h2 id="예시--gcd-구하기">예시 : GCD 구하기<a hidden class="anchor" aria-hidden="true" href="#예시--gcd-구하기">#</a></h2>
<p>GCD 는 <code>Greatest Common Divisor</code> 의 약자로 한국어로 <a href="https://ko.wikipedia.org/wiki/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98">최대 공약수</a>를 뜻한다.</p>
<p>이에 대해서는 유클리드 호제법을 이용할 수도 있고, 그냥 브루트 포스를 사용할 수도 있지만, <code>브루트 포스</code>도 하나의 방법이며 이 자체로 알고리즘일 수도 있다는 사실을 알면 좋겠다.</p>
<p>실제로 의사코드를 제작하는 과정을 통해 직접 의사코드로 의사를 표현해보자.</p>
<pre tabindex="0"><code>GCD(m, n)
    while n != 0 do
        r &lt;- m%n // m mod(n), m이 n보다 크다 가정.
        m &lt;- n
        n &lt;- r
</code></pre><p>이 의사코드가 맞는 지 증명을 하기 위해서는, 위에 반복문이 수행되는 반복 작업이 다른 error 나 argument 에 대해서 맞다는 것을 증명을 해야할 것이다.</p>
<h2 id="알고리즘의-설계-분석-과정">알고리즘의 설계-분석 과정<a hidden class="anchor" aria-hidden="true" href="#알고리즘의-설계-분석-과정">#</a></h2>
<p>알고리즘을 설계-분석하는 과정은 아래와 같다.</p>
<ol>
<li>
<p>문제를 이해하기</p>
</li>
<li>
<p>상황 분석하기</p>
<p>2-1. 연산 장치가 현실적으로 계산 가능한 양인가?</p>
<p>2-2. 정확하게 풀 것인가? 근사치를 구할 것인가? (소수)</p>
<p>2-3. 어떤 알고리즘 디자인 기술을 정할 것인가?</p>
<p>2-4. 어떤 자료구조를 사용할 것인가?</p>
</li>
<li>
<p>알고리즘 설계하기</p>
</li>
<li>
<p>정확함을 증명하기</p>
<p>4-1. 정확하지 않다면, 2번 항목과 3번 항목으로 돌아갈 수 있다.</p>
</li>
<li>
<p>알고리즘을 분석하기 (얼마나 빠른지 등)</p>
<p>5-1. 빠르지 않다면, 2번 항목과 3번 항목으로 돌아갈 수도 있다.</p>
</li>
<li>
<p>알고리즘을 구현(Code) 하기</p>
</li>
</ol>
<h2 id="알고리즘을-증명하는-방법">알고리즘을 증명하는 방법<a hidden class="anchor" aria-hidden="true" href="#알고리즘을-증명하는-방법">#</a></h2>
<p>알고리즘을 증명하는 방법은 수학에서 많이 가져올 수 있다. 필자는 애초에 알고리즘 자체가 수학의 일종이라고 생각한다.</p>
<p>이번 강의는 그 중 자주 사용되는 방법으로 몇가지를 소개한다.</p>
<p>일반적으로 두가지 경우를 먼저 소개한다.</p>
<h3 id="정확하지-않음을-증명하기">정확하지 않음을 증명하기<a hidden class="anchor" aria-hidden="true" href="#정확하지-않음을-증명하기">#</a></h3>
<p>대표적으로 반례를 찾는 것이다. 반례를 찾으면 알고리즘은 실패한 알고리즘이다.</p>
<h3 id="정확함을-증명하기">정확함을 증명하기<a hidden class="anchor" aria-hidden="true" href="#정확함을-증명하기">#</a></h3>
<p>모든 입력에 대해 정확함을 증명하기란 몇가지의 입력 예시만으론 쉽지가 않다. 이에 대해서는 <code>수학적 귀납법</code>을 활용한다.</p>
<h2 id="증명하기">증명하기<a hidden class="anchor" aria-hidden="true" href="#증명하기">#</a></h2>
<p>연역적 증명 (Deductive reasoning) 이란, 대전제를 이용해서 소전제가 맞음을 증명하는 방법이 있다.</p>
<p>귀납적 증명 (Inductive reasoning) 소전제를 모아서 하나의 증명을 하는 방법이다.</p>
<p>귀류법이란, 대전제가 틀렸음을 가정했을 때, 반례가 생김을 찾아서 증명하는 방법이다.</p>
<h3 id="수학적-귀납법을-이용한-증명-과정">수학적 귀납법을 이용한 증명 과정<a hidden class="anchor" aria-hidden="true" href="#수학적-귀납법을-이용한-증명-과정">#</a></h3>
<p>실제로 하나하나의 예시를 모아서 증명하기란 말이 되지 않는다. 따라서 이를 수학적으로 증명할 수 있는 방법이 있는데, 이것이 <code>수학적 귀납법</code> 이다.</p>
<p>수학적 귀납법은 도미노와 같다고 생각하면 된다.</p>
<ol>
<li>
<p>첫번째 사례 (P_1, basis) 가 옳다고 증명한다.</p>
</li>
<li>
<p>1번째부터 k 번째 사례 (P_k, n &gt;= k, P_1 &hellip; P_k) 가 옳다고 <code>가정</code> 한다.</p>
</li>
<li>
<p>이때, 첫번째 사례부터 k번째 사례로 k + 1 번째 사례가 옳다고 증명하면, 이는 수학적으로 증명이 된다.</p>
</li>
</ol>
<p>가우스 공식이 맞음을 증명하는 방법도 위 방법을 통해서 증명이 가능하다.</p>
<h2 id="예시--정렬-알고리즘">예시 : 정렬 알고리즘<a hidden class="anchor" aria-hidden="true" href="#예시--정렬-알고리즘">#</a></h2>
<p>정렬 문제란, 입력으로 특정 숫자의 나열에 대해 증가하는 순서의 순열로 출력하게 만드는 문제를 뜻한다.</p>
<h3 id="삽입-정렬이-무엇인가">삽입 정렬이 무엇인가?<a hidden class="anchor" aria-hidden="true" href="#삽입-정렬이-무엇인가">#</a></h3>
<p>삽입 정렬은 정렬 문제를 푸는 알고리즘 중에 하나이다.</p>
<pre tabindex="0"><code>A[] 는 입력된 배열

for j &lt;- 2 to N
    do key &lt;- A[j]
        i &lt;- j-1 // i는 j-1부터 1까지 순회를 할 것이다.
        while i &gt; 0 and A[i] &gt; key
            do A[i + 1] &lt;- A[i]
                i &lt;- i-1
        A[i+1] &lt;- key
</code></pre><p>위 예시를 잘 보면, j번째 순회에서 앞의 원소들을 하나하나씩 읽으며, j번째 값보다 i번째 값이 크면 하나씩 뒤로 넘겨준다.</p>
<p>그러다가, 작거나 같은 순간이 온다면, 그자리에 j번째 원소를 집어넣어주는 작업을 한다.</p>
<h3 id="알고리즘-분석하기">알고리즘 분석하기<a hidden class="anchor" aria-hidden="true" href="#알고리즘-분석하기">#</a></h3>
<p>해당 알고리즘이 빠른가? -&gt; 걸리는 시간이 얼마나 되는가?</p>
<p>알고리즘이 <code>좋은가?</code> -&gt; 어떻게 판별할 것인가?</p>
<p>알고리즘이 <code>정확한가?</code> -&gt; 어떻게 증명할 것인가?</p>
<p>위의 사항들에 대해서 말할 수 있어야할 것이다.</p>
<p>분석에 대해서는 아래 3가지 경우의 수로 나뉠 수 있다.</p>
<ul>
<li>
<p>worst case : 가장 최악의 경우의 수를 뜻합니다. 시간이 가장 오래걸리는 경우를 뜻하지요.</p>
</li>
<li>
<p>average case : 평균적인 경우의 수를 뜻합니다. 모든 경우의 수에 대해 평균으로 나누어 계산을 하므로 구하기 어렵습니다.</p>
</li>
<li>
<p>best-case : 가장 빠르게 될 경우의 수를 뜻합니다. 시간이 가장 안걸리므로 너무 편향적인 결과를 보여주기도 합니다.</p>
</li>
</ul>
<p>정확한 속도를 계산할 수 없어서 <code>점근 표기법 (Asymptotic Analysis)</code> 을 활용한다.</p>
<p>삽입정렬에서는 worst-case 는 역순으로 정렬된 배열이 주어졌을 때 일 것이고, best-case 는 이미 정렬된 배열이 주어졌을 때일 것이다. 그리고 average-case 는 best와 worst 만큼 역순과 정렬된 배열이 주어진 경우일 것이다.</p>
<p>따라서, worst case는 <code>O(n^2)</code>, best case는 <code>O(n)</code>, average case는 <code>O(n^2 / 2) = O(n^2)</code> 일 것이다.</p>
<p>이 표기법에 관해서는 이후 문서에서 상세하게 표시할 것이다.</p>


    </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/2024/2024-07-20-boostcamp-1/">
    <span class="title">« Prev</span>
    <br>
    <span>[부스트캠프 챌린지] 1주차 후기 및 회고
</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/2024/2024-03-24-algorithm-2/">
    <span class="title">Next »</span>
    <br>
    <span>[알고리즘] Chapter 3</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/moozeh">moozeh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
