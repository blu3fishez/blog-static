<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>JWT 토큰 파싱 변경 과정과 협업의 가치에 대한 고민 | blog.moozeh</title>
<meta name="keywords" content="boostcamp">
<meta name="description" content="문제 상황
저는 토큰 인증방식 을 이용하여서 구현했습니다. 토큰 방식으로 해서 세션을 저장할 필요가 없어서 확장성 있게 설계할 수 있어서 좋았습니다.
하지만 문제가 생겼습니다. 기능 확장을 하는데 있어서 문제가 생겼는데요, 문제 상황은 이렇습니다. 질문지 개발을 다른 캠퍼께서하고 계셨는데, 질문지 스크랩에 대한 내용을 리턴해야합니다.
만약 로그인한 유저가 질문지(대충 리소스) 리스트를 받아오는데 있어서 자신이 어떤 질문지를 스크랩했는지 보여주는 식으로 질문지 리스트를 리턴해야한다 하는 유즈 케이스가 있습니다. 문제는 이때, 로그인하지 않은 유저는 모든 질문지 리스트에 스크랩 여부를 false 로 하여 리턴하려고 했었는데요.">
<meta name="author" content="moozeh">
<link rel="canonical" href="https://blog.moozeh.org/posts/2024/2024-12-28-jwt-%ED%86%A0%ED%81%B0-%ED%8C%8C%EC%8B%B1-%EB%B3%80%EA%B2%BD-%EA%B3%BC%EC%A0%95%EA%B3%BC-%ED%98%91%EC%97%85%EC%9D%98-%EA%B0%80%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.moozeh.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.moozeh.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.moozeh.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.moozeh.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.moozeh.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.moozeh.org/posts/2024/2024-12-28-jwt-%ED%86%A0%ED%81%B0-%ED%8C%8C%EC%8B%B1-%EB%B3%80%EA%B2%BD-%EA%B3%BC%EC%A0%95%EA%B3%BC-%ED%98%91%EC%97%85%EC%9D%98-%EA%B0%80%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.moozeh.org/posts/2024/2024-12-28-jwt-%ED%86%A0%ED%81%B0-%ED%8C%8C%EC%8B%B1-%EB%B3%80%EA%B2%BD-%EA%B3%BC%EC%A0%95%EA%B3%BC-%ED%98%91%EC%97%85%EC%9D%98-%EA%B0%80%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC/">
  <meta property="og:site_name" content="blog.moozeh">
  <meta property="og:title" content="JWT 토큰 파싱 변경 과정과 협업의 가치에 대한 고민">
  <meta property="og:description" content="문제 상황 저는 토큰 인증방식 을 이용하여서 구현했습니다. 토큰 방식으로 해서 세션을 저장할 필요가 없어서 확장성 있게 설계할 수 있어서 좋았습니다.
하지만 문제가 생겼습니다. 기능 확장을 하는데 있어서 문제가 생겼는데요, 문제 상황은 이렇습니다. 질문지 개발을 다른 캠퍼께서하고 계셨는데, 질문지 스크랩에 대한 내용을 리턴해야합니다.
만약 로그인한 유저가 질문지(대충 리소스) 리스트를 받아오는데 있어서 자신이 어떤 질문지를 스크랩했는지 보여주는 식으로 질문지 리스트를 리턴해야한다 하는 유즈 케이스가 있습니다. 문제는 이때, 로그인하지 않은 유저는 모든 질문지 리스트에 스크랩 여부를 false 로 하여 리턴하려고 했었는데요.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-28T22:46:02+09:00">
    <meta property="article:modified_time" content="2024-12-28T22:46:02+09:00">
    <meta property="article:tag" content="Boostcamp">
      <meta property="og:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:title" content="JWT 토큰 파싱 변경 과정과 협업의 가치에 대한 고민">
<meta name="twitter:description" content="문제 상황
저는 토큰 인증방식 을 이용하여서 구현했습니다. 토큰 방식으로 해서 세션을 저장할 필요가 없어서 확장성 있게 설계할 수 있어서 좋았습니다.
하지만 문제가 생겼습니다. 기능 확장을 하는데 있어서 문제가 생겼는데요, 문제 상황은 이렇습니다. 질문지 개발을 다른 캠퍼께서하고 계셨는데, 질문지 스크랩에 대한 내용을 리턴해야합니다.
만약 로그인한 유저가 질문지(대충 리소스) 리스트를 받아오는데 있어서 자신이 어떤 질문지를 스크랩했는지 보여주는 식으로 질문지 리스트를 리턴해야한다 하는 유즈 케이스가 있습니다. 문제는 이때, 로그인하지 않은 유저는 모든 질문지 리스트에 스크랩 여부를 false 로 하여 리턴하려고 했었는데요.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.moozeh.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "JWT 토큰 파싱 변경 과정과 협업의 가치에 대한 고민",
      "item": "https://blog.moozeh.org/posts/2024/2024-12-28-jwt-%ED%86%A0%ED%81%B0-%ED%8C%8C%EC%8B%B1-%EB%B3%80%EA%B2%BD-%EA%B3%BC%EC%A0%95%EA%B3%BC-%ED%98%91%EC%97%85%EC%9D%98-%EA%B0%80%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JWT 토큰 파싱 변경 과정과 협업의 가치에 대한 고민",
  "name": "JWT 토큰 파싱 변경 과정과 협업의 가치에 대한 고민",
  "description": "문제 상황 저는 토큰 인증방식 을 이용하여서 구현했습니다. 토큰 방식으로 해서 세션을 저장할 필요가 없어서 확장성 있게 설계할 수 있어서 좋았습니다.\n하지만 문제가 생겼습니다. 기능 확장을 하는데 있어서 문제가 생겼는데요, 문제 상황은 이렇습니다. 질문지 개발을 다른 캠퍼께서하고 계셨는데, 질문지 스크랩에 대한 내용을 리턴해야합니다.\n만약 로그인한 유저가 질문지(대충 리소스) 리스트를 받아오는데 있어서 자신이 어떤 질문지를 스크랩했는지 보여주는 식으로 질문지 리스트를 리턴해야한다 하는 유즈 케이스가 있습니다. 문제는 이때, 로그인하지 않은 유저는 모든 질문지 리스트에 스크랩 여부를 false 로 하여 리턴하려고 했었는데요.\n",
  "keywords": [
    "boostcamp"
  ],
  "articleBody": "문제 상황 저는 토큰 인증방식 을 이용하여서 구현했습니다. 토큰 방식으로 해서 세션을 저장할 필요가 없어서 확장성 있게 설계할 수 있어서 좋았습니다.\n하지만 문제가 생겼습니다. 기능 확장을 하는데 있어서 문제가 생겼는데요, 문제 상황은 이렇습니다. 질문지 개발을 다른 캠퍼께서하고 계셨는데, 질문지 스크랩에 대한 내용을 리턴해야합니다.\n만약 로그인한 유저가 질문지(대충 리소스) 리스트를 받아오는데 있어서 자신이 어떤 질문지를 스크랩했는지 보여주는 식으로 질문지 리스트를 리턴해야한다 하는 유즈 케이스가 있습니다. 문제는 이때, 로그인하지 않은 유저는 모든 질문지 리스트에 스크랩 여부를 false 로 하여 리턴하려고 했었는데요.\n이때, AuthGuard(”jwt”) 를 통해 유저 정보를 받아오고 있었는데, 유저 정보가 없으면 무조건 401 에러를 내뱉기 때문에, 인증 모듈을 구현한 저에게 개선 요청을 하셨습니다. 아래는 실제 코드입니다.\n해당 상황에서 핸들러에 진입하기도 전에 Guard 에서 반환을 시켜버리기 때문에 인증 전략을 수정해야하는 상황이었습니다. 토큰을 전달 받아 scrap 유무를 확인해서 질문지들을 조회하는 API를 하나씩 더 만들 수도 있겠지만, 카테고리에 따라 만드는 경우 등 다양한 유즈케이스가 있어서 확장성 있게 개선하는 방향이 아니라고 판단했습니다.\n@Post() @UseGuards(AuthGuard(\"jwt\")) async createQuestionList( @JwtPayload() token: IJwtPayload, @Req() req, @Body() body: { title: string; contents: string[]; categoryNames: string[]; isPublic: boolean; } ) { try { const { title, contents, categoryNames, isPublic } = body; // 질문지 DTO 준비 const createQuestionListDto: CreateQuestionListDto = { title, contents, categoryNames, isPublic, userId: token.userId, }; // 질문지 생성 const { createdQuestionList, createdQuestions } = await this.questionListService.createQuestionList(createQuestionListDto); return { success: true, message: \"Question list created successfully.\", data: { createdQuestionList, createdQuestions, }, }; } catch (error) { return { success: false, message: \"Failed to create question list.\", error: error.message, }; } } 해결 시도 과정 401 리턴을 저는 JWT 데코레이터 에서 하고 있었습니다. 위 개발일지 글에서 올린 데코레이터 코드와는 다른 이전 코드입니다. 그래서 해당 부분에서 타입 가드가 오류가 날 경우 null 을 리턴해주는 식으로 해결했습니다.\nexport const JwtPayload = createParamDecorator((data: unknown, ctx: ExecutionContext) =\u003e { const request = ctx.switchToHttp().getRequest(); const payload = request.user.jwtToken; if (!isJwtTokenPayload(payload)) { throw new UnauthorizedException(\"Invalid jwt token payload\"); } return payload; }); 해결된 줄 알았으나,, 그럼에도 불구하고 여전히 401 에러를 리턴하고 있었습니다.\n알고보니 passport-jwt 에서 직접적으로 토큰 인증에 실패하면 에러를 출력하고 있었습니다. 이 경우도 verify 함수를 설정해보는 등 여러 시도를 해보았지만,처음부터 토큰을 가져오지 못할 때 바로 401 에러를 자체적으로 리턴하고 있었습니다.\n그래서 이경우도 jsonwebtoken 라이브러리와 passport-custom 으로 자체적으로 해결했습니다.\nimport { Injectable } from \"@nestjs/common\"; import { PassportStrategy } from \"@nestjs/passport\"; import { Strategy } from \"passport-jwt\"; import { Request } from \"express\"; import \"dotenv/config\"; @Injectable() export class AccessTokenStrategy extends PassportStrategy(Strategy, \"jwt\") { constructor() { super({ jwtFromRequest: (req: Request) =\u003e { if (!req || !req.cookies) return null; return req.cookies[\"accessToken\"]; }, secretOrKey: process.env.JWT_ACCESS_TOKEN_SECRET_KEY, passReqToCallback: true, }); } async validate(req: Request, payload: any) { const { userId, username } = payload; return { jwtToken: { userId, username, }, }; } } 생각해보니.. 생각해보니, 컨트롤러의 책임은 API 응답에 있을 수 있겠다는 생각이 들었습니다. 이게 무슨 뜻이냐면, 어떤 요청에 대한 응답의 책임은 컨트롤러에 있다라는 생각입니다. 또한, 아까 사례처럼 오류 처리에 대한 철학을 조금 생각해봤습니다.\n예외를 진짜 마구잡이로 던져서 컨트롤러 핸들러에서 어찌할 줄 모르는 경우를 생각해보면, 에러 핸들링을 하는 범위를 어디서부터 어떻게 해야할지 생각을 다시하게 되었습니다.\n배울 점 이와 관련해서 Claude 에게도 물어보았습니다. 혼자만의 생각을 정리하지 않고, 무언가 자문을 구할 사람이 주변에 없을 경우 이용을 하고 있었는데, 이에 관한 답변도 공유를 하면서 저의 생각을 정리하며 마쳐봅니다.\n질문\n401 등 컨트롤러에서는 응답 코드를 리턴하는 핸들링에 대한 책임이 전적으로 있다고 생각하는데요. 어떻게 생각하시나요?\n클로드의 답변 HTTP 상태 코드의 처리와 관련된 중요한 논점을 제기하셨네요. 컨트롤러의 책임 범위에 대해 제 의견을 말씀드리겠습니다.\n컨트롤러가 상태 코드를 전적으로 처리하는 것보다는, 다음과 같은 계층적 접근이 더 효과적일 수 있습니다:\nException Filters 활용 @Catch(UnauthorizedException) export class HttpExceptionFilter implements ExceptionFilter { catch(exception: UnauthorizedException, host: ArgumentsHost) { const ctx = host.switchToHttp(); const response = ctx.getResponse(); response.status(401).json({ statusCode: 401, message: 'Unauthorized access' }); } } Guards에서의 인증/인가 처리 @Injectable() export class AuthGuard implements CanActivate { canActivate(context: ExecutionContext) { // 인증 실패 시 UnauthorizedException 발생 throw new UnauthorizedException(); } } Interceptors를 통한 공통 응답 처리 @Injectable() export class TransformInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler) { return next.handle().pipe( map(data =\u003e ({ statusCode: context.switchToHttp().getResponse().statusCode, data })) ); } } 이렇게 계층화된 접근을 사용하면 다음과 같은 이점이 있습니다:\n관심사의 분리: 컨트롤러는 비즈니스 로직에만 집중할 수 있습니다 코드 재사용: 공통된 에러 처리 로직을 여러 컨트롤러에서 재사용할 수 있습니다 일관성: 애플리케이션 전반에 걸쳐 일관된 에러 처리가 가능합니다 물론 특수한 경우에는 컨트롤러에서 직접 상태 코드를 다뤄야 할 수도 있습니다. 하지만 대부분의 경우, Nest.js가 제공하는 이러한 기능들을 활용하는 것이 더 효과적인 접근방식이 될 것 같습니다.\n이러한 방식에 대해 어떻게 생각하시나요?\n다시 개선한 협업 과정 가급적이면 Nest.js 에서 제공하는 철학을 지켜야하는게 맞다고 생각이 들지만, 우리 팀에서 협업하는 방식은 팀 전체적으로 원하는 컨벤션을 지키는게 좋다고 생각했습니다.\n위에서 언급했듯, 저희 프로젝트를 백엔드를 맡고 계신 다른 개발자분께서 맡으신 부분이라 최대한 그부분에 편하게 맞춰주려고 노력했습니다. 이전 스터디 세션 리팩토링 과정 에서 배우기를 코드 구현의 철학보다는 팀의 가치를 지키는게 중요하다고 생각했고, 팀이 원하는 컨벤션을 어느정도 맞추는 것도 중요하다고 생각하게 되었습니다.\n![[Pasted image 20241228225723.webp|200]]\n![[Pasted image 20241228225742.webp|200]]\n진정한 협업의 가치는 팀을 먼저 생각하기 가 아닐까 싶습니다. 무엇이든 정답이 없고, 진짜 협업의 가치를 쫓기 위해서는 저나 프레임워크의 원칙보다 팀원의 원칙을 따라가는게 맞지 않나 생각을 했고, 실제로 반영하여 Claude의 답변을 반영하진 않았고, 이대로 진행하려고 합니다!\n",
  "wordCount" : "818",
  "inLanguage": "en",
  "image": "https://blog.moozeh.org/images/papermod-cover.png","datePublished": "2024-12-28T22:46:02+09:00",
  "dateModified": "2024-12-28T22:46:02+09:00",
  "author":{
    "@type": "Person",
    "name": "moozeh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.moozeh.org/posts/2024/2024-12-28-jwt-%ED%86%A0%ED%81%B0-%ED%8C%8C%EC%8B%B1-%EB%B3%80%EA%B2%BD-%EA%B3%BC%EC%A0%95%EA%B3%BC-%ED%98%91%EC%97%85%EC%9D%98-%EA%B0%80%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EB%AF%BC/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.moozeh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.moozeh.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.moozeh.org/" accesskey="h" title="blog.moozeh (Alt + H)">blog.moozeh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.moozeh.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.moozeh.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.moozeh.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      JWT 토큰 파싱 변경 과정과 협업의 가치에 대한 고민
    </h1>
    <div class="post-meta"><span title='2024-12-28 22:46:02 +0900 KST'>December 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;moozeh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%eb%ac%b8%ec%a0%9c-%ec%83%81%ed%99%a9" aria-label="문제 상황">문제 상황</a></li>
                <li>
                    <a href="#%ed%95%b4%ea%b2%b0-%ec%8b%9c%eb%8f%84-%ea%b3%bc%ec%a0%95" aria-label="해결 시도 과정">해결 시도 과정</a><ul>
                        
                <li>
                    <a href="#%ed%95%b4%ea%b2%b0%eb%90%9c-%ec%a4%84-%ec%95%8c%ec%95%98%ec%9c%bc%eb%82%98" aria-label="해결된 줄 알았으나,,">해결된 줄 알았으나,,</a></li>
                <li>
                    <a href="#%ec%83%9d%ea%b0%81%ed%95%b4%eb%b3%b4%eb%8b%88" aria-label="생각해보니..">생각해보니..</a></li></ul>
                </li>
                <li>
                    <a href="#%eb%b0%b0%ec%9a%b8-%ec%a0%90" aria-label="배울 점">배울 점</a><ul>
                        
                <li>
                    <a href="#%ed%81%b4%eb%a1%9c%eb%93%9c%ec%9d%98-%eb%8b%b5%eb%b3%80" aria-label="클로드의 답변">클로드의 답변</a></li>
                <li>
                    <a href="#%eb%8b%a4%ec%8b%9c-%ea%b0%9c%ec%84%a0%ed%95%9c-%ed%98%91%ec%97%85-%ea%b3%bc%ec%a0%95" aria-label="다시 개선한 협업 과정">다시 개선한 협업 과정</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><h2 id="문제-상황">문제 상황<a hidden class="anchor" aria-hidden="true" href="#문제-상황">#</a></h2>
<p>저는 <code>토큰 인증방식</code> 을 이용하여서 구현했습니다. 토큰 방식으로 해서 세션을 저장할 필요가 없어서 확장성 있게 설계할 수 있어서 좋았습니다.</p>
<p>하지만 문제가 생겼습니다. 기능 확장을 하는데 있어서 문제가 생겼는데요, 문제 상황은 이렇습니다. 질문지 개발을 다른 캠퍼께서하고 계셨는데, 질문지 스크랩에 대한 내용을 리턴해야합니다.</p>
<p>만약 로그인한 유저가 질문지(대충 리소스) 리스트를 받아오는데 있어서 자신이 어떤 질문지를 스크랩했는지 보여주는 식으로 질문지 리스트를 리턴해야한다 하는 유즈 케이스가 있습니다. 문제는 이때, 로그인하지 않은 유저는 모든 질문지 리스트에 스크랩 여부를 <code>false</code> 로 하여 리턴하려고 했었는데요.</p>
<p>이때, <code>AuthGuard(”jwt”)</code> 를 통해 유저 정보를 받아오고 있었는데, 유저 정보가 없으면 무조건 <code>401</code> 에러를 내뱉기 때문에, 인증 모듈을 구현한 저에게 개선 요청을 하셨습니다. 아래는 실제 코드입니다.</p>
<p>해당 상황에서 핸들러에 진입하기도 전에 Guard 에서 반환을 시켜버리기 때문에 인증 전략을 수정해야하는 상황이었습니다. 토큰을 전달 받아 scrap 유무를 확인해서 질문지들을 조회하는 API를 하나씩 더 만들 수도 있겠지만, 카테고리에 따라 만드는 경우 등 다양한 유즈케이스가 있어서 확장성 있게 개선하는 방향이 아니라고 판단했습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kd">@Post</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kd">@UseGuards</span><span class="p">(</span><span class="nx">AuthGuard</span><span class="p">(</span><span class="s2">&#34;jwt&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kr">async</span> <span class="nx">createQuestionList</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kd">@JwtPayload</span><span class="p">()</span> <span class="nx">token</span>: <span class="kt">IJwtPayload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kd">@Req</span><span class="p">()</span> <span class="nx">req</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kd">@Body</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">body</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">title</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">contents</span>: <span class="kt">string</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">        <span class="nx">categoryNames</span>: <span class="kt">string</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">        <span class="nx">isPublic</span>: <span class="kt">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="p">{</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">contents</span><span class="p">,</span> <span class="nx">categoryNames</span><span class="p">,</span> <span class="nx">isPublic</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">body</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 질문지 DTO 준비
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="nx">createQuestionListDto</span>: <span class="kt">CreateQuestionListDto</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">title</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">contents</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">categoryNames</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">isPublic</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">userId</span>: <span class="kt">token.userId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 질문지 생성
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kr">const</span> <span class="p">{</span> <span class="nx">createdQuestionList</span><span class="p">,</span> <span class="nx">createdQuestions</span> <span class="p">}</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">questionListService</span><span class="p">.</span><span class="nx">createQuestionList</span><span class="p">(</span><span class="nx">createQuestionListDto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">success</span>: <span class="kt">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">message</span><span class="o">:</span> <span class="s2">&#34;Question list created successfully.&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">createdQuestionList</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nx">createdQuestions</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">success</span>: <span class="kt">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">message</span><span class="o">:</span> <span class="s2">&#34;Failed to create question list.&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">error</span>: <span class="kt">error.message</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="해결-시도-과정">해결 시도 과정<a hidden class="anchor" aria-hidden="true" href="#해결-시도-과정">#</a></h2>
<p>401 리턴을 저는 <code>JWT 데코레이터</code> 에서 하고 있었습니다. 위 개발일지 글에서 올린 데코레이터 코드와는 다른 이전 코드입니다. 그래서 해당 부분에서 타입 가드가 오류가 날 경우 <code>null</code> 을 리턴해주는 식으로 해결했습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">JwtPayload</span> <span class="o">=</span> <span class="nx">createParamDecorator</span><span class="p">((</span><span class="nx">data</span>: <span class="kt">unknown</span><span class="p">,</span> <span class="nx">ctx</span>: <span class="kt">ExecutionContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">switchToHttp</span><span class="p">().</span><span class="nx">getRequest</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">payload</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">jwtToken</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isJwtTokenPayload</span><span class="p">(</span><span class="nx">payload</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nx">UnauthorizedException</span><span class="p">(</span><span class="s2">&#34;Invalid jwt token payload&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span></code></pre></div><h3 id="해결된-줄-알았으나">해결된 줄 알았으나,,<a hidden class="anchor" aria-hidden="true" href="#해결된-줄-알았으나">#</a></h3>
<p>그럼에도 불구하고 여전히 <code>401</code> 에러를 리턴하고 있었습니다.</p>
<p>알고보니 <code>passport-jwt</code> 에서 직접적으로 토큰 인증에 실패하면 에러를 출력하고 있었습니다. 이 경우도 <code>verify</code> 함수를 설정해보는 등 여러 시도를 해보았지만,처음부터 토큰을 가져오지 못할 때 바로 <code>401</code> 에러를 자체적으로 리턴하고 있었습니다.</p>
<p>그래서 이경우도 <code>jsonwebtoken</code> 라이브러리와 <code>passport-custom</code> 으로 자체적으로 해결했습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span> <span class="p">}</span> <span class="kr">from</span> <span class="s2">&#34;@nestjs/common&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">PassportStrategy</span> <span class="p">}</span> <span class="kr">from</span> <span class="s2">&#34;@nestjs/passport&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Strategy</span> <span class="p">}</span> <span class="kr">from</span> <span class="s2">&#34;passport-jwt&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Request</span> <span class="p">}</span> <span class="kr">from</span> <span class="s2">&#34;express&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">import</span> <span class="s2">&#34;dotenv/config&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">@Injectable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">AccessTokenStrategy</span> <span class="kr">extends</span> <span class="nx">PassportStrategy</span><span class="p">(</span><span class="nx">Strategy</span><span class="p">,</span> <span class="s2">&#34;jwt&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">super</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">            <span class="nx">jwtFromRequest</span><span class="o">:</span> <span class="p">(</span><span class="nx">req</span>: <span class="kt">Request</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">req</span> <span class="o">||</span> <span class="o">!</span><span class="nx">req</span><span class="p">.</span><span class="nx">cookies</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nx">req</span><span class="p">.</span><span class="nx">cookies</span><span class="p">[</span><span class="s2">&#34;accessToken&#34;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="nx">secretOrKey</span>: <span class="kt">process.env.JWT_ACCESS_TOKEN_SECRET_KEY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="nx">passReqToCallback</span>: <span class="kt">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kr">async</span> <span class="nx">validate</span><span class="p">(</span><span class="nx">req</span>: <span class="kt">Request</span><span class="p">,</span> <span class="nx">payload</span>: <span class="kt">any</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">const</span> <span class="p">{</span> <span class="nx">userId</span><span class="p">,</span> <span class="nx">username</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">payload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">jwtToken</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">userId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="nx">username</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">},</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="생각해보니">생각해보니..<a hidden class="anchor" aria-hidden="true" href="#생각해보니">#</a></h3>
<p>생각해보니, 컨트롤러의 책임은 API 응답에 있을 수 있겠다는 생각이 들었습니다. 이게 무슨 뜻이냐면, <strong>어떤 요청에 대한 응답의 책임은 컨트롤러에 있다</strong>라는 생각입니다. 또한, 아까 사례처럼 오류 처리에 대한 철학을 조금 생각해봤습니다.</p>
<p>예외를 진짜 마구잡이로 던져서 컨트롤러 핸들러에서 어찌할 줄 모르는 경우를 생각해보면, 에러 핸들링을 하는 범위를 어디서부터 어떻게 해야할지 생각을 다시하게 되었습니다.</p>
<h2 id="배울-점">배울 점<a hidden class="anchor" aria-hidden="true" href="#배울-점">#</a></h2>
<p>이와 관련해서 <code>Claude</code> 에게도 물어보았습니다. 혼자만의 생각을 정리하지 않고, 무언가 자문을 구할 사람이 주변에 없을 경우 이용을 하고 있었는데, 이에 관한 답변도 공유를 하면서 저의 생각을 정리하며 마쳐봅니다.</p>
<blockquote>
<p>질문</p>
<p>401 등 컨트롤러에서는 응답 코드를 리턴하는 핸들링에 대한 책임이 전적으로 있다고 생각하는데요. 어떻게 생각하시나요?</p></blockquote>
<h3 id="클로드의-답변">클로드의 답변<a hidden class="anchor" aria-hidden="true" href="#클로드의-답변">#</a></h3>
<p>HTTP 상태 코드의 처리와 관련된 중요한 논점을 제기하셨네요. 컨트롤러의 책임 범위에 대해 제 의견을 말씀드리겠습니다.</p>
<p>컨트롤러가 상태 코드를 전적으로 처리하는 것보다는, 다음과 같은 계층적 접근이 더 효과적일 수 있습니다:</p>
<blockquote>
<ol>
<li>Exception Filters 활용</li>
</ol></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kd">@Catch</span><span class="p">(</span><span class="nx">UnauthorizedException</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">HttpExceptionFilter</span> <span class="kr">implements</span> <span class="nx">ExceptionFilter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">catch</span><span class="p">(</span><span class="nx">exception</span>: <span class="kt">UnauthorizedException</span><span class="p">,</span> <span class="nx">host</span>: <span class="kt">ArgumentsHost</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">host</span><span class="p">.</span><span class="nx">switchToHttp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getResponse</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">response</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">401</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">      <span class="nx">statusCode</span>: <span class="kt">401</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;Unauthorized access&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<ol start="2">
<li>Guards에서의 인증/인가 처리</li>
</ol></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kd">@Injectable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">AuthGuard</span> <span class="kr">implements</span> <span class="nx">CanActivate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">canActivate</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 인증 실패 시 UnauthorizedException 발생
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">throw</span> <span class="k">new</span> <span class="nx">UnauthorizedException</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<ol start="3">
<li>Interceptors를 통한 공통 응답 처리</li>
</ol></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tsx" data-lang="tsx"><span class="line"><span class="cl"><span class="kd">@Injectable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">TransformInterceptor</span> <span class="kr">implements</span> <span class="nx">NestInterceptor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">intercept</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span> <span class="nx">next</span>: <span class="kt">CallHandler</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nx">handle</span><span class="p">().</span><span class="nx">pipe</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="nx">map</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">({</span>
</span></span><span class="line"><span class="cl">        <span class="nx">statusCode</span>: <span class="kt">context.switchToHttp</span><span class="p">().</span><span class="nx">getResponse</span><span class="p">().</span><span class="nx">statusCode</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">data</span>
</span></span><span class="line"><span class="cl">      <span class="p">}))</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이렇게 계층화된 접근을 사용하면 다음과 같은 이점이 있습니다:</p>
<ol>
<li>관심사의 분리: 컨트롤러는 비즈니스 로직에만 집중할 수 있습니다</li>
<li>코드 재사용: 공통된 에러 처리 로직을 여러 컨트롤러에서 재사용할 수 있습니다</li>
<li>일관성: 애플리케이션 전반에 걸쳐 일관된 에러 처리가 가능합니다</li>
</ol>
<p>물론 특수한 경우에는 컨트롤러에서 직접 상태 코드를 다뤄야 할 수도 있습니다. 하지만 대부분의 경우, Nest.js가 제공하는 이러한 기능들을 활용하는 것이 더 효과적인 접근방식이 될 것 같습니다.</p>
<p>이러한 방식에 대해 어떻게 생각하시나요?</p>
<h3 id="다시-개선한-협업-과정">다시 개선한 협업 과정<a hidden class="anchor" aria-hidden="true" href="#다시-개선한-협업-과정">#</a></h3>
<p>가급적이면 <code>Nest.js</code> 에서 제공하는 철학을 지켜야하는게 맞다고 생각이 들지만, 우리 팀에서 협업하는 방식은 팀 전체적으로 원하는 컨벤션을 지키는게 좋다고 생각했습니다.</p>
<p>위에서 언급했듯, 저희 프로젝트를 백엔드를 맡고 계신 다른 개발자분께서 맡으신 부분이라 최대한 그부분에 편하게 맞춰주려고 노력했습니다. 이전 <code>스터디 세션 리팩토링 과정</code> 에서 배우기를 <code>코드 구현의 철학보다는 팀의 가치를 지키는게 중요하다고 생각했고</code>, 팀이 원하는 컨벤션을 어느정도 맞추는 것도 중요하다고 생각하게 되었습니다.</p>
<img src="/assets/images/Pasted%20image%2020241228225723.webp" alt="Pasted image 20241228225723" loading="lazy" style="width: 200px;">
<img src="/assets/images/Pasted%20image%2020241228225742.webp" alt="Pasted image 20241228225742" loading="lazy" style="width: 200px;">
<p>진정한 협업의 가치는 <code>팀을 먼저 생각하기</code> 가 아닐까 싶습니다. 무엇이든 정답이 없고, 진짜 협업의 가치를 쫓기 위해서는 저나 프레임워크의 원칙보다 팀원의 원칙을 따라가는게 맞지 않나 생각을 했고, 실제로 반영하여 <code>Claude</code>의 답변을 반영하진 않았고, 이대로 진행하려고 합니다!</p>


    </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.moozeh.org/tags/boostcamp/">Boostcamp</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.moozeh.org/posts/2024/2024-12-28-the-redirect_uri-is-not-associated-with-this-application-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/">
    <span class="title">« Prev</span>
    <br>
    <span>The redirect_uri is not associated with this application 오류 해결</span>
  </a>
  <a class="next" href="https://blog.moozeh.org/posts/2024/2024-12-21-custom-passport-%EB%A1%9C-github-oauth-%EB%A1%9C%EC%A7%81%EC%9D%84-%EC%A7%81%EC%A0%91-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/">
    <span class="title">Next »</span>
    <br>
    <span>Custom Passport 로 Github OAuth 로직을 직접 구현하기</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/moozeh">moozeh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
