<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Nest.js Modules 를 통해 배우는 의존성 주입 | blog.blu3fishez</title>
<meta name="keywords" content="Nestjs">

<meta name="description" content=" [!important]
제가 몰랐던 백엔드 지식 위주로 이야기 합니다. Express, MVC 패턴에 관해 공부하고 오셔야 이해할 수 있습니다.
Express 를 배우고, 보다 좀 더 정형화된 형식이 필요함을 느꼈다.
코드를 보다 견고하게 짜는 것에 대한 욕심이 생겼고, 에러 처리 등 다양한 예외 처리 로직들을 수행해보면서, 코드의 안정성이 중요하다는 걸 느꼈다.
그래서 이번에 Nest.js 를 배우기 시작했는데, Controller Service 등등.. 유명한 계층은 내가 아는 일들을 그대로 수행하고 있어서 배우는데 문제가 없었다.
그런데, 왜 @Module 데코레이터라는 계층이 있는 걸까? 궁금해져서 조금 알아보았다.
">
<meta name="author" content="blu3fishez">
<link rel="canonical" href="https://blog.blu3fishez.org/posts/2024/2024-10-25-nestjs-modules-%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d3f251795b1b2227fec87dbd9339a39a72025c1e2678c7b78fdbf5213fbef45d.css" integrity="sha256-0/JReVsbIif&#43;yH29kzmjmnICXB4meMe3j9v1IT&#43;&#43;9F0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.blu3fishez.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.blu3fishez.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.blu3fishez.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.blu3fishez.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.blu3fishez.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.blu3fishez.org/posts/2024/2024-10-25-nestjs-modules-%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.blu3fishez.org/posts/2024/2024-10-25-nestjs-modules-%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85/">
  <meta property="og:site_name" content="blog.blu3fishez">
  <meta property="og:title" content="Nest.js Modules 를 통해 배우는 의존성 주입">
  <meta property="og:description" content=" [!important]
제가 몰랐던 백엔드 지식 위주로 이야기 합니다. Express, MVC 패턴에 관해 공부하고 오셔야 이해할 수 있습니다.
Express 를 배우고, 보다 좀 더 정형화된 형식이 필요함을 느꼈다.
코드를 보다 견고하게 짜는 것에 대한 욕심이 생겼고, 에러 처리 등 다양한 예외 처리 로직들을 수행해보면서, 코드의 안정성이 중요하다는 걸 느꼈다.
그래서 이번에 Nest.js 를 배우기 시작했는데, Controller Service 등등.. 유명한 계층은 내가 아는 일들을 그대로 수행하고 있어서 배우는데 문제가 없었다.
그런데, 왜 @Module 데코레이터라는 계층이 있는 걸까? 궁금해져서 조금 알아보았다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-10-25T12:10:38+09:00">
    <meta property="article:modified_time" content="2024-10-25T12:10:38+09:00">
    <meta property="article:tag" content="Nestjs">
      <meta property="og:image" content="https://blog.blu3fishez.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.blu3fishez.org/images/papermod-cover.png">
<meta name="twitter:title" content="Nest.js Modules 를 통해 배우는 의존성 주입">
<meta name="twitter:description" content="
[!important]
제가 몰랐던 백엔드 지식 위주로 이야기 합니다.
Express, MVC 패턴에 관해 공부하고 오셔야 이해할 수 있습니다.
Express 를 배우고, 보다 좀 더 정형화된 형식이 필요함을 느꼈다.
코드를 보다 견고하게 짜는 것에 대한 욕심이 생겼고, 에러 처리 등 다양한 예외 처리 로직들을 수행해보면서, 코드의 안정성이 중요하다는 걸 느꼈다.
그래서 이번에 Nest.js 를 배우기 시작했는데, Controller Service 등등.. 유명한 계층은 내가 아는 일들을 그대로 수행하고 있어서 배우는데 문제가 없었다.
그런데, 왜 @Module 데코레이터라는 계층이 있는 걸까? 궁금해져서 조금 알아보았다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.blu3fishez.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Nest.js Modules 를 통해 배우는 의존성 주입",
      "item": "https://blog.blu3fishez.org/posts/2024/2024-10-25-nestjs-modules-%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Nest.js Modules 를 통해 배우는 의존성 주입",
  "name": "Nest.js Modules 를 통해 배우는 의존성 주입",
  "description": " [!important]\n제가 몰랐던 백엔드 지식 위주로 이야기 합니다. Express, MVC 패턴에 관해 공부하고 오셔야 이해할 수 있습니다.\nExpress 를 배우고, 보다 좀 더 정형화된 형식이 필요함을 느꼈다.\n코드를 보다 견고하게 짜는 것에 대한 욕심이 생겼고, 에러 처리 등 다양한 예외 처리 로직들을 수행해보면서, 코드의 안정성이 중요하다는 걸 느꼈다.\n그래서 이번에 Nest.js 를 배우기 시작했는데, Controller Service 등등.. 유명한 계층은 내가 아는 일들을 그대로 수행하고 있어서 배우는데 문제가 없었다.\n그런데, 왜 @Module 데코레이터라는 계층이 있는 걸까? 궁금해져서 조금 알아보았다.\n",
  "keywords": [
    "Nestjs"
  ],
  "articleBody": " [!important]\n제가 몰랐던 백엔드 지식 위주로 이야기 합니다. Express, MVC 패턴에 관해 공부하고 오셔야 이해할 수 있습니다.\nExpress 를 배우고, 보다 좀 더 정형화된 형식이 필요함을 느꼈다.\n코드를 보다 견고하게 짜는 것에 대한 욕심이 생겼고, 에러 처리 등 다양한 예외 처리 로직들을 수행해보면서, 코드의 안정성이 중요하다는 걸 느꼈다.\n그래서 이번에 Nest.js 를 배우기 시작했는데, Controller Service 등등.. 유명한 계층은 내가 아는 일들을 그대로 수행하고 있어서 배우는데 문제가 없었다.\n그런데, 왜 @Module 데코레이터라는 계층이 있는 걸까? 궁금해져서 조금 알아보았다.\n🍀 Module 이란 어떤 역할을 할까? 💉 의존성 주입이란 무엇일까 내가 잘못 알고 있었던 지식이 있었다. 나는 여태까지 의존성 주입이 사용자가 어떤 모듈을 굳이 import 하는 구문 자체가 개발자에게 책임이 있다고 잘못 이해하고 있었다.\n의존성 주입의 정의 의존성 주입은 살짝 다르다. 구현체는 그대로 두되, 실제 내부 구현을 우리가 다양한 방식으로할 수 있게끔 하는 것이다.\n이게 무슨 뜻이냐면, 특정 클래스가 가진 메서드 (반환 타입까지) 가 정의된 스펙만을 지키면 그 내부 구조는 우리가 마음대로할 수 있는 것이다.\n스펙 자체만을 정의하고, 우리는 그걸 쓰기만 하는 것이다. 그렇게된다면 협업에 있어서 효용성이 생기면서 동시에 타입 정의도 할 수 있을 거라 생각했다.\n그래서 궁금한 점이, 결국엔 Nest에서는 자체적인 스펙을 정의해두는 타입 명시 클래스가 있어야하지 않을까?\n스펙 자체를 한번 더 구현을 하여 구현을 두번해야한다고 생각하면, 어딘가 불편할 것 같다고 생각했는데, 제어의 역전이란 의미 자체를 내가 잘못 이해하고 있었다.\n제어의 역전의 정의 의존성 주입 시스템에게 이 클래스의 인스턴스 들을 관리해주세요 라고 생각하는게 옳다.\n각각의 의존성의 정의를 주입 받는 클래스 내에서 new 생성자를 호출할 게 아니라, 의존성 시스템에서 직접 인스턴스를 만들어서 주입 시켜주는 것이 핵심이다.\n그렇게 된다면, 싱글턴 패턴을 만들 수 있는 것 아닌가? 라고 생각할 수 있다.\n그 부분의 경우 우리가 유동적으로 조절해줄 수 있는 것이다.\n싱글턴과 차이점 유연성 필요에 따라 해당 인스턴스의 범위를 내가 정의할 수 있는게 크다. 일종의 인스턴스 관리 툴이라고 생각하면 편할 듯하다. 예를들어, Nest 에서 @Injectable 데코레이터 인자로 scope 값을 REQUEST 범위를 설정하면, 각 요청마다 새로운 인스턴스가 생성된다고도 한다. 생명 주기 관리 Nest.js 에서는 실제로 생성을 싱글턴으로 할게 아니라, 해당 클래스가 언제 종료되고 새롭게 재생성할 수 있을지까지 별도로 관리할 수 있을 것이다. 🐈‍⬛ Nest의 의존성 주입 방식 그런데, 나는 여기서 이상하게 생각했다.\n왜냐하면 결국 providers 배열을 통해 의존성 주입 대상을 전부 정의해주게 된다면, 굳이 @Injectable 데코레이터를 등록해야하는가? 라는 의문이 들었기 때문이다.\nNest 에서는 이 둘이 함께 작동하여 의존성 주입 시스템을 구성한다.\nAI에게 물어보았더니, 간단한 동작 예시를 알려주었다.\n아래 코드는 실제 Nest 구현체가 아니라, Nest의 동작 방식 이해를 위한 예제이다. 직접 만든다면 참고해볼 수 있을 것 같다.\nclass DIContainer { private providers = new Map(); register(token: any, provider: any) { this.providers.set(token, provider); } resolve(target: any) { const tokens = Reflect.getMetadata('design:paramtypes', target) || []; const injections = tokens.map(token =\u003e this.resolve(this.providers.get(token))); return new target(...injections); } } function Module(metadata: { providers: any[] }) { return function(target: any) { const container = new DIContainer(); metadata.providers.forEach(provider =\u003e { container.register(provider, provider); }); // 이 부분은 실제로는 Nest.js 내부에서 처리됩니다 target.prototype.container = container; } } @Injectable() class UserService { getUsers() { return ['User1', 'User2']; } } @Injectable() class UserController { constructor(private userService: UserService) {} getUsers() { return this.userService.getUsers(); } } @Module({ providers: [UserService, UserController] }) class AppModule {} // 사용 예시 (이 부분은 Nest.js에서 내부적으로 처리됩니다) const appModule = new AppModule(); const userController = appModule.container.resolve(UserController); console.log(userController.getUsers()); // ['User1', 'User2'] Module 데코레이터를 사용할 때, 각각의 의존성 주입 컨테이너를 사용하는데, 실제 Nest.js 는 전역 의존성 컨테이너를 사용한다. 대신, 전역 컨테이너의 일부로 사용된다. Injectable 데코레이터가 별도로 필요한 이유 providers 를 통해 export 를 할 수 있고, Injectable 을 통해서 내가 원하는 범위 간 의존성 전달을 해줄 수 있는 장점이 있다.\n또한, 이 과정에서 내부적으로는 메타데이터에 클래스를 추가하여 의존성 타입을 정의해줄 수 있다.\n마지막으로, 가독성 측면에서 해당 클래스가 주입될 수 있는 클래스임을 인지시켜주는 부분도 있다.\n반대로, providers 만으로 의존성 주입이 될 수 없는 이유로 @Injectable 데코레이터를 사용하는 클래스 내에서도 의존성 주입을 사용하기 위한 것도 있다.\nReflect를 사용하는 이유 단순히 Map 으로 대체될 수 없는 Reflect 만의 중요한 이점이 있기 때문에 사용된다.\n방금 언급한 메타 데이터에 클래스를 추가할 수 있다는 것은 Reflect 를 이용하여 타입 정보를 의존성 등록 시 보존할 수 있다.\nclass MyService { constructor(private dependency: SomeDependency) {} } // 런타임에 타입 정보 접근 가능 const paramTypes = Reflect.getMetadata('design:paramtypes', MyService); 위와 같이, 런타임에 타입 정보에 접근이 가능하다.\n또한, 생성자 파라미터의 타입 정보, 특정 파라미터에 적용된 커스텀 데코레이터, 클래스 자체에 적용된 데코레이터 정보 모두 런타임에 접근하고 처리할 수 있다고 한다.\n@Injectable() class ComplexService { constructor( private service1: Service1, @Inject('CONFIG') private config: Config, @Optional() private optionalService?: OptionalService ) {} } 정리하자면, Reflect 맵을 이용하면 타입 정보를 보존하면서 런타임에 (실제 의존성이 주입될 때) 어떤 타입 정보가 들어갈 지 타입스크립트 컴파일러가 알 수 있다.\n",
  "wordCount" : "732",
  "inLanguage": "en",
  "image": "https://blog.blu3fishez.org/images/papermod-cover.png","datePublished": "2024-10-25T12:10:38+09:00",
  "dateModified": "2024-10-25T12:10:38+09:00",
  "author":{
    "@type": "Person",
    "name": "blu3fishez"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.blu3fishez.org/posts/2024/2024-10-25-nestjs-modules-%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.blu3fishez",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.blu3fishez.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.blu3fishez.org/" accesskey="h" title="blog.blu3fishez (Alt + H)">blog.blu3fishez</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.blu3fishez.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.blu3fishez.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.blu3fishez.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.blu3fishez.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.blu3fishez.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Nest.js Modules 를 통해 배우는 의존성 주입
    </h1>
    <div class="post-meta"><span title='2024-10-25 12:10:38 +0900 KST'>October 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;blu3fishez

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#-module-%ec%9d%b4%eb%9e%80-%ec%96%b4%eb%96%a4-%ec%97%ad%ed%95%a0%ec%9d%84-%ed%95%a0%ea%b9%8c" aria-label="🍀 Module 이란 어떤 역할을 할까?">🍀 Module 이란 어떤 역할을 할까?</a></li>
                <li>
                    <a href="#-%ec%9d%98%ec%a1%b4%ec%84%b1-%ec%a3%bc%ec%9e%85%ec%9d%b4%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%bc%ea%b9%8c" aria-label="💉 의존성 주입이란 무엇일까">💉 의존성 주입이란 무엇일까</a><ul>
                        
                <li>
                    <a href="#%ec%9d%98%ec%a1%b4%ec%84%b1-%ec%a3%bc%ec%9e%85%ec%9d%98-%ec%a0%95%ec%9d%98" aria-label="의존성 주입의 정의">의존성 주입의 정의</a></li>
                <li>
                    <a href="#%ec%a0%9c%ec%96%b4%ec%9d%98-%ec%97%ad%ec%a0%84%ec%9d%98-%ec%a0%95%ec%9d%98" aria-label="제어의 역전의 정의">제어의 역전의 정의</a></li>
                <li>
                    <a href="#%ec%8b%b1%ea%b8%80%ed%84%b4%ea%b3%bc-%ec%b0%a8%ec%9d%b4%ec%a0%90" aria-label="싱글턴과 차이점">싱글턴과 차이점</a></li></ul>
                </li>
                <li>
                    <a href="#-nest%ec%9d%98-%ec%9d%98%ec%a1%b4%ec%84%b1-%ec%a3%bc%ec%9e%85-%eb%b0%a9%ec%8b%9d" aria-label="🐈‍⬛ Nest의 의존성 주입 방식">🐈‍⬛ Nest의 의존성 주입 방식</a><ul>
                        
                <li>
                    <a href="#injectable-%eb%8d%b0%ec%bd%94%eb%a0%88%ec%9d%b4%ed%84%b0%ea%b0%80-%eb%b3%84%eb%8f%84%eb%a1%9c-%ed%95%84%ec%9a%94%ed%95%9c-%ec%9d%b4%ec%9c%a0" aria-label="Injectable 데코레이터가 별도로 필요한 이유">Injectable 데코레이터가 별도로 필요한 이유</a></li>
                <li>
                    <a href="#reflect%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-%ec%9d%b4%ec%9c%a0" aria-label="Reflect를 사용하는 이유">Reflect를 사용하는 이유</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><blockquote>
<p>[!important]</p>
<p>제가 몰랐던 백엔드 지식 위주로 이야기 합니다.
Express, MVC 패턴에 관해 공부하고 오셔야 이해할 수 있습니다.</p></blockquote>
<p>Express 를 배우고, 보다 좀 더 정형화된 형식이 필요함을 느꼈다.</p>
<p>코드를 보다 견고하게 짜는 것에 대한 욕심이 생겼고, 에러 처리 등 다양한 예외 처리 로직들을 수행해보면서, 코드의 안정성이 중요하다는 걸 느꼈다.</p>
<p>그래서 이번에 Nest.js 를 배우기 시작했는데, <code>Controller</code> <code>Service</code> 등등.. 유명한 계층은 내가 아는 일들을 그대로 수행하고 있어서 배우는데 문제가 없었다.</p>
<p>그런데, 왜 <code>@Module</code> 데코레이터라는 계층이 있는 걸까? 궁금해져서 조금 알아보았다.</p>
<h2 id="-module-이란-어떤-역할을-할까">🍀 Module 이란 어떤 역할을 할까?<a hidden class="anchor" aria-hidden="true" href="#-module-이란-어떤-역할을-할까">#</a></h2>
<h2 id="-의존성-주입이란-무엇일까">💉 의존성 주입이란 무엇일까<a hidden class="anchor" aria-hidden="true" href="#-의존성-주입이란-무엇일까">#</a></h2>
<p>내가 잘못 알고 있었던 지식이 있었다.
나는 여태까지 의존성 주입이 사용자가 어떤 모듈을 굳이 <code>import</code> 하는 구문 자체가 개발자에게 책임이 있다고 잘못 이해하고 있었다.</p>
<h3 id="의존성-주입의-정의">의존성 주입의 정의<a hidden class="anchor" aria-hidden="true" href="#의존성-주입의-정의">#</a></h3>
<p>의존성 주입은 살짝 다르다. <strong>구현체는 그대로 두되, 실제 내부 구현을 우리가 다양한 방식으로할 수 있게끔 하는 것이다.</strong></p>
<p>이게 무슨 뜻이냐면, 특정 클래스가 가진 메서드 (반환 타입까지) 가 정의된 스펙만을 지키면 그 내부 구조는 우리가 마음대로할 수 있는 것이다.</p>
<p>스펙 자체만을 정의하고, 우리는 그걸 쓰기만 하는 것이다.  그렇게된다면 협업에 있어서 효용성이 생기면서 동시에 타입 정의도 할 수 있을 거라 생각했다.</p>
<p>그래서 궁금한 점이, 결국엔 Nest에서는 자체적인 스펙을 정의해두는 타입 명시 클래스가 있어야하지 않을까?</p>
<p>스펙 자체를 한번 더 구현을 하여 구현을 두번해야한다고 생각하면, 어딘가 불편할 것 같다고 생각했는데, 제어의 역전이란 의미 자체를 내가 잘못 이해하고 있었다.</p>
<h3 id="제어의-역전의-정의">제어의 역전의 정의<a hidden class="anchor" aria-hidden="true" href="#제어의-역전의-정의">#</a></h3>
<p>의존성 주입 시스템에게 <code>이 클래스의 인스턴스 들을 관리해주세요</code> 라고 생각하는게 옳다.</p>
<p>각각의 의존성의 정의를 주입 받는 클래스 내에서 <code>new</code> 생성자를 호출할 게 아니라, 의존성 시스템에서 직접 인스턴스를 만들어서 <code>주입</code> 시켜주는 것이 핵심이다.</p>
<p>그렇게 된다면, <code>싱글턴</code> 패턴을 만들 수 있는 것 아닌가? 라고 생각할 수 있다.</p>
<p>그 부분의 경우 우리가 유동적으로 조절해줄 수 있는 것이다.</p>
<h3 id="싱글턴과-차이점">싱글턴과 차이점<a hidden class="anchor" aria-hidden="true" href="#싱글턴과-차이점">#</a></h3>
<ol>
<li>유연성
<ul>
<li>필요에 따라 해당 인스턴스의 범위를 내가 정의할 수 있는게 크다. 일종의 인스턴스 관리 툴이라고 생각하면 편할 듯하다.</li>
<li>예를들어, <code>Nest</code> 에서 <code>@Injectable</code> 데코레이터 인자로 <code>scope</code> 값을 <code>REQUEST</code> 범위를 설정하면, 각 요청마다 새로운 인스턴스가 생성된다고도 한다.</li>
</ul>
</li>
<li>생명 주기 관리
<ul>
<li>Nest.js 에서는 실제로 생성을 싱글턴으로 할게 아니라, 해당 클래스가 언제 종료되고 새롭게 재생성할 수 있을지까지 별도로 관리할 수 있을 것이다.</li>
</ul>
</li>
</ol>
<h2 id="-nest의-의존성-주입-방식">🐈‍⬛ Nest의 의존성 주입 방식<a hidden class="anchor" aria-hidden="true" href="#-nest의-의존성-주입-방식">#</a></h2>
<p>그런데, 나는 여기서 이상하게 생각했다.</p>
<p>왜냐하면 결국 <code>providers</code> 배열을 통해 의존성 주입 대상을 전부 정의해주게 된다면, 굳이 <code>@Injectable</code> 데코레이터를 등록해야하는가? 라는 의문이 들었기 때문이다.</p>
<blockquote>
<p>Nest 에서는 이 둘이 함께 작동하여 의존성 주입 시스템을 구성한다.</p></blockquote>
<p>AI에게 물어보았더니, 간단한 동작 예시를 알려주었다.</p>
<p>아래 코드는 실제 Nest 구현체가 아니라, Nest의 동작 방식 이해를 위한 예제이다. 직접 만든다면 참고해볼 수 있을 것 같다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">DIContainer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">private</span> <span class="nx">providers</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">register</span><span class="p">(</span><span class="nx">token</span>: <span class="kt">any</span><span class="p">,</span> <span class="nx">provider</span>: <span class="kt">any</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">providers</span><span class="p">.</span><span class="kr">set</span><span class="p">(</span><span class="nx">token</span><span class="p">,</span> <span class="nx">provider</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">resolve</span><span class="p">(</span><span class="nx">target</span>: <span class="kt">any</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">tokens</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getMetadata</span><span class="p">(</span><span class="s1">&#39;design:paramtypes&#39;</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">injections</span> <span class="o">=</span> <span class="nx">tokens</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">token</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">providers</span><span class="p">.</span><span class="kr">get</span><span class="p">(</span><span class="nx">token</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nx">target</span><span class="p">(...</span><span class="nx">injections</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Module</span><span class="p">(</span><span class="nx">metadata</span><span class="o">:</span> <span class="p">{</span> <span class="nx">providers</span>: <span class="kt">any</span><span class="p">[]</span> <span class="p">})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span>: <span class="kt">any</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">const</span> <span class="nx">container</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DIContainer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">metadata</span><span class="p">.</span><span class="nx">providers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">provider</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">container</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="nx">provider</span><span class="p">,</span> <span class="nx">provider</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 이 부분은 실제로는 Nest.js 내부에서 처리됩니다
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">target</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">container</span> <span class="o">=</span> <span class="nx">container</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">@Injectable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">UserService</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">getUsers() {</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;User1&#39;</span><span class="p">,</span> <span class="s1">&#39;User2&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">@Injectable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">UserController</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">constructor</span><span class="p">(</span><span class="kr">private</span> <span class="nx">userService</span>: <span class="kt">UserService</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">getUsers() {</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">userService</span><span class="p">.</span><span class="nx">getUsers</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">@Module</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">  <span class="nx">providers</span><span class="o">:</span> <span class="p">[</span><span class="nx">UserService</span><span class="p">,</span> <span class="nx">UserController</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">AppModule</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 사용 예시 (이 부분은 Nest.js에서 내부적으로 처리됩니다)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">appModule</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppModule</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">userController</span> <span class="o">=</span> <span class="nx">appModule</span><span class="p">.</span><span class="nx">container</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">UserController</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">userController</span><span class="p">.</span><span class="nx">getUsers</span><span class="p">());</span> <span class="c1">// [&#39;User1&#39;, &#39;User2&#39;]
</span></span></span></code></pre></div><ul>
<li>Module 데코레이터를 사용할 때, 각각의 의존성 주입 컨테이너를 사용하는데, 실제 Nest.js 는 전역 의존성 컨테이너를 사용한다.
<ul>
<li>대신, 전역 컨테이너의 일부로 사용된다.</li>
</ul>
</li>
</ul>
<h3 id="injectable-데코레이터가-별도로-필요한-이유">Injectable 데코레이터가 별도로 필요한 이유<a hidden class="anchor" aria-hidden="true" href="#injectable-데코레이터가-별도로-필요한-이유">#</a></h3>
<p>providers 를 통해 export 를 할 수 있고, <code>Injectable</code> 을 통해서 내가 원하는 범위 간 의존성 전달을 해줄 수 있는 장점이 있다.</p>
<p>또한, 이 과정에서 내부적으로는 메타데이터에 클래스를 추가하여 의존성 타입을 정의해줄 수 있다.</p>
<p>마지막으로, 가독성 측면에서 해당 클래스가 주입될 수 있는 클래스임을 인지시켜주는 부분도 있다.</p>
<p>반대로, <code>providers</code> 만으로 의존성 주입이 될 수 없는 이유로 <code>@Injectable</code> 데코레이터를 사용하는 클래스 내에서도 의존성 주입을 사용하기 위한 것도 있다.</p>
<h3 id="reflect를-사용하는-이유">Reflect를 사용하는 이유<a hidden class="anchor" aria-hidden="true" href="#reflect를-사용하는-이유">#</a></h3>
<p>단순히 <code>Map</code> 으로 대체될 수 없는 <code>Reflect</code> 만의 중요한 이점이 있기 때문에 사용된다.</p>
<p>방금 언급한 <strong>메타 데이터에 클래스를 추가할 수 있다</strong>는 것은 <code>Reflect</code> 를 이용하여 타입 정보를 의존성 등록 시 보존할 수 있다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyService</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">constructor</span><span class="p">(</span><span class="kr">private</span> <span class="nx">dependency</span>: <span class="kt">SomeDependency</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 런타임에 타입 정보 접근 가능
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">paramTypes</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getMetadata</span><span class="p">(</span><span class="s1">&#39;design:paramtypes&#39;</span><span class="p">,</span> <span class="nx">MyService</span><span class="p">);</span>
</span></span></code></pre></div><p>위와 같이, 런타임에 타입 정보에 접근이 가능하다.</p>
<p>또한, 생성자 파라미터의 타입 정보, 특정 파라미터에 적용된 커스텀 데코레이터, 클래스 자체에 적용된 데코레이터 정보 모두 런타임에 접근하고 처리할 수 있다고 한다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kd">@Injectable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">ComplexService</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">constructor</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kr">private</span> <span class="nx">service1</span>: <span class="kt">Service1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kd">@Inject</span><span class="p">(</span><span class="s1">&#39;CONFIG&#39;</span><span class="p">)</span> <span class="kr">private</span> <span class="nx">config</span>: <span class="kt">Config</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kd">@Optional</span><span class="p">()</span> <span class="kr">private</span> <span class="nx">optionalService?</span>: <span class="kt">OptionalService</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>정리하자면, Reflect 맵을 이용하면 <strong>타입 정보를 보존하면서 런타임에 (실제 의존성이 주입될 때) 어떤 타입 정보가 들어갈 지 타입스크립트 컴파일러가 알 수 있다.</strong></p>


    </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.blu3fishez.org/tags/nestjs/">Nestjs</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.blu3fishez.org/posts/2024/2024-10-26-%EB%8F%84%EC%BB%A4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/">
    <span class="title">« Prev</span>
    <br>
    <span>도커 네트워크 인터페이스를 알아보자</span>
  </a>
  <a class="next" href="https://blog.blu3fishez.org/posts/2024/2024-10-24-%EC%A7%80%EC%86%8D-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-%ED%95%99%EC%8A%B5-%EC%8A%A4%ED%94%84%EB%A6%B0%ED%8A%B8-%ED%9A%8C%EA%B3%A0/">
    <span class="title">Next »</span>
    <br>
    <span>지속 가능한 개발자란 무엇일까? - 학습 스프린트 회고</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/blu3fishez">blu3fishez</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
