<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Nest.js] Nest.js 에서의 DTO | blog.moozeh</title>
<meta name="keywords" content="Backend, Nestjs">
<meta name="description" content="DTO 란?
이전에 계층 간 데이터 교환을 위한 객체라고 배웠다.
여기에 더 나아가서, DTO란, 네트워크 를 통해 전송되는 방법 또한 정의할 수 있다.
말 그대로 데이터 전송 객체이다.
Nest.js 에서의 DTO
Nest.js 에서는 Class 를 이용하여 정의하는 것을 추천하고 있으며, interface 로도 가능하다.
그 이유는 class 는 interface 와 달리, 런타임 내에 정의 되어 있기 때문에 pipe 등의 기능도 활용 가능하다고 한다.

이는 반대로 얘기하면, 굳이 상태를 보존할 이유가 없다면 인터페이스를 쓰는게 낫다는 뜻으로도 해석할 수 있겠다.">
<meta name="author" content="moozeh">
<link rel="canonical" href="https://blog.moozeh.org/posts/2024/2024-10-23-nestjs-nestjs-%EC%97%90%EC%84%9C%EC%9D%98-dto/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.moozeh.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.moozeh.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.moozeh.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.moozeh.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.moozeh.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.moozeh.org/posts/2024/2024-10-23-nestjs-nestjs-%EC%97%90%EC%84%9C%EC%9D%98-dto/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.moozeh.org/posts/2024/2024-10-23-nestjs-nestjs-%EC%97%90%EC%84%9C%EC%9D%98-dto/">
  <meta property="og:site_name" content="blog.moozeh">
  <meta property="og:title" content="[Nest.js] Nest.js 에서의 DTO">
  <meta property="og:description" content="DTO 란? 이전에 계층 간 데이터 교환을 위한 객체라고 배웠다.
여기에 더 나아가서, DTO란, 네트워크 를 통해 전송되는 방법 또한 정의할 수 있다.
말 그대로 데이터 전송 객체이다.
Nest.js 에서의 DTO Nest.js 에서는 Class 를 이용하여 정의하는 것을 추천하고 있으며, interface 로도 가능하다.
그 이유는 class 는 interface 와 달리, 런타임 내에 정의 되어 있기 때문에 pipe 등의 기능도 활용 가능하다고 한다.
이는 반대로 얘기하면, 굳이 상태를 보존할 이유가 없다면 인터페이스를 쓰는게 낫다는 뜻으로도 해석할 수 있겠다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-10-23T18:46:23+09:00">
    <meta property="article:modified_time" content="2024-10-23T18:46:23+09:00">
    <meta property="article:tag" content="Backend">
    <meta property="article:tag" content="Nestjs">
      <meta property="og:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:title" content="[Nest.js] Nest.js 에서의 DTO">
<meta name="twitter:description" content="DTO 란?
이전에 계층 간 데이터 교환을 위한 객체라고 배웠다.
여기에 더 나아가서, DTO란, 네트워크 를 통해 전송되는 방법 또한 정의할 수 있다.
말 그대로 데이터 전송 객체이다.
Nest.js 에서의 DTO
Nest.js 에서는 Class 를 이용하여 정의하는 것을 추천하고 있으며, interface 로도 가능하다.
그 이유는 class 는 interface 와 달리, 런타임 내에 정의 되어 있기 때문에 pipe 등의 기능도 활용 가능하다고 한다.

이는 반대로 얘기하면, 굳이 상태를 보존할 이유가 없다면 인터페이스를 쓰는게 낫다는 뜻으로도 해석할 수 있겠다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.moozeh.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[Nest.js] Nest.js 에서의 DTO",
      "item": "https://blog.moozeh.org/posts/2024/2024-10-23-nestjs-nestjs-%EC%97%90%EC%84%9C%EC%9D%98-dto/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Nest.js] Nest.js 에서의 DTO",
  "name": "[Nest.js] Nest.js 에서의 DTO",
  "description": "DTO 란? 이전에 계층 간 데이터 교환을 위한 객체라고 배웠다.\n여기에 더 나아가서, DTO란, 네트워크 를 통해 전송되는 방법 또한 정의할 수 있다.\n말 그대로 데이터 전송 객체이다.\nNest.js 에서의 DTO Nest.js 에서는 Class 를 이용하여 정의하는 것을 추천하고 있으며, interface 로도 가능하다.\n그 이유는 class 는 interface 와 달리, 런타임 내에 정의 되어 있기 때문에 pipe 등의 기능도 활용 가능하다고 한다.\n이는 반대로 얘기하면, 굳이 상태를 보존할 이유가 없다면 인터페이스를 쓰는게 낫다는 뜻으로도 해석할 수 있겠다.\n",
  "keywords": [
    "Backend", "Nestjs"
  ],
  "articleBody": "DTO 란? 이전에 계층 간 데이터 교환을 위한 객체라고 배웠다.\n여기에 더 나아가서, DTO란, 네트워크 를 통해 전송되는 방법 또한 정의할 수 있다.\n말 그대로 데이터 전송 객체이다.\nNest.js 에서의 DTO Nest.js 에서는 Class 를 이용하여 정의하는 것을 추천하고 있으며, interface 로도 가능하다.\n그 이유는 class 는 interface 와 달리, 런타임 내에 정의 되어 있기 때문에 pipe 등의 기능도 활용 가능하다고 한다.\n이는 반대로 얘기하면, 굳이 상태를 보존할 이유가 없다면 인터페이스를 쓰는게 낫다는 뜻으로도 해석할 수 있겠다.\nDTO의 역할 DTO의 역할은 크게 두가지 이다.\n데이터의 유효성 체크 타입스크립트에서의 타입으로 활용 프로퍼티 변경의 단순화 여러 계층에서 여러개의 데이터를 보내는 형식이 될 때 이를 하나의 객체로 정의하여 프로퍼티의 변경이 필요할 때, 여러 계층에서 수정해야할 때 되게 귀찮은데, 이 문제를 해결해줄 수 있다.\n내가 이전에 배웠던 점과의 차이 이전에 내가 공부하기를 엔티티와 대응시켜 DB와 분리하는 쪽으로 DTO를 구현했지만,\n실제로 메서드마다 사용하는 DTO를 따로 정의할 수도 있다. 굳이 하나만 만들 필요는 없단 점을 생각 못했다.\n즉, 하나의 모듈(도메인) 내에서 DTO를 꼭 하나로 통일할 필요가 없다.\nDTO 사용하기 예시 DTO 자체도 단순히 모델을 정의하듯이 정의하면 된다.\nexport class CreateBoardDto { title: string; description: string; } 이 DTO를 실제 사용할 때에는 아래와 같이 사용하면 된다.\n@Post() @UsePipes(ValidationPipe) createBoard(@Body() createBoardDto: CreateBoardDto): Board { return this.boardsService.createBoard(createBoardDto); } ",
  "wordCount" : "199",
  "inLanguage": "en",
  "image": "https://blog.moozeh.org/images/papermod-cover.png","datePublished": "2024-10-23T18:46:23+09:00",
  "dateModified": "2024-10-23T18:46:23+09:00",
  "author":{
    "@type": "Person",
    "name": "moozeh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.moozeh.org/posts/2024/2024-10-23-nestjs-nestjs-%EC%97%90%EC%84%9C%EC%9D%98-dto/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.moozeh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.moozeh.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.moozeh.org/" accesskey="h" title="blog.moozeh (Alt + H)">blog.moozeh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.moozeh.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.moozeh.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.moozeh.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      [Nest.js] Nest.js 에서의 DTO
    </h1>
    <div class="post-meta"><span title='2024-10-23 18:46:23 +0900 KST'>October 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;moozeh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#dto-%eb%9e%80" aria-label="DTO 란?">DTO 란?</a><ul>
                        
                <li>
                    <a href="#nestjs-%ec%97%90%ec%84%9c%ec%9d%98-dto" aria-label="Nest.js 에서의 DTO">Nest.js 에서의 DTO</a></li></ul>
                </li>
                <li>
                    <a href="#dto%ec%9d%98-%ec%97%ad%ed%95%a0" aria-label="DTO의 역할">DTO의 역할</a><ul>
                        
                <li>
                    <a href="#%eb%82%b4%ea%b0%80-%ec%9d%b4%ec%a0%84%ec%97%90-%eb%b0%b0%ec%9b%a0%eb%8d%98-%ec%a0%90%ea%b3%bc%ec%9d%98-%ec%b0%a8%ec%9d%b4" aria-label="내가 이전에 배웠던 점과의 차이">내가 이전에 배웠던 점과의 차이</a></li></ul>
                </li>
                <li>
                    <a href="#dto-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0-%ec%98%88%ec%8b%9c" aria-label="DTO 사용하기 예시">DTO 사용하기 예시</a>
                </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><h2 id="dto-란">DTO 란?<a hidden class="anchor" aria-hidden="true" href="#dto-란">#</a></h2>
<p>이전에 계층 간 데이터 교환을 위한 객체라고 배웠다.</p>
<p>여기에 더 나아가서, <code>DTO</code>란, <code>네트워크</code> 를 통해 전송되는 방법 또한 정의할 수 있다.</p>
<p>말 그대로 데이터 전송 객체이다.</p>
<h3 id="nestjs-에서의-dto">Nest.js 에서의 DTO<a hidden class="anchor" aria-hidden="true" href="#nestjs-에서의-dto">#</a></h3>
<p>Nest.js 에서는 <code>Class</code> 를 이용하여 정의하는 것을 추천하고 있으며, <code>interface</code> 로도 가능하다.</p>
<p>그 이유는 <code>class</code> 는 <code>interface</code> 와 달리, 런타임 내에 정의 되어 있기 때문에 <code>pipe</code> 등의 기능도 활용 가능하다고 한다.</p>
<blockquote>
<p>이는 <strong>반대로 얘기하면, 굳이 상태를 보존할 이유가 없다면 인터페이스를 쓰는게 낫다는 뜻으로도 해석할 수 있겠다.</strong></p></blockquote>
<h2 id="dto의-역할">DTO의 역할<a hidden class="anchor" aria-hidden="true" href="#dto의-역할">#</a></h2>
<p>DTO의 역할은 크게 두가지 이다.</p>
<ol>
<li>데이터의 유효성 체크</li>
<li>타입스크립트에서의 타입으로 활용</li>
<li>프로퍼티 변경의 단순화</li>
</ol>
<p>여러 계층에서 여러개의 데이터를 보내는 형식이 될 때 이를 하나의 객체로 정의하여 프로퍼티의 변경이 필요할 때,
여러 계층에서 수정해야할 때 되게 귀찮은데, 이 문제를 해결해줄 수 있다.</p>
<h3 id="내가-이전에-배웠던-점과의-차이">내가 이전에 배웠던 점과의 차이<a hidden class="anchor" aria-hidden="true" href="#내가-이전에-배웠던-점과의-차이">#</a></h3>
<p>이전에 내가 공부하기를 엔티티와 대응시켜 DB와 분리하는 쪽으로 DTO를 구현했지만,</p>
<p>실제로 메서드마다 사용하는 DTO를 따로 정의할 수도 있다. 굳이 하나만 만들 필요는 없단 점을 생각 못했다.</p>
<p>즉, 하나의 모듈(도메인) 내에서 DTO를 꼭 하나로 통일할 필요가 없다.</p>
<h2 id="dto-사용하기-예시">DTO 사용하기 예시<a hidden class="anchor" aria-hidden="true" href="#dto-사용하기-예시">#</a></h2>
<p>DTO 자체도 단순히 모델을 정의하듯이 정의하면 된다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts:create-board.dto.ts" data-lang="ts:create-board.dto.ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">CreateBoardDto</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">title</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">description</span>: <span class="kt">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이 DTO를 실제 사용할 때에는 아래와 같이 사용하면 된다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ts:boards.controller.ts" data-lang="ts:boards.controller.ts"><span class="line"><span class="cl"><span class="kd">@Post</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kd">@UsePipes</span><span class="p">(</span><span class="nx">ValidationPipe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">createBoard</span><span class="p">(</span><span class="kd">@Body</span><span class="p">()</span> <span class="nx">createBoardDto</span>: <span class="kt">CreateBoardDto</span><span class="p">)</span><span class="o">:</span> <span class="nx">Board</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">boardsService</span><span class="p">.</span><span class="nx">createBoard</span><span class="p">(</span><span class="nx">createBoardDto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>

    </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.moozeh.org/tags/backend/">Backend</a></li>
      <li><a href="https://blog.moozeh.org/tags/nestjs/">Nestjs</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.moozeh.org/posts/2024/2024-10-24-%EC%A7%80%EC%86%8D-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C-%ED%95%99%EC%8A%B5-%EC%8A%A4%ED%94%84%EB%A6%B0%ED%8A%B8-%ED%9A%8C%EA%B3%A0/">
    <span class="title">« Prev</span>
    <br>
    <span>지속 가능한 개발자란 무엇일까? - 학습 스프린트 회고</span>
  </a>
  <a class="next" href="https://blog.moozeh.org/posts/2024/2024-10-06-tls-https/">
    <span class="title">Next »</span>
    <br>
    <span>HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝
</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/moozeh">moozeh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
