<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>API의 응답 바디는 커도 좋을까
 | blog.moozeh</title>
<meta name="keywords" content="">
<meta name="description" content="서론 : API 설계 시 든 의문
API 응답과 요청 과정에서의 오버헤드는 얼마나 성능에 영향을 끼칠까요?
예를 들어 여러 카테고리 열에 담긴 카드 정보를 불러오는 API를 작성해야할 때가 있었는데, 저는 전체 데이터를 한번에 가져오는게 아니라, 열의 인덱스 번호를 URL에 담아서 보내고, 해당 열에 대응하는 카드들을 가져오는 API 로 설계를 했었습니다.
이렇게 설계를 했던 이유는 사실 REST 원칙에서 &ldquo;API 계층적으로 구성해야한다&quot;는 원칙에 따라 구성을 하였기 때문입니다. 사실 카드 인덱싱을 하는데 있어서 계층적으로 구성하려면 URL 파라미터를 /columns/cards 이런식으로 불러오도록 만드는게 좋지 않았을까 하는 생각이 듭니다.">
<meta name="author" content="moozeh">
<link rel="canonical" href="https://blog.moozeh.org/posts/2024/2024-09-01-api-response/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.moozeh.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.moozeh.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.moozeh.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.moozeh.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.moozeh.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.moozeh.org/posts/2024/2024-09-01-api-response/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.moozeh.org/posts/2024/2024-09-01-api-response/">
  <meta property="og:site_name" content="blog.moozeh">
  <meta property="og:title" content="API의 응답 바디는 커도 좋을까
">
  <meta property="og:description" content="서론 : API 설계 시 든 의문 API 응답과 요청 과정에서의 오버헤드는 얼마나 성능에 영향을 끼칠까요?
예를 들어 여러 카테고리 열에 담긴 카드 정보를 불러오는 API를 작성해야할 때가 있었는데, 저는 전체 데이터를 한번에 가져오는게 아니라, 열의 인덱스 번호를 URL에 담아서 보내고, 해당 열에 대응하는 카드들을 가져오는 API 로 설계를 했었습니다.
이렇게 설계를 했던 이유는 사실 REST 원칙에서 “API 계층적으로 구성해야한다&#34;는 원칙에 따라 구성을 하였기 때문입니다. 사실 카드 인덱싱을 하는데 있어서 계층적으로 구성하려면 URL 파라미터를 /columns/cards 이런식으로 불러오도록 만드는게 좋지 않았을까 하는 생각이 듭니다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-01T23:30:00+09:00">
    <meta property="article:modified_time" content="2024-09-01T23:30:00+09:00">
      <meta property="og:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.moozeh.org/images/papermod-cover.png">
<meta name="twitter:title" content="API의 응답 바디는 커도 좋을까
">
<meta name="twitter:description" content="서론 : API 설계 시 든 의문
API 응답과 요청 과정에서의 오버헤드는 얼마나 성능에 영향을 끼칠까요?
예를 들어 여러 카테고리 열에 담긴 카드 정보를 불러오는 API를 작성해야할 때가 있었는데, 저는 전체 데이터를 한번에 가져오는게 아니라, 열의 인덱스 번호를 URL에 담아서 보내고, 해당 열에 대응하는 카드들을 가져오는 API 로 설계를 했었습니다.
이렇게 설계를 했던 이유는 사실 REST 원칙에서 &ldquo;API 계층적으로 구성해야한다&quot;는 원칙에 따라 구성을 하였기 때문입니다. 사실 카드 인덱싱을 하는데 있어서 계층적으로 구성하려면 URL 파라미터를 /columns/cards 이런식으로 불러오도록 만드는게 좋지 않았을까 하는 생각이 듭니다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.moozeh.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "API의 응답 바디는 커도 좋을까\n",
      "item": "https://blog.moozeh.org/posts/2024/2024-09-01-api-response/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "API의 응답 바디는 커도 좋을까\n",
  "name": "API의 응답 바디는 커도 좋을까\n",
  "description": "서론 : API 설계 시 든 의문 API 응답과 요청 과정에서의 오버헤드는 얼마나 성능에 영향을 끼칠까요?\n예를 들어 여러 카테고리 열에 담긴 카드 정보를 불러오는 API를 작성해야할 때가 있었는데, 저는 전체 데이터를 한번에 가져오는게 아니라, 열의 인덱스 번호를 URL에 담아서 보내고, 해당 열에 대응하는 카드들을 가져오는 API 로 설계를 했었습니다.\n이렇게 설계를 했던 이유는 사실 REST 원칙에서 \u0026ldquo;API 계층적으로 구성해야한다\u0026quot;는 원칙에 따라 구성을 하였기 때문입니다. 사실 카드 인덱싱을 하는데 있어서 계층적으로 구성하려면 URL 파라미터를 /columns/cards 이런식으로 불러오도록 만드는게 좋지 않았을까 하는 생각이 듭니다.\n",
  "keywords": [
    
  ],
  "articleBody": "서론 : API 설계 시 든 의문 API 응답과 요청 과정에서의 오버헤드는 얼마나 성능에 영향을 끼칠까요?\n예를 들어 여러 카테고리 열에 담긴 카드 정보를 불러오는 API를 작성해야할 때가 있었는데, 저는 전체 데이터를 한번에 가져오는게 아니라, 열의 인덱스 번호를 URL에 담아서 보내고, 해당 열에 대응하는 카드들을 가져오는 API 로 설계를 했었습니다.\n이렇게 설계를 했던 이유는 사실 REST 원칙에서 “API 계층적으로 구성해야한다\"는 원칙에 따라 구성을 하였기 때문입니다. 사실 카드 인덱싱을 하는데 있어서 계층적으로 구성하려면 URL 파라미터를 /columns/cards 이런식으로 불러오도록 만드는게 좋지 않았을까 하는 생각이 듭니다.\nAPI의 응답 바디는 과연 커도 상관이 없을까? 하지만 그때 의문이 들었습니다. API 요청을 받았을 때, 만약에 전체 카드에 대한 정보를 API로 요청을 하였다면, 만약 보내야할 응답의 바디가 커진다고 가정하면, 패킷의 경우 응답 바디가 커지게 되면 애플리케이션 단에서 보내게되는 패킷을 트래픽에 맞게 나누어서 보내야한다고 알고 있는데, 그러면 라우팅의 수가 많아지니 손해가 아닐까라는 것이었습니다.\n요청을 여러번하면, 그만큼 네트워크 상황에 따라 최적화되어 보내지지 않을까라고 순수하게 궁금해했던 것 같습니다. 단순하게 생각해보면 HTTP 요청은 애플리케이션 단 이므로 의미가 없지만, 실제로 나누어 보내는게 오버헤드가 얼마나 큰지도 궁금하기도 했습니다.\n이미지를 불러오기 위한 서버와 이미지 처리 방식 이게 신기한 점이, 실제로 노션과 같은 경우 이미지를 불러오는 방식은 따로 입니다. 비교적 용량이 큰 이미지의 경우 요청을 별도로 된다는 뜻인데, 노션의 경우 일반적으로 문서가 블락단위로 나누어서 각각의 블락을 하나의 객체로 담아서 API로 응답 바디에 담아서 보냅니다.\n실제 노션 API 를 통해서 노션 페이지를 제 개인 깃허브 페이지로 배포해보려고 예전에 잠깐 찾아봤었는데 (물론 완전히 해보진 못했지만..) 노션에서는 페이지를 불러올 때 각 블락단위로 불러오고, 이때 이미지의 경우 이것을 하나의 “파일” 취급합니다. 노션에서는 파일 블록에는 별도의 url 참조만 올려놓습니다.\n노션 파일 링크\n전체 블락을 가져오게 되면 모든 페이지의 내용이 구현되어야하지만, 최근 슬랙에서 다른 동료 캠퍼분께서 이미지만 로딩이 안되는 현상을 보셨을 겁니다. 사실 이러한 현상은 이미지가 별도의 파일로 취급되기 때문에, 블락은 불러와지고, 이미지와 연결된 파일의 url 을 통해 불러오는 것에 실패했기 때문입니다.\n일반적으로 백엔드 기술 중에 많이 알려진 로드 밸런싱 같은 별도의 확장 설계를 한 이유는 하나의 API로 불러오는 응답의 내용이 많아지기 때문에 이렇게 해결한 것이라고 저는 추측합니다.\n그래서 API 응답의 바디가 큰 하나의 API를 사용하는 것이 좋을까, 그게 아니라면, 내가 생각한 것 처럼 여러개의 API를 쓰더라도 응답 바디가 작은게 좋을까 라는 것에 대한 의문이 커지기 시작했습니다. 다른 말로 저런 이미지도 한번에 불러오면 되는 거 아닌가? 라는 것이죠.\n사실 트래픽 상으로만 보면 한번에 담아서 보내는게 이득일 것 입니다. 하지만 “왜?”라는 질문을 생각해보는게 우선이라고 생각했고, 아래와 같이 좀 더 깊게 고민해볼 수 있는 시간이었던 것 같습니다.\n왜? 라는 질문을 생각해보기 “요청 응답 헤더가 포함되어서 오버헤드가 커져서 그래요” 라고 단순히 생각하고 끝낼 수도 있을 것입니다. 하지만 그렇게 단순히 생각할 수가 없을지도 모릅니다.\n첫번째로, 만약 요청 응답 헤더를 무시할만큼 바디가 커지게 되면 패킷을 나누어야 합니다. (근거 : 내 학교 수업 중 “데이터통신, 자세한건 IPv4 패킷 전달 과정 참고”) 그렇게 된다면, 패킷을 나눈 만큼 네트워크 단의 패킷의 헤더는 다시 붙게 되고 오히려 전달해야할 패킷은 더 많아집니다. 즉, 큰 차이가 없게 될 것이란 거죠.\n두번째로, 한번에 보내는 애플리케이션의 요청 혹은 응답이 많아진다면, 패킷 로스로 인한 복구에 드는 시간이 증가할 수도 있다는 점입니다. 그렇게된다면 적은 크기를 주고받는 API를 여러번 호출하는게 이득이 될 수도 있지않을까란 생각입니다.\n사실 두번째에 관한 실험을 제대로 진행해볼 순 없었는데, 혹시 알고있는 분이 있다면 댓글로 정보공유해주시면 감사하겠습니다.\n실제로 스프링부트를 사용하다가 응답 바디가 큰 경우 중간에 패킷로스로 인해서 다시 보내야하는 경우가 있다고 한다.\nData loss when calling a HTTP request with huge response body\n하지만 이런 것도 직접 실험을 해보고 원인을 찾아보는게 의미 있다고 생각합니다. 그래서 주말에 남는 시간에 직접 실험을 해보았고, 배울 점들을 많이 발견할 수 있었던 것 같습니다.\nAPI 네트워크 테스트 진행 우선 위에 언급한 제 의문들에 대한 영향을 최대화 하기 위해 파일의 크기를 다르게 해서 진행했습니다. API 응답 바디에 큰 JSON 파일을 보내주었습니다.\n또한, 라우팅에 대한 최적화가 진행될 수 있다는 가정하에,\n하지만 돈이 없어(…) 서버를 사지 못하므로 나와 서버 간의 루트가 최적화 되어있는지는 별도로 환경을 분리하지 못함을 인식해주길 바라겠습니다.\n데이터 파일 크기 선정 기준 일단, IPv4 데이터 패킷이 65535Byte 이므로, 64KB 가 넘는 JSON 파일이 필요했습니다. 마침 구글링을 해보니까 실제로 크기에 따른 JSON 파일들을 제공해주는 사이트가 있었습니다. 다른분들도 필요하시면 참고하면 좋을 것 같습니다.\n![[image_1231333.png]]\n해당 파일로 진행\n20 MB Dummy JSON File - Sample Json File Free Download\nPostman 실험을 하려고 여러 툴을 찾아보았는데, 어쩌다보니 Postman 에 대해서 사용해보게 되는 경험을 갖게 되었습니다. 주변에 많은 백엔드 개발자 친구들이 애용하는 툴이였는데, 그때까지만 해도 저는 이걸 왜 쓰는가? 그냥 브라우저에서 요청해보면 되지 않을까? 라고 생각했었는데, 프론트엔드를 만들지 않은 상황에서는 이게 엄청 편했었습니다.\n사용방법 Postman 사용방법은 정말 간단합니다.\n![[image 1.png]]\n메인 화면에 요청 방식을 선택하고, 요청 주소를 쓰면 끝입니다.\nparams 는 URL 에 포함해서 보내는 파라미터를 뜻합니다.\n요청 body 는 Body 항목에 이런식으로 입력하면 됩니다.\n![[image 2.png]]\n또 HTTP 뿐만 아니라, 웹소켓, GraphQL 등의 요청도 보낼 수 있는 것 같습니다. 여러모로 유용할 것 같습니다!\n![[image 3.png]]\n실험 과정 솔직히 말해서 로컬 서버를 통해서 요청들을 받아냈고, 다른 영향 요소들을 완벽히 분리하진 못해서 엄밀히 정확한 측정을 하진 못했습니다.\n하지만 그 과정에서 얻어낸 결론과 공부할 점들이 많았습니다.\n10mb 크기의 JSON을 반환하는 요청 2번, 20mb 크기의 JSON을 반환하는 요청 1번을 각각 10번정도씩 실행하였고, 그 결과를 비교해보려고 합니다.\n10mb 요청 → 총 트래픽 9.81mb, 소요시간 110ms ~ 86ms 까지 내려감 Asset not found: image%204.png\n20mb → 총 트래픽 19.44mb, 소요시간 211ms ~ 155ms 까지 내려감 ![[image 5.png]]\nAPI 실험 결과 고려해야할 요소 요청을 많이 받으면 서버가 받을 부하도 생각해야합니다. 정보를 보내는 경우 데이터베이스 쿼리를 자주 수행해야할 것임을 인지해야합니다. 만약 그렇다면, 동시성 요소도 고려해야합니다. 예시 : API 요청을 여러번 보내고 받는 도중, 다른 곳에서 수정이 일어났다면? 알아낸 점 의외로 API 요청과 응답의 헤더의 크기는 상관 없습니다. 헤더의 경우 둘다 합쳐서 500Byte 도 채 되지 않았습니다. 시간에 영향을 주는 요소는 다른 곳에 있었습니다. HTTP는 TCP 로 소통하고 응답을 받습니다. TCP 라서 소켓 연결이 이루어지는 게 아닙니다. 따라서 API 요청은 TCP 소켓을 연결한 후, 작업이 끝나면 다시 연결을 닫는 구조로 이루어집니다. WebSocket 을 통해서 지속적으로 연결할 수 있는 것으로 보입니다. (추측) API가 요청을 보내고 받는 과정 이것을 이해하려면 API 요청을 보내고 받는 과정을 이해해야합니다. HTTP 요청은 TCP 요청인데, TCP 요청은 요청을 보내고, 응답을 받아야합니다. 그 과정에서 TCP 연결을 하게 됩니다. HTTP의 전송 프로토콜은 TCP 입니다.\n그 과정에서 생기는 TCP 의 특징으로 인해 이러한 부분에서 오버헤드가 더 큼을 알 수 있을 것 같습니다.\n[TCP/UDP] TCP와 UDP의 특징과 차이\nTCP 요청 TCP 연결은 IP가 데이터를 어디로 보낼지 처리한다면, TCP는 패킷이 제대로 전달되었는지 확인을 합니다. 일반적으로 연결형 서비스에서 TCP를 자주 사용하게 되는데, 위 링크에 따르면 3-way handshaking을 통해 연결을 설정하고, 4-way handshaking 을 통해서 연결을 해제한다고 합니다.\n![[image 6.png]]\n연결을 수립하는데 세번의 데이터 요청을 주고받기 때문에 3-way handshaking\n아래의 사진은 구글 서버에 직접 GET 요청을 보낸 결과입니다. 구글 서버와 같이 로컬보다 경로가 더 길어진 경우 TCP 핸드셰이킹 과정에서 드는 시간이 더욱 커집니다. 이것이 진짜 API 요청에 영향을 주는 핵심이고, API 요청은 클라이언트의 작업 요청에 따라 분리해야하는 원인입니다.\n![[image 7.png]]\n구글에 GET 요청을 보낸 결과. 확실히 TCP 핸드셰이킹 과정이 엄청 길어졌다.\n추후에 글로 정리하려고 하지만, 일단 3-way handshake 와 4-way handshake에 관한 글을 올려봅니다.\n[네트워크] TCP/UDP와 3 -Way Handshake \u0026 4 -Way Handshake\n결론 저는 결국 API 설계를 할 때에는 어떤 것이든 대상의 요구사항에 따라 구성해야한다고 생각하게 되었습니다. 이게 무슨 뜻이냐면, 클라이언트가 몰라도 되는 일은 굳이 수행하지 않도록 하자는 것이었습니다.\n예를 들어, 서론에서 언급한 미션 예시를 보더라도, 특정 컬럼에 담긴 꼭 해야하지 않는 이상 그냥 한번에 보내는게 맞다고 생각이 들었고, 해당 수정 사항을 다음에 반영해보려고 합니다.\n",
  "wordCount" : "1159",
  "inLanguage": "en",
  "image": "https://blog.moozeh.org/images/papermod-cover.png","datePublished": "2024-09-01T23:30:00+09:00",
  "dateModified": "2024-09-01T23:30:00+09:00",
  "author":{
    "@type": "Person",
    "name": "moozeh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.moozeh.org/posts/2024/2024-09-01-api-response/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.moozeh",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.moozeh.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.moozeh.org/" accesskey="h" title="blog.moozeh (Alt + H)">blog.moozeh</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.moozeh.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.moozeh.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.moozeh.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.moozeh.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      API의 응답 바디는 커도 좋을까

    </h1>
    <div class="post-meta"><span title='2024-09-01 23:30:00 +0900 KST'>September 1, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;moozeh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%ec%84%9c%eb%a1%a0--api-%ec%84%a4%ea%b3%84-%ec%8b%9c-%eb%93%a0-%ec%9d%98%eb%ac%b8" aria-label="서론 : API 설계 시 든 의문">서론 : API 설계 시 든 의문</a><ul>
                        
                <li>
                    <a href="#api%ec%9d%98-%ec%9d%91%eb%8b%b5-%eb%b0%94%eb%94%94%eb%8a%94-%ea%b3%bc%ec%97%b0-%ec%bb%a4%eb%8f%84-%ec%83%81%ea%b4%80%ec%9d%b4-%ec%97%86%ec%9d%84%ea%b9%8c" aria-label="API의 응답 바디는 과연 커도 상관이 없을까?">API의 응답 바디는 과연 커도 상관이 없을까?</a></li>
                <li>
                    <a href="#%ec%9d%b4%eb%af%b8%ec%a7%80%eb%a5%bc-%eb%b6%88%eb%9f%ac%ec%98%a4%ea%b8%b0-%ec%9c%84%ed%95%9c-%ec%84%9c%eb%b2%84%ec%99%80-%ec%9d%b4%eb%af%b8%ec%a7%80-%ec%b2%98%eb%a6%ac-%eb%b0%a9%ec%8b%9d" aria-label="이미지를 불러오기 위한 서버와 이미지 처리 방식">이미지를 불러오기 위한 서버와 이미지 처리 방식</a></li></ul>
                </li>
                <li>
                    <a href="#%ec%99%9c-%eb%9d%bc%eb%8a%94-%ec%a7%88%eb%ac%b8%ec%9d%84-%ec%83%9d%ea%b0%81%ed%95%b4%eb%b3%b4%ea%b8%b0" aria-label="왜? 라는 질문을 생각해보기">왜? 라는 질문을 생각해보기</a></li>
                <li>
                    <a href="#api-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%a7%84%ed%96%89" aria-label="API 네트워크 테스트 진행">API 네트워크 테스트 진행</a><ul>
                        
                <li>
                    <a href="#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ed%8c%8c%ec%9d%bc-%ed%81%ac%ea%b8%b0-%ec%84%a0%ec%a0%95-%ea%b8%b0%ec%a4%80" aria-label="데이터 파일 크기 선정 기준">데이터 파일 크기 선정 기준</a></li></ul>
                </li>
                <li>
                    <a href="#postman" aria-label="Postman">Postman</a><ul>
                        
                <li>
                    <a href="#%ec%82%ac%ec%9a%a9%eb%b0%a9%eb%b2%95" aria-label="사용방법">사용방법</a></li></ul>
                </li>
                <li>
                    <a href="#%ec%8b%a4%ed%97%98-%ea%b3%bc%ec%a0%95" aria-label="실험 과정">실험 과정</a><ul>
                        
                <li>
                    <a href="#api-%ec%8b%a4%ed%97%98-%ea%b2%b0%ea%b3%bc" aria-label="API 실험 결과">API 실험 결과</a></li>
                <li>
                    <a href="#api%ea%b0%80-%ec%9a%94%ec%b2%ad%ec%9d%84-%eb%b3%b4%eb%82%b4%ea%b3%a0-%eb%b0%9b%eb%8a%94-%ea%b3%bc%ec%a0%95" aria-label="API가 요청을 보내고 받는 과정">API가 요청을 보내고 받는 과정</a></li>
                <li>
                    <a href="#tcp-%ec%9a%94%ec%b2%ad" aria-label="TCP 요청">TCP 요청</a></li></ul>
                </li>
                <li>
                    <a href="#%ea%b2%b0%eb%a1%a0" aria-label="결론">결론</a>
                </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><h2 id="서론--api-설계-시-든-의문">서론 : API 설계 시 든 의문<a hidden class="anchor" aria-hidden="true" href="#서론--api-설계-시-든-의문">#</a></h2>
<p>API 응답과 요청 과정에서의 오버헤드는 얼마나 성능에 영향을 끼칠까요?</p>
<p>예를 들어 여러 카테고리 열에 담긴 카드 정보를 불러오는 API를 작성해야할 때가 있었는데, 저는 전체 데이터를 한번에 가져오는게 아니라, 열의 인덱스 번호를 URL에 담아서 보내고, 해당 열에 대응하는 카드들을 가져오는 API 로 설계를 했었습니다.</p>
<p>이렇게 설계를 했던 이유는 사실 REST 원칙에서 &ldquo;API 계층적으로 구성해야한다&quot;는 원칙에 따라 구성을 하였기 때문입니다. 사실 카드 인덱싱을 하는데 있어서 계층적으로 구성하려면 URL 파라미터를 <code>/columns/cards</code> 이런식으로 불러오도록 만드는게 좋지 않았을까 하는 생각이 듭니다.</p>
<h3 id="api의-응답-바디는-과연-커도-상관이-없을까">API의 응답 바디는 과연 커도 상관이 없을까?<a hidden class="anchor" aria-hidden="true" href="#api의-응답-바디는-과연-커도-상관이-없을까">#</a></h3>
<p>하지만 그때 의문이 들었습니다. API 요청을 받았을 때, 만약에 전체 카드에 대한 정보를 API로 요청을 하였다면, 만약 보내야할 응답의 바디가 커진다고 가정하면, 패킷의 경우 응답 바디가 커지게 되면 애플리케이션 단에서 보내게되는 패킷을 트래픽에 맞게 나누어서 보내야한다고 알고 있는데, 그러면 라우팅의 수가 많아지니 손해가 아닐까라는 것이었습니다.</p>
<p>요청을 여러번하면, 그만큼 네트워크 상황에 따라 최적화되어 보내지지 않을까라고 순수하게 궁금해했던 것 같습니다. 단순하게 생각해보면 HTTP 요청은 애플리케이션 단 이므로 의미가 없지만, 실제로 나누어 보내는게 오버헤드가 얼마나 큰지도 궁금하기도 했습니다.</p>
<h3 id="이미지를-불러오기-위한-서버와-이미지-처리-방식">이미지를 불러오기 위한 서버와 이미지 처리 방식<a hidden class="anchor" aria-hidden="true" href="#이미지를-불러오기-위한-서버와-이미지-처리-방식">#</a></h3>
<p>이게 신기한 점이, 실제로 노션과 같은 경우 이미지를 불러오는 방식은 따로 입니다. 비교적 용량이 큰 이미지의 경우 요청을 별도로 된다는 뜻인데, 노션의 경우 일반적으로 문서가 블락단위로 나누어서 각각의 블락을 하나의 객체로 담아서 API로 응답 바디에 담아서 보냅니다.</p>
<p>실제 노션 API 를 통해서 노션 페이지를 제 개인 깃허브 페이지로 배포해보려고 예전에 잠깐 찾아봤었는데 (물론 완전히 해보진 못했지만..) 노션에서는 페이지를 불러올 때 각 블락단위로 불러오고, 이때 이미지의 경우 이것을 하나의 “파일” 취급합니다. 노션에서는 파일 블록에는 별도의 url 참조만 올려놓습니다.</p>
<p><a href="https://developers.notion.com/reference/file-object">노션 파일 링크</a></p>
<p>전체 블락을 가져오게 되면 모든 페이지의 내용이 구현되어야하지만, 최근 슬랙에서 다른 동료 캠퍼분께서 이미지만 로딩이 안되는 현상을 보셨을 겁니다. 사실 이러한 현상은 이미지가 별도의 파일로 취급되기 때문에, 블락은 불러와지고, 이미지와 연결된 파일의 <code>url</code> 을 통해 불러오는 것에 실패했기 때문입니다.</p>
<p>일반적으로 백엔드 기술 중에 많이 알려진 로드 밸런싱 같은 별도의 확장 설계를 한 이유는 하나의 API로 불러오는 응답의 내용이 많아지기 때문에 이렇게 해결한 것이라고 저는 추측합니다.</p>
<p>그래서 API 응답의 바디가 큰 하나의 API를 사용하는 것이 좋을까, 그게 아니라면, 내가 생각한 것 처럼 여러개의 API를 쓰더라도 응답 바디가 작은게 좋을까 라는 것에 대한 의문이 커지기 시작했습니다. 다른 말로 저런 이미지도 한번에 불러오면 되는 거 아닌가? 라는 것이죠.</p>
<p>사실 트래픽 상으로만 보면 한번에 담아서 보내는게 이득일 것 입니다. 하지만 “왜?”라는 질문을 생각해보는게 우선이라고 생각했고, 아래와 같이 좀 더 깊게 고민해볼 수 있는 시간이었던 것 같습니다.</p>
<h2 id="왜-라는-질문을-생각해보기">왜? 라는 질문을 생각해보기<a hidden class="anchor" aria-hidden="true" href="#왜-라는-질문을-생각해보기">#</a></h2>
<p><em>&ldquo;요청 응답 헤더가 포함되어서 오버헤드가 커져서 그래요&rdquo;</em> 라고 단순히 생각하고 끝낼 수도 있을 것입니다. 하지만 그렇게 단순히 생각할 수가 없을지도 모릅니다.</p>
<p>첫번째로, 만약 요청 응답 헤더를 무시할만큼 바디가 커지게 되면 패킷을 나누어야 합니다. (근거 : 내 학교 수업 중 &ldquo;데이터통신, 자세한건 IPv4 패킷 전달 과정 참고&rdquo;) <strong>그렇게 된다면, 패킷을 나눈 만큼 네트워크 단의 패킷의 헤더는 다시 붙게 되고 오히려 전달해야할 패킷은 더 많아집니다. 즉, 큰 차이가 없게 될 것이란 거죠.</strong></p>
<p>두번째로, 한번에 보내는 애플리케이션의 요청 혹은 응답이 많아진다면, 패킷 로스로 인한 복구에 드는 시간이 증가할 수도 있다는 점입니다. 그렇게된다면 적은 크기를 주고받는 API를 여러번 호출하는게 이득이 될 수도 있지않을까란 생각입니다.</p>
<p>사실 두번째에 관한 실험을 제대로 진행해볼 순 없었는데, 혹시 알고있는 분이 있다면 댓글로 정보공유해주시면 감사하겠습니다.</p>
<blockquote>
<p>실제로 스프링부트를 사용하다가 응답 바디가 큰 경우 중간에 패킷로스로 인해서 다시 보내야하는 경우가 있다고 한다.</p>
<p><a href="https://stackoverflow.com/questions/77220948/data-loss-when-calling-a-http-request-with-huge-response-body-in-spring-boot">Data loss when calling a HTTP request with huge response body</a></p></blockquote>
<p>하지만 이런 것도 직접 실험을 해보고 원인을 찾아보는게 의미 있다고 생각합니다. 그래서 주말에 남는 시간에 직접 실험을 해보았고, 배울 점들을 많이 발견할 수 있었던 것 같습니다.</p>
<h2 id="api-네트워크-테스트-진행">API 네트워크 테스트 진행<a hidden class="anchor" aria-hidden="true" href="#api-네트워크-테스트-진행">#</a></h2>
<p>우선 위에 언급한 제 의문들에 대한 영향을 최대화 하기 위해 파일의 크기를 다르게 해서 진행했습니다. API 응답 바디에 큰 <code>JSON</code> 파일을 보내주었습니다.</p>
<p>또한, 라우팅에 대한 최적화가 진행될 수 있다는 가정하에,</p>
<p>하지만 돈이 없어(…) 서버를 사지 못하므로 나와 서버 간의 루트가 최적화 되어있는지는 별도로 환경을 분리하지 못함을 인식해주길 바라겠습니다.</p>
<h3 id="데이터-파일-크기-선정-기준">데이터 파일 크기 선정 기준<a hidden class="anchor" aria-hidden="true" href="#데이터-파일-크기-선정-기준">#</a></h3>
<p>일단, IPv4 데이터 패킷이 <code>65535Byte</code> 이므로, 64KB 가 넘는 JSON 파일이 필요했습니다. 마침 구글링을 해보니까 실제로 크기에 따른 JSON 파일들을 제공해주는 사이트가 있었습니다. 다른분들도 필요하시면 참고하면 좋을 것 같습니다.</p>
<img src="/assets/images/image_1231333.png" alt="image_1231333" loading="lazy">
<p>해당 파일로 진행</p>
<p><a href="https://examplefile.com/code/json/20-mb-json">20 MB Dummy JSON File - Sample Json File Free Download</a></p>
<h2 id="postman">Postman<a hidden class="anchor" aria-hidden="true" href="#postman">#</a></h2>
<p>실험을 하려고 여러 툴을 찾아보았는데, 어쩌다보니 Postman 에 대해서 사용해보게 되는 경험을 갖게 되었습니다. 주변에 많은 백엔드 개발자 친구들이 애용하는 툴이였는데, 그때까지만 해도 저는 이걸 왜 쓰는가? 그냥 브라우저에서 요청해보면 되지 않을까? 라고 생각했었는데, 프론트엔드를 만들지 않은 상황에서는 이게 엄청 편했었습니다.</p>
<h3 id="사용방법">사용방법<a hidden class="anchor" aria-hidden="true" href="#사용방법">#</a></h3>
<p>Postman 사용방법은 정말 간단합니다.</p>
<img src="/assets/images/image%201.png" alt="image 1" loading="lazy">
<p>메인 화면에 요청 방식을 선택하고, 요청 주소를 쓰면 끝입니다.</p>
<p><code>params</code> 는 <code>URL</code> 에 포함해서 보내는 파라미터를 뜻합니다.</p>
<p>요청 body 는 Body 항목에 이런식으로 입력하면 됩니다.</p>
<img src="/assets/images/image%202.png" alt="image 2" loading="lazy">
<p>또 HTTP 뿐만 아니라, 웹소켓, GraphQL 등의 요청도 보낼 수 있는 것 같습니다. 여러모로 유용할 것 같습니다!</p>
<img src="/assets/images/image%203.png" alt="image 3" loading="lazy">
<h2 id="실험-과정">실험 과정<a hidden class="anchor" aria-hidden="true" href="#실험-과정">#</a></h2>
<p>솔직히 말해서 로컬 서버를 통해서 요청들을 받아냈고, 다른 영향 요소들을 완벽히 분리하진 못해서 엄밀히 정확한 측정을 하진 못했습니다.</p>
<p>하지만 그 과정에서 얻어낸 결론과 공부할 점들이 많았습니다.</p>
<p>10mb 크기의 JSON을 반환하는 요청 2번, 20mb 크기의 JSON을 반환하는 요청 1번을 각각 10번정도씩 실행하였고, 그 결과를 비교해보려고 합니다.</p>
<ul>
<li><code>10mb</code> 요청 → 총 트래픽 <code>9.81mb</code>, 소요시간 <code>110ms ~ 86ms</code> 까지 내려감</li>
</ul>
<p><p style="color: red;">Asset not found: image%204.png</p></p>
<ul>
<li><code>20mb</code> → 총 트래픽 <code>19.44mb</code>, 소요시간 <code>211ms ~ 155ms</code> 까지 내려감</li>
</ul>
<img src="/assets/images/image%205.png" alt="image 5" loading="lazy">
<h3 id="api-실험-결과">API 실험 결과<a hidden class="anchor" aria-hidden="true" href="#api-실험-결과">#</a></h3>
<ul>
<li>고려해야할 요소
<ul>
<li>요청을 많이 받으면 서버가 받을 부하도 생각해야합니다.</li>
<li>정보를 보내는 경우 데이터베이스 쿼리를 자주 수행해야할 것임을 인지해야합니다.</li>
<li>만약 그렇다면, 동시성 요소도 고려해야합니다.
<ul>
<li>예시 : <code>API 요청을 여러번 보내고 받는 도중, 다른 곳에서 수정이 일어났다면?</code></li>
</ul>
</li>
</ul>
</li>
<li>알아낸 점
<ul>
<li>의외로 API 요청과 응답의 헤더의 크기는 상관 없습니다.
<ul>
<li>헤더의 경우 둘다 합쳐서 <code>500Byte</code> 도 채 되지 않았습니다.</li>
</ul>
</li>
<li>시간에 영향을 주는 요소는 다른 곳에 있었습니다.
<ul>
<li>HTTP는 <code>TCP</code> 로 소통하고 응답을 받습니다.
<ul>
<li><code>TCP</code> 라서 소켓 연결이 이루어지는 게 아닙니다.</li>
<li>따라서 API 요청은 TCP 소켓을 연결한 후, 작업이 끝나면 다시 연결을 닫는 구조로 이루어집니다.</li>
<li><code>WebSocket</code> 을 통해서 지속적으로 연결할 수 있는 것으로 보입니다. (추측)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="api가-요청을-보내고-받는-과정">API가 요청을 보내고 받는 과정<a hidden class="anchor" aria-hidden="true" href="#api가-요청을-보내고-받는-과정">#</a></h3>
<p>이것을 이해하려면 API 요청을 보내고 받는 과정을 이해해야합니다. HTTP 요청은 <code>TCP</code> 요청인데, TCP 요청은 요청을 보내고, 응답을 받아야합니다. 그 과정에서 TCP 연결을 하게 됩니다. <code>HTTP의 전송 프로토콜은 TCP</code> 입니다.</p>
<p>그 과정에서 생기는 TCP 의 특징으로 인해 이러한 부분에서 오버헤드가 더 큼을 알 수 있을 것 같습니다.</p>
<p><a href="https://mangkyu.tistory.com/15">[TCP/UDP] TCP와 UDP의 특징과 차이</a></p>
<h3 id="tcp-요청">TCP 요청<a hidden class="anchor" aria-hidden="true" href="#tcp-요청">#</a></h3>
<p>TCP 연결은 IP가 데이터를 어디로 보낼지 처리한다면, TCP는 패킷이 제대로 전달되었는지 확인을 합니다. 일반적으로 연결형 서비스에서 TCP를 자주 사용하게 되는데, 위 링크에 따르면 3-way handshaking을 통해 연결을 설정하고, 4-way handshaking 을 통해서 연결을 해제한다고 합니다.</p>
<img src="/assets/images/image%206.png" alt="image 6" loading="lazy">
<p>연결을 수립하는데 세번의 데이터 요청을 주고받기 때문에 3-way handshaking</p>
<p>아래의 사진은 구글 서버에 직접 GET 요청을 보낸 결과입니다. 구글 서버와 같이 로컬보다 경로가 더 길어진 경우 TCP 핸드셰이킹 과정에서 드는 시간이 더욱 커집니다. 이것이 진짜 API 요청에 영향을 주는 핵심이고, API 요청은 클라이언트의 작업 요청에 따라 분리해야하는 원인입니다.</p>
<img src="/assets/images/image%207.png" alt="image 7" loading="lazy">
<p>구글에 GET 요청을 보낸 결과. 확실히 TCP 핸드셰이킹 과정이 엄청 길어졌다.</p>
<p>추후에 글로 정리하려고 하지만, 일단 3-way handshake 와 4-way handshake에 관한 글을 올려봅니다.</p>
<p><a href="https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3-Way-Handshake4-Way-Handshake">[네트워크] TCP/UDP와 3 -Way Handshake &amp; 4 -Way Handshake</a></p>
<h2 id="결론">결론<a hidden class="anchor" aria-hidden="true" href="#결론">#</a></h2>
<p>저는 결국 API 설계를 할 때에는 <strong>어떤 것이든 대상의 요구사항에 따라 구성해야한다고 생각하게 되었습니다.</strong> 이게 무슨 뜻이냐면, 클라이언트가 몰라도 되는 일은 굳이 수행하지 않도록 하자는 것이었습니다.</p>
<p>예를 들어, 서론에서 언급한 미션 예시를 보더라도, 특정 컬럼에 담긴 꼭 해야하지 않는 이상 그냥 한번에 보내는게 맞다고 생각이 들었고, 해당 수정 사항을 다음에 반영해보려고 합니다.</p>


    </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.moozeh.org/posts/2024/2024-10-06-tls-https/">
    <span class="title">« Prev</span>
    <br>
    <span>HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝
</span>
  </a>
  <a class="next" href="https://blog.moozeh.org/posts/2024/2024-08-03-boostcamp-3/">
    <span class="title">Next »</span>
    <br>
    <span>[부스트캠프 챌린지] 3주차 후기 및 회고
</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/moozeh">moozeh</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
