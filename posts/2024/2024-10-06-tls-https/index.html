<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝
 | blog.blu3fishez</title>
<meta name="keywords" content="network">
<meta name="description" content="🧵 HTTP, 그 다음은?
HTTP 프로토콜을 직접 만들어보면서, 생각보다 간단한 방식으로 소통한다고 깨달았습니다.
무언가 특수한 포맷팅을 이용해서..? 바이너리로 인코딩하여 전송할 줄 알았는데 문자였던 것이지요..
그래서 이렇게 간단하게 문자열로 소통하니, 보안에 정말로 취약할 수 밖에 없음을 또 인지할 수 밖에 없었습니다. 역시 무언가를 사용할 때에는 보안을 의식할 수 밖에 없습니다.
그래서 우리가 흔하게 사용하지만, 당연하다고 여기는 HTTPS 에 대해 더 공부를 하게 되었습니다.
HTTPS 프로토콜
그럼 HTTPS란 뭘까요?
HTTP &#43; S(ecure) 즉, 보안 계층을 더한 HTTP 라고 생각하면 됩니다. 우리가 C언어에서 MSVC 에서 사용할 수 있는 scanf_s 와 같은 s 처럼 보안을 의식하여 보안 계층을 한층 더 감싼 HTTP 통신이라고 생각하면 됩니다.">
<meta name="author" content="blu3fishez">
<link rel="canonical" href="https://blog.blu3fishez.org/posts/2024/2024-10-06-tls-https/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.580d5c4b37c6350e62c76a9e39ccff4785bf5e515b18b3cb0605dea4cc5f5376.css" integrity="sha256-WA1cSzfGNQ5ix2qeOcz/R4W/XlFbGLPLBgXepMxfU3Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://blog.blu3fishez.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://blog.blu3fishez.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://blog.blu3fishez.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://blog.blu3fishez.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://blog.blu3fishez.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://blog.blu3fishez.org/posts/2024/2024-10-06-tls-https/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://blog.blu3fishez.org/posts/2024/2024-10-06-tls-https/">
  <meta property="og:site_name" content="blog.blu3fishez">
  <meta property="og:title" content="HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝
">
  <meta property="og:description" content="🧵 HTTP, 그 다음은? HTTP 프로토콜을 직접 만들어보면서, 생각보다 간단한 방식으로 소통한다고 깨달았습니다.
무언가 특수한 포맷팅을 이용해서..? 바이너리로 인코딩하여 전송할 줄 알았는데 문자였던 것이지요..
그래서 이렇게 간단하게 문자열로 소통하니, 보안에 정말로 취약할 수 밖에 없음을 또 인지할 수 밖에 없었습니다. 역시 무언가를 사용할 때에는 보안을 의식할 수 밖에 없습니다.
그래서 우리가 흔하게 사용하지만, 당연하다고 여기는 HTTPS 에 대해 더 공부를 하게 되었습니다.
HTTPS 프로토콜 그럼 HTTPS란 뭘까요?
HTTP &#43; S(ecure) 즉, 보안 계층을 더한 HTTP 라고 생각하면 됩니다. 우리가 C언어에서 MSVC 에서 사용할 수 있는 scanf_s 와 같은 s 처럼 보안을 의식하여 보안 계층을 한층 더 감싼 HTTP 통신이라고 생각하면 됩니다.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-10-06T21:57:00+09:00">
    <meta property="article:modified_time" content="2024-10-06T21:57:00+09:00">
    <meta property="article:tag" content="Network">
      <meta property="og:image" content="https://blog.blu3fishez.org/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://blog.blu3fishez.org/images/papermod-cover.png">
<meta name="twitter:title" content="HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝
">
<meta name="twitter:description" content="🧵 HTTP, 그 다음은?
HTTP 프로토콜을 직접 만들어보면서, 생각보다 간단한 방식으로 소통한다고 깨달았습니다.
무언가 특수한 포맷팅을 이용해서..? 바이너리로 인코딩하여 전송할 줄 알았는데 문자였던 것이지요..
그래서 이렇게 간단하게 문자열로 소통하니, 보안에 정말로 취약할 수 밖에 없음을 또 인지할 수 밖에 없었습니다. 역시 무언가를 사용할 때에는 보안을 의식할 수 밖에 없습니다.
그래서 우리가 흔하게 사용하지만, 당연하다고 여기는 HTTPS 에 대해 더 공부를 하게 되었습니다.
HTTPS 프로토콜
그럼 HTTPS란 뭘까요?
HTTP &#43; S(ecure) 즉, 보안 계층을 더한 HTTP 라고 생각하면 됩니다. 우리가 C언어에서 MSVC 에서 사용할 수 있는 scanf_s 와 같은 s 처럼 보안을 의식하여 보안 계층을 한층 더 감싼 HTTP 통신이라고 생각하면 됩니다.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://blog.blu3fishez.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝\n",
      "item": "https://blog.blu3fishez.org/posts/2024/2024-10-06-tls-https/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝\n",
  "name": "HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝\n",
  "description": "🧵 HTTP, 그 다음은? HTTP 프로토콜을 직접 만들어보면서, 생각보다 간단한 방식으로 소통한다고 깨달았습니다.\n무언가 특수한 포맷팅을 이용해서..? 바이너리로 인코딩하여 전송할 줄 알았는데 문자였던 것이지요..\n그래서 이렇게 간단하게 문자열로 소통하니, 보안에 정말로 취약할 수 밖에 없음을 또 인지할 수 밖에 없었습니다. 역시 무언가를 사용할 때에는 보안을 의식할 수 밖에 없습니다.\n그래서 우리가 흔하게 사용하지만, 당연하다고 여기는 HTTPS 에 대해 더 공부를 하게 되었습니다.\nHTTPS 프로토콜 그럼 HTTPS란 뭘까요?\nHTTP + S(ecure) 즉, 보안 계층을 더한 HTTP 라고 생각하면 됩니다. 우리가 C언어에서 MSVC 에서 사용할 수 있는 scanf_s 와 같은 s 처럼 보안을 의식하여 보안 계층을 한층 더 감싼 HTTP 통신이라고 생각하면 됩니다.\n",
  "keywords": [
    "network"
  ],
  "articleBody": "🧵 HTTP, 그 다음은? HTTP 프로토콜을 직접 만들어보면서, 생각보다 간단한 방식으로 소통한다고 깨달았습니다.\n무언가 특수한 포맷팅을 이용해서..? 바이너리로 인코딩하여 전송할 줄 알았는데 문자였던 것이지요..\n그래서 이렇게 간단하게 문자열로 소통하니, 보안에 정말로 취약할 수 밖에 없음을 또 인지할 수 밖에 없었습니다. 역시 무언가를 사용할 때에는 보안을 의식할 수 밖에 없습니다.\n그래서 우리가 흔하게 사용하지만, 당연하다고 여기는 HTTPS 에 대해 더 공부를 하게 되었습니다.\nHTTPS 프로토콜 그럼 HTTPS란 뭘까요?\nHTTP + S(ecure) 즉, 보안 계층을 더한 HTTP 라고 생각하면 됩니다. 우리가 C언어에서 MSVC 에서 사용할 수 있는 scanf_s 와 같은 s 처럼 보안을 의식하여 보안 계층을 한층 더 감싼 HTTP 통신이라고 생각하면 됩니다.\n이때, 이 인증은 정확히 어떤 인증을 뜻할까요? 이 인증은 SSL, 이제는 TLS라고 불리는 프로토콜을 사용하여 암호화하여 통신합니다.\nHTTPS 통신 과정 간단합니다! 사전에 약속된 대칭키를 통해서 소통하는 형태입니다.\n하지만 그 앞과정이 살짝 복잡한데요, 그래서 기존 HTTP보다 오버헤드가 크다는 단점이 있습니다.\n하지만 보안이라는 장점앞에 그깟 오버헤드쯤이야… 싶습니다 ㅎㅎ\n클라이언트가 서버에 연결 요청 서버가 SSL/TLS 인증서를 클라이언트에게 보내줌 클라이언트가 인증서를 검증함 (인증기관, CA 로부터) TLS 핸드 셰이크를 통해 안전한 연결 설정 암호화된 데이터 통신 시작 ![[2024-10-06-tls-https-image.png]]\n출처 : https://brunch.co.kr/@growthminder/79\n🗒️ TLS 란? 사전적 정의는 다음과 같습니다.\n🔥 Transport Layer Security\nSSL 이라고도 불리며, 인터넷에서 안전하게 서로 통신할 수 있도록 하는 프로토콜을 뜻합니다.\n그래서 이는 비단 인터넷 사용 뿐만 아니라, 인터넷 연결 그 자체에도 적용되기도 합니다.\n예를 들어, 우리가 와이파이를 연결할 때에도 대학교의 경우, 특정 인증서를 통해 (PEM 키 등) 연결하기도 합니다.\n이러한 TLS를 사용하여 좋은 점은 무엇일까요? 크게 세가지 입니다.\nTLS의 장점 데이터의 기밀성(보안) 유지 가능 데이터의 무결성 보장 (변조 방지) 인증 제공 가능 (서버 인증서를 통해 우리 서버가 검증된 서버임을 알려줄 수 있음) 🔒 TLS 가 완전히 안전할까요? 일반적으로 안전합니다! 사실 그렇게 깊게까지 생각할 필욘 없지만, 왜 이렇게 안전한지 한번 TLS 과정을 통해 같이 생각해봅시다.\nTLS 통신(핸드 셰이크) 과정 Client Hello 클라이언트가 서버에 지원 가능한 암호 스위트 목록, SSL/TLS 버전을 전송해줍니다. Server Hello 서버가 선택한 암호 스위트와 SSL/TLS 버전을 클라이언트에 응답합니다. Certificate : 서버가 자신의 SSL 인증서를 클라이언트에 전송해줍니다. Server Key Exchange : 서버가 키 교환에 필요한 추가 정보를 전송합니다. Server Hello Done : 서버가 초기 메세지 전송을 완료했음을 알립니다. Client Key Exchange : 클라이언트가 대칭키 (세션 키) 생성에 필요한 정보를 암호화하여 서버에 전송합니다. Change Cipher Spec : 양측이 협상된 암호 스위트를 사용할 준비가 되었음을 알립니다. Finished : 핸드 셰이크를 완료하고, 암호화 통신을 시작합니다. 그 이후부터는 단순히 HTTP 메세지를 서로 인증된 암호화 정보를 통해 암호화하여 통신하는게 끝입니다! 간단하죠. 간단하지만 정말 강력하다고 생각합니다.\n하지만 몇가지 궁금점들이 있을 수 있는데, 저의 경우 이러한 궁금점들이 생겨서 더 자세하게 공부하게 되었습니다.\n아무것도 없는 클라이언트가 무엇으로부터 암호화를 할 수 있을까? 일단, 첫번째로 서버에 지원 가능한 암호 스위트 목록을 전송합니다.\n그리고 인증서에는 공개키가 포함되어있습니다! 이게 정말 중요한 정보입니다. 인증서가 없어서 HTTPS 연결을 사용할 수 없는 이유가 이것입니다.\n이 인증서는 서버의 공개키를 포함하고 있고, 이것을 CA가 보증해주는 구조입니다.\n그리고, 실제 데이터 암호화에는 이 공개키가 사용되지 않습니다. 인증서를 검증하는데에 사용되기 때문입니다.\n대칭키(세션키) 가 무엇인가요? 세션키란, 세션마다 동적으로 생성되어 해당 세션 동안 유효한 키 입니다.\n암호화와 복호화에 동일한 키를 사용하는 암호화 방식에서 사용되는 키를 뜻합니다.\n따라서 우리가 생각하는 비밀키 공개키 등등.. 과는 관련없는 키입니다.\n오히려 비밀키와 공개키를 사용하여 해당 세션키를 전달하고 받는데에 사용됩니다.\n하지만,, 클라이언트가 공개키로 암호화한 데이터를 어떻게 알게 될까요..?\n그러면, 대칭키를 어떻게 클라이언트가 알게 되나요? 그래서, 프리마스터 시크릿 이라는 임의의 값을 별도로 생성하여 클라이언트가 세션키를 안전하게 받는데 사용할 수 있습니다.\n클라이언트가 먼저 생성한 프리마스터 시크릿 이라는 임의의 값을 서버에게 먼저 전달합니다. 서버는 이 프리마스터 시크릿 이라는 값을 받아서 알게 되는 거죠.\n결국, 세션 통신에 관한 키 생성은 클라이언트 가 하게 됩니다. 이 프리마스터 시크릿 이란 걸 가지고 각자 동일한 세션키를 생성하는 것이죠.\nTLS 중간자 공격 하지만 TLS 핸드셰이크 과정 자체에서 중간자 공격(MITM)이 일어날 수도 있는 것도 사실입니다.\n인증서 조작 공격자가 신뢰할 수 있는 인증서를 획득하거나 사용자의 시스템에 악의적인 루트 인증서를 설치할 경우, 중간자 공격(MITM) 공격이 가능할 수 있습니다\n프로토콜 다운그레이드 공격자가 클라이언트와 서버 간의 통신을 방해하여 더 취약한 이전 버전의 TLS를 사용하도록 강제할 수 있습니다.\n🧑‍⚕️ 중간자 공격을 완전히 방지하기 위한 방법 신뢰할 수 있는 CA (인증기관) 사용, 최신 TLS 버전 사용 Certificate authority\n신뢰할 수 있는 인증기관을 서버 도메인 / 인증서 내용을 비교하여 확인할 수 있다면, 우리는 인증하는 것 자체에는 큰 문제가 없는 이유가 이것입니다.\n우리가 자주 사용하는 Let's Encrypt 가 대표적인 인증기관입니다.\n하지만, 돈이 없거나, 이러한 인증 기관도 믿지 못하는 상황이 있을 수 있겠죠? 이러한 점에 대한 우려는 타당하다고 생각이 되고, 제 주변 지인과의 대화에서도 나온 주제이기도 합니다.\n진짜 그럼 매번 인증기관에 접속하나요..? 아뇨! 그건 또 아닙니다.\n대신 다음과 같은 방식으로 CA의 신뢰성을 확인할 수 있습니다.\n사전에 설치된 CA 인증서 애초부터 운영체제와 웹브라우저에서 신뢰할 수 있는 CA의 루트 인증서 목록이 미리 설치되어있습니다. 서버 인증서 검증 TLS 핸드 셰이크 중에는 자신의 인증서를 클라이언트에게 전송합니다. (원래 전송해옴) 로컬 검증 자신이 받은 서버 인증서와 자신이 가지고 있는 신뢰할 수 있는 CA 목록과 대조합니다. 인증서 체인 검증 필요할 경우, 루트 CA까지 검증을 수행할 수 있습니다. 이렇게 실시간 CA 접속 없음이 보장됩니다.\n이미 신뢰할 수 있는 CA 목록을 가지고 있기 때문에, 일반적으로 안전하다고 할 수 있는 겁니다.\n또한 최신 TLS 버전을 사용하는 것도 좋은 방법이 될 수 있습니다. 하지만 여기서 끝내면 섭섭하니 이러한 방법 외의 여러 방안 중 하나를 알아보고자 합니다.\n인증서 피닝 (공개키 피닝) 그 방법은 말 그대로 공개키 자체를 고정하는 방법입니다.\n서버와 클라이언트 간 공개키를 서로 가지고 있다면, CA 시스템을 변조됐더라도, 탈취할 수 없게 됩니다. (이미 서버에 대한 인증서정보(공개키)를 클라이언트가 가진 상태로 통신을 시작할 수 있습니다.)\n추가 : 인증 기관은 정확히 어떻게 등록되고 관리될까요? 인증기관이 신뢰할 수 있게 되는 과정에 대한 질문이 있었습니다.\n저도 그부분에 관련해서 미흡하게 알고 있었고 따로 공부하게 되었습니다.\n우선, 공개적인 인증기관이 되려면, 엄격한 검사과정을 거쳐야한다고 합니다. 우선, Let’s Encrypt 를 예시로 들면, 해당 기관은 비영리 인증 기관입니다. 이러한 인증기관은 WebTrust, ETSI 등의 엄격한 기준이 있다고 하는데, 이러한 조건을 충족해야한다고 합니다.\n해당 과정에서는 보안 정책, 키 관리, 인증서 발급 절차 등을 검사한다고 보시면 되겠습니다.\n그 후, 주요 브라우저와 운영체제 제조업체(마이크로소프트, 애플, 모질라) 등에서 운영하는 루트 인증서 프로그램이 따로 있습니다.\n이러한 루트 프로그램에 참여하여, 브라우저와 운영체제에 직접 인증기관의 서명을 발급해줄 수 있습니다.\n그 외에도 법적인 계약을 체결하거나, 지속적인 외부 감사를 받는 등 신뢰받을 수 있는 인증기관으로 거듭나려면 조건이 많이 필요합니다.\n",
  "wordCount" : "973",
  "inLanguage": "en",
  "image": "https://blog.blu3fishez.org/images/papermod-cover.png","datePublished": "2024-10-06T21:57:00+09:00",
  "dateModified": "2024-10-06T21:57:00+09:00",
  "author":{
    "@type": "Person",
    "name": "blu3fishez"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://blog.blu3fishez.org/posts/2024/2024-10-06-tls-https/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog.blu3fishez",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blog.blu3fishez.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://blog.blu3fishez.org/" accesskey="h" title="blog.blu3fishez (Alt + H)">blog.blu3fishez</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://blog.blu3fishez.org/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://blog.blu3fishez.org/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://blog.blu3fishez.org/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://blog.blu3fishez.org/">Home</a>&nbsp;»&nbsp;<a href="https://blog.blu3fishez.org/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      HTTPS, TLS의 의미와 관련 보안 취약점과 인증서 피닝

    </h1>
    <div class="post-meta"><span title='2024-10-06 21:57:00 +0900 KST'>October 6, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;blu3fishez

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#http-%ea%b7%b8-%eb%8b%a4%ec%9d%8c%ec%9d%80" aria-label="🧵 HTTP, 그 다음은?">🧵 HTTP, 그 다음은?</a><ul>
                        
                <li>
                    <a href="#https-%ed%94%84%eb%a1%9c%ed%86%a0%ec%bd%9c" aria-label="HTTPS 프로토콜">HTTPS 프로토콜</a></li>
                <li>
                    <a href="#https-%ed%86%b5%ec%8b%a0-%ea%b3%bc%ec%a0%95" aria-label="HTTPS 통신 과정">HTTPS 통신 과정</a></li></ul>
                </li>
                <li>
                    <a href="#tls-%eb%9e%80" aria-label="🗒️ TLS 란?">🗒️ TLS 란?</a><ul>
                        
                <li>
                    <a href="#tls%ec%9d%98-%ec%9e%a5%ec%a0%90" aria-label="TLS의 장점">TLS의 장점</a></li></ul>
                </li>
                <li>
                    <a href="#tls-%ea%b0%80-%ec%99%84%ec%a0%84%ed%9e%88-%ec%95%88%ec%a0%84%ed%95%a0%ea%b9%8c%ec%9a%94" aria-label="🔒 TLS 가 완전히 안전할까요?">🔒 TLS 가 완전히 안전할까요?</a><ul>
                        
                <li>
                    <a href="#tls-%ed%86%b5%ec%8b%a0%ed%95%b8%eb%93%9c-%ec%85%b0%ec%9d%b4%ed%81%ac-%ea%b3%bc%ec%a0%95" aria-label="TLS 통신(핸드 셰이크) 과정">TLS 통신(핸드 셰이크) 과정</a><ul>
                        
                <li>
                    <a href="#%ec%95%84%eb%ac%b4%ea%b2%83%eb%8f%84-%ec%97%86%eb%8a%94-%ed%81%b4%eb%9d%bc%ec%9d%b4%ec%96%b8%ed%8a%b8%ea%b0%80-%eb%ac%b4%ec%97%87%ec%9c%bc%eb%a1%9c%eb%b6%80%ed%84%b0-%ec%95%94%ed%98%b8%ed%99%94%eb%a5%bc-%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" aria-label="아무것도 없는 클라이언트가 무엇으로부터 암호화를 할 수 있을까?">아무것도 없는 클라이언트가 무엇으로부터 암호화를 할 수 있을까?</a></li>
                <li>
                    <a href="#%eb%8c%80%ec%b9%ad%ed%82%a4%ec%84%b8%ec%85%98%ed%82%a4-%ea%b0%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80%ec%9a%94" aria-label="대칭키(세션키) 가 무엇인가요?">대칭키(세션키) 가 무엇인가요?</a></li>
                <li>
                    <a href="#%ea%b7%b8%eb%9f%ac%eb%a9%b4-%eb%8c%80%ec%b9%ad%ed%82%a4%eb%a5%bc-%ec%96%b4%eb%96%bb%ea%b2%8c-%ed%81%b4%eb%9d%bc%ec%9d%b4%ec%96%b8%ed%8a%b8%ea%b0%80-%ec%95%8c%ea%b2%8c-%eb%90%98%eb%82%98%ec%9a%94" aria-label="그러면, 대칭키를 어떻게 클라이언트가 알게 되나요?">그러면, 대칭키를 어떻게 클라이언트가 알게 되나요?</a></li></ul>
                </li>
                <li>
                    <a href="#tls-%ec%a4%91%ea%b0%84%ec%9e%90-%ea%b3%b5%ea%b2%a9" aria-label="TLS 중간자 공격">TLS 중간자 공격</a></li></ul>
                </li>
                <li>
                    <a href="#-%ec%a4%91%ea%b0%84%ec%9e%90-%ea%b3%b5%ea%b2%a9%ec%9d%84-%ec%99%84%ec%a0%84%ed%9e%88-%eb%b0%a9%ec%a7%80%ed%95%98%ea%b8%b0-%ec%9c%84%ed%95%9c-%eb%b0%a9%eb%b2%95" aria-label="🧑‍⚕️ 중간자 공격을 완전히 방지하기 위한 방법">🧑‍⚕️ 중간자 공격을 완전히 방지하기 위한 방법</a><ul>
                        
                <li>
                    <a href="#%ec%8b%a0%eb%a2%b0%ed%95%a0-%ec%88%98-%ec%9e%88%eb%8a%94-ca-%ec%9d%b8%ec%a6%9d%ea%b8%b0%ea%b4%80-%ec%82%ac%ec%9a%a9-%ec%b5%9c%ec%8b%a0-tls-%eb%b2%84%ec%a0%84-%ec%82%ac%ec%9a%a9" aria-label="신뢰할 수 있는 CA (인증기관) 사용, 최신 TLS 버전 사용">신뢰할 수 있는 CA (인증기관) 사용, 최신 TLS 버전 사용</a><ul>
                        
                <li>
                    <a href="#%ec%a7%84%ec%a7%9c-%ea%b7%b8%eb%9f%bc-%eb%a7%a4%eb%b2%88-%ec%9d%b8%ec%a6%9d%ea%b8%b0%ea%b4%80%ec%97%90-%ec%a0%91%ec%86%8d%ed%95%98%eb%82%98%ec%9a%94" aria-label="진짜 그럼 매번 인증기관에 접속하나요..?">진짜 그럼 매번 인증기관에 접속하나요..?</a></li></ul>
                </li>
                <li>
                    <a href="#%ec%9d%b8%ec%a6%9d%ec%84%9c-%ed%94%bc%eb%8b%9d-%ea%b3%b5%ea%b0%9c%ed%82%a4-%ed%94%bc%eb%8b%9d" aria-label="인증서 피닝 (공개키 피닝)">인증서 피닝 (공개키 피닝)</a></li>
                <li>
                    <a href="#%ec%b6%94%ea%b0%80--%ec%9d%b8%ec%a6%9d-%ea%b8%b0%ea%b4%80%ec%9d%80-%ec%a0%95%ed%99%95%ed%9e%88-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%93%b1%eb%a1%9d%eb%90%98%ea%b3%a0-%ea%b4%80%eb%a6%ac%eb%90%a0%ea%b9%8c%ec%9a%94" aria-label="추가 : 인증 기관은 정확히 어떻게 등록되고 관리될까요?">추가 : 인증 기관은 정확히 어떻게 등록되고 관리될까요?</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
<div class="post-content"><h2 id="http-그-다음은">🧵 HTTP, 그 다음은?<a hidden class="anchor" aria-hidden="true" href="#http-그-다음은">#</a></h2>
<p>HTTP 프로토콜을 직접 만들어보면서, 생각보다 간단한 방식으로 소통한다고 깨달았습니다.</p>
<p>무언가 특수한 포맷팅을 이용해서..? 바이너리로 인코딩하여 전송할 줄 알았는데 문자였던 것이지요..</p>
<p>그래서 이렇게 간단하게 문자열로 소통하니, 보안에 정말로 취약할 수 밖에 없음을 또 인지할 수 밖에 없었습니다. 역시 무언가를 사용할 때에는 보안을 의식할 수 밖에 없습니다.</p>
<p>그래서 우리가 흔하게 사용하지만, 당연하다고 여기는 HTTPS 에 대해 더 공부를 하게 되었습니다.</p>
<h3 id="https-프로토콜">HTTPS 프로토콜<a hidden class="anchor" aria-hidden="true" href="#https-프로토콜">#</a></h3>
<p>그럼 HTTPS란 뭘까요?</p>
<p>HTTP + S(ecure) 즉, 보안 계층을 더한 HTTP 라고 생각하면 됩니다. 우리가 C언어에서 MSVC 에서 사용할 수 있는 scanf_s 와 같은 s 처럼 보안을 의식하여 보안 계층을 한층 더 감싼 HTTP 통신이라고 생각하면 됩니다.</p>
<p>이때, 이 인증은 정확히 어떤 인증을 뜻할까요? 이 인증은 SSL, 이제는 TLS라고 불리는 프로토콜을 사용하여 암호화하여 통신합니다.</p>
<h3 id="https-통신-과정">HTTPS 통신 과정<a hidden class="anchor" aria-hidden="true" href="#https-통신-과정">#</a></h3>
<p>간단합니다! 사전에 약속된 대칭키를 통해서 소통하는 형태입니다.</p>
<p>하지만 그 앞과정이 살짝 복잡한데요, 그래서 기존 HTTP보다 오버헤드가 크다는 단점이 있습니다.</p>
<p>하지만 보안이라는 장점앞에 그깟 오버헤드쯤이야… 싶습니다 ㅎㅎ</p>
<ol>
<li>클라이언트가 서버에 연결 요청</li>
<li>서버가 SSL/TLS 인증서를 클라이언트에게 보내줌</li>
<li>클라이언트가 인증서를 검증함 (인증기관, CA 로부터)</li>
<li>TLS 핸드 셰이크를 통해 안전한 연결 설정</li>
<li>암호화된 데이터 통신 시작</li>
</ol>
<img src="/assets/images/2024-10-06-tls-https-image.png" alt="2024-10-06-tls-https-image" loading="lazy">
<p><em>출처 : <a href="https://brunch.co.kr/@growthminder/79">https://brunch.co.kr/@growthminder/79</a></em></p>
<h2 id="tls-란">🗒️ TLS 란?<a hidden class="anchor" aria-hidden="true" href="#tls-란">#</a></h2>
<p>사전적 정의는 다음과 같습니다.</p>
<blockquote>
<p>🔥 Transport Layer Security</p>
<p>SSL 이라고도 불리며, 인터넷에서 안전하게 서로 통신할 수 있도록 하는 프로토콜을 뜻합니다.</p></blockquote>
<p>그래서 이는 비단 인터넷 사용 뿐만 아니라, 인터넷 연결 그 자체에도 적용되기도 합니다.</p>
<p>예를 들어, 우리가 와이파이를 연결할 때에도 대학교의 경우, 특정 인증서를 통해 (PEM 키 등) 연결하기도 합니다.</p>
<p>이러한 TLS를 사용하여 좋은 점은 무엇일까요? 크게 세가지 입니다.</p>
<h3 id="tls의-장점">TLS의 장점<a hidden class="anchor" aria-hidden="true" href="#tls의-장점">#</a></h3>
<ol>
<li>데이터의 기밀성(보안) 유지 가능</li>
<li>데이터의 무결성 보장 (변조 방지)</li>
<li>인증 제공 가능 (서버 인증서를 통해 우리 서버가 검증된 서버임을 알려줄 수 있음)</li>
</ol>
<h2 id="tls-가-완전히-안전할까요">🔒 TLS 가 완전히 안전할까요?<a hidden class="anchor" aria-hidden="true" href="#tls-가-완전히-안전할까요">#</a></h2>
<p>일반적으로 안전합니다! 사실 그렇게 깊게까지 생각할 필욘 없지만, 왜 이렇게 안전한지 한번 TLS 과정을 통해 같이 생각해봅시다.</p>
<h3 id="tls-통신핸드-셰이크-과정">TLS 통신(핸드 셰이크) 과정<a hidden class="anchor" aria-hidden="true" href="#tls-통신핸드-셰이크-과정">#</a></h3>
<ol>
<li>Client Hello
<ol>
<li>클라이언트가 서버에 지원 가능한 암호 스위트 목록, SSL/TLS 버전을 전송해줍니다.</li>
</ol>
</li>
<li>Server Hello
<ol>
<li>서버가 선택한 암호 스위트와 SSL/TLS 버전을 클라이언트에 응답합니다.</li>
</ol>
</li>
<li>Certificate : 서버가 자신의 SSL 인증서를 클라이언트에 전송해줍니다.</li>
<li>Server Key Exchange : 서버가 키 교환에 필요한 추가 정보를 전송합니다.</li>
<li>Server Hello Done : 서버가 초기 메세지 전송을 완료했음을 알립니다.</li>
<li>Client Key Exchange : 클라이언트가 대칭키 (세션 키) 생성에 필요한 정보를 암호화하여 서버에 전송합니다.</li>
<li>Change Cipher Spec : 양측이 협상된 암호 스위트를 사용할 준비가 되었음을 알립니다.</li>
<li>Finished : 핸드 셰이크를 완료하고, 암호화 통신을 시작합니다.</li>
</ol>
<p>그 이후부터는 단순히 HTTP 메세지를 서로 인증된 암호화 정보를 통해 암호화하여 통신하는게 끝입니다! 간단하죠. 간단하지만 정말 강력하다고 생각합니다.</p>
<p>하지만 몇가지 궁금점들이 있을 수 있는데, 저의 경우 이러한 궁금점들이 생겨서 더 자세하게 공부하게 되었습니다.</p>
<h4 id="아무것도-없는-클라이언트가-무엇으로부터-암호화를-할-수-있을까">아무것도 없는 클라이언트가 무엇으로부터 암호화를 할 수 있을까?<a hidden class="anchor" aria-hidden="true" href="#아무것도-없는-클라이언트가-무엇으로부터-암호화를-할-수-있을까">#</a></h4>
<p>일단, 첫번째로 서버에 지원 가능한 암호 스위트 목록을 전송합니다.</p>
<p>그리고 인증서에는 공개키가 포함되어있습니다! 이게 정말 중요한 정보입니다. 인증서가 없어서 HTTPS 연결을 사용할 수 없는 이유가 이것입니다.</p>
<p>이 인증서는 서버의 공개키를 포함하고 있고, 이것을 CA가 보증해주는 구조입니다.</p>
<p>그리고, 실제 데이터 암호화에는 이 공개키가 사용되지 않습니다. 인증서를 검증하는데에 사용되기 때문입니다.</p>
<h4 id="대칭키세션키-가-무엇인가요">대칭키(세션키) 가 무엇인가요?<a hidden class="anchor" aria-hidden="true" href="#대칭키세션키-가-무엇인가요">#</a></h4>
<p>세션키란, <code>세션마다 동적으로 생성되어 해당 세션 동안 유효한 키</code> 입니다.</p>
<p>암호화와 복호화에 동일한 키를 사용하는 암호화 방식에서 사용되는 키를 뜻합니다.</p>
<p>따라서 우리가 생각하는 비밀키 공개키 등등.. 과는 관련없는 키입니다.</p>
<p>오히려 비밀키와 공개키를 사용하여 해당 세션키를 전달하고 받는데에 사용됩니다.</p>
<blockquote>
<p>하지만,, 클라이언트가 공개키로 암호화한 데이터를 어떻게 알게 될까요..?</p></blockquote>
<h4 id="그러면-대칭키를-어떻게-클라이언트가-알게-되나요">그러면, 대칭키를 어떻게 클라이언트가 알게 되나요?<a hidden class="anchor" aria-hidden="true" href="#그러면-대칭키를-어떻게-클라이언트가-알게-되나요">#</a></h4>
<p>그래서, <code>프리마스터 시크릿</code> 이라는 임의의 값을 별도로 생성하여 클라이언트가 세션키를 안전하게 받는데 사용할 수 있습니다.</p>
<p>클라이언트가 먼저 생성한 <code>프리마스터 시크릿</code> 이라는 임의의 값을 서버에게 먼저 전달합니다. 서버는 이 <code>프리마스터 시크릿</code> 이라는 값을 받아서 알게 되는 거죠.</p>
<p>결국, 세션 통신에 관한 키 생성은 <code>클라이언트</code> 가 하게 됩니다. 이 <code>프리마스터 시크릿</code> 이란 걸 가지고 각자 동일한 세션키를 생성하는 것이죠.</p>
<h3 id="tls-중간자-공격">TLS 중간자 공격<a hidden class="anchor" aria-hidden="true" href="#tls-중간자-공격">#</a></h3>
<p>하지만 TLS 핸드셰이크 과정 자체에서 중간자 공격(MITM)이 일어날 수도 있는 것도 사실입니다.</p>
<ol>
<li>인증서 조작</li>
</ol>
<p>공격자가 신뢰할 수 있는 인증서를 획득하거나 사용자의 시스템에 악의적인 루트 인증서를 설치할 경우, 중간자 공격(MITM) 공격이 가능할 수 있습니다</p>
<ol>
<li>프로토콜 다운그레이드</li>
</ol>
<p>공격자가 클라이언트와 서버 간의 통신을 방해하여 더 취약한 이전 버전의 TLS를 사용하도록 강제할 수 있습니다.</p>
<h2 id="-중간자-공격을-완전히-방지하기-위한-방법">🧑‍⚕️ 중간자 공격을 완전히 방지하기 위한 방법<a hidden class="anchor" aria-hidden="true" href="#-중간자-공격을-완전히-방지하기-위한-방법">#</a></h2>
<h3 id="신뢰할-수-있는-ca-인증기관-사용-최신-tls-버전-사용">신뢰할 수 있는 CA (인증기관) 사용, 최신 TLS 버전 사용<a hidden class="anchor" aria-hidden="true" href="#신뢰할-수-있는-ca-인증기관-사용-최신-tls-버전-사용">#</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Certificate_authority">Certificate authority</a></p>
<p>신뢰할 수 있는 인증기관을 서버 도메인 / 인증서 내용을 비교하여 확인할 수 있다면, 우리는 인증하는 것 자체에는 큰 문제가 없는 이유가 이것입니다.</p>
<p>우리가 자주 사용하는 <code>Let's Encrypt</code> 가 대표적인 인증기관입니다.</p>
<p>하지만, 돈이 없거나, 이러한 인증 기관도 믿지 못하는 상황이 있을 수 있겠죠? 이러한 점에 대한 우려는 타당하다고 생각이 되고, 제 주변 지인과의 대화에서도 나온 주제이기도 합니다.</p>
<h4 id="진짜-그럼-매번-인증기관에-접속하나요">진짜 그럼 매번 인증기관에 접속하나요..?<a hidden class="anchor" aria-hidden="true" href="#진짜-그럼-매번-인증기관에-접속하나요">#</a></h4>
<p>아뇨! 그건 또 아닙니다.</p>
<p>대신 다음과 같은 방식으로 CA의 신뢰성을 확인할 수 있습니다.</p>
<ol>
<li>사전에 설치된 CA 인증서
<ul>
<li>애초부터 운영체제와 웹브라우저에서 신뢰할 수 있는 CA의 루트 인증서 목록이 미리 설치되어있습니다.</li>
</ul>
</li>
<li>서버 인증서 검증
<ul>
<li>TLS 핸드 셰이크 중에는 자신의 인증서를 클라이언트에게 전송합니다. (원래 전송해옴)</li>
</ul>
</li>
<li>로컬 검증
<ul>
<li>자신이 받은 서버 인증서와 자신이 가지고 있는 신뢰할 수 있는 CA 목록과 대조합니다.</li>
</ul>
</li>
<li>인증서 체인 검증
<ul>
<li>필요할 경우, 루트 CA까지 검증을 수행할 수 있습니다.</li>
</ul>
</li>
</ol>
<p>이렇게 실시간 CA 접속 없음이 보장됩니다.</p>
<p>이미 신뢰할 수 있는 CA 목록을 가지고 있기 때문에, 일반적으로 안전하다고 할 수 있는 겁니다.</p>
<p>또한 최신 TLS 버전을 사용하는 것도 좋은 방법이 될 수 있습니다. 하지만 여기서 끝내면 섭섭하니 이러한 방법 외의 여러 방안 중 하나를 알아보고자 합니다.</p>
<h3 id="인증서-피닝-공개키-피닝">인증서 피닝 (공개키 피닝)<a hidden class="anchor" aria-hidden="true" href="#인증서-피닝-공개키-피닝">#</a></h3>
<p>그 방법은 말 그대로 공개키 자체를 고정하는 방법입니다.</p>
<p>서버와 클라이언트 간 공개키를 서로 가지고 있다면, CA 시스템을 변조됐더라도, 탈취할 수 없게 됩니다. (이미 서버에 대한 인증서정보(공개키)를 클라이언트가 가진 상태로 통신을 시작할 수 있습니다.)</p>
<h3 id="추가--인증-기관은-정확히-어떻게-등록되고-관리될까요">추가 : 인증 기관은 정확히 어떻게 등록되고 관리될까요?<a hidden class="anchor" aria-hidden="true" href="#추가--인증-기관은-정확히-어떻게-등록되고-관리될까요">#</a></h3>
<p>인증기관이 신뢰할 수 있게 되는 과정에 대한 질문이 있었습니다.</p>
<p>저도 그부분에 관련해서 미흡하게 알고 있었고 따로 공부하게 되었습니다.</p>
<p>우선, 공개적인 인증기관이 되려면, 엄격한 검사과정을 거쳐야한다고 합니다. 우선, Let’s Encrypt 를 예시로 들면, 해당 기관은 비영리 인증 기관입니다. 이러한 인증기관은 WebTrust, ETSI 등의 엄격한 기준이 있다고 하는데, 이러한 조건을 충족해야한다고 합니다.</p>
<p>해당 과정에서는 보안 정책, 키 관리, 인증서 발급 절차 등을 검사한다고 보시면 되겠습니다.</p>
<p>그 후, 주요 브라우저와 운영체제 제조업체(마이크로소프트, 애플, 모질라) 등에서 운영하는 루트 인증서 프로그램이 따로 있습니다.</p>
<p>이러한 루트 프로그램에 참여하여, 브라우저와 운영체제에 직접 인증기관의 서명을 발급해줄 수 있습니다.</p>
<p>그 외에도 법적인 계약을 체결하거나, 지속적인 외부 감사를 받는 등 신뢰받을 수 있는 인증기관으로 거듭나려면 조건이 많이 필요합니다.</p>


    </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://blog.blu3fishez.org/tags/network/">Network</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://blog.blu3fishez.org/posts/2024/2024-10-23-nestjs-nestjs-%EC%97%90%EC%84%9C%EC%9D%98-dto/">
    <span class="title">« Prev</span>
    <br>
    <span>[Nest.js] Nest.js 에서의 DTO</span>
  </a>
  <a class="next" href="https://blog.blu3fishez.org/posts/2024/2024-09-01-api-response/">
    <span class="title">Next »</span>
    <br>
    <span>API의 응답 바디는 커도 좋을까
</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/blu3fishez">blu3fishez</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
