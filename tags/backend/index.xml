<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Backend on blog.moozeh</title>
    <link>http://localhost:1313/tags/backend/</link>
    <description>Recent content in Backend on blog.moozeh</description>
    <image>
      <title>blog.moozeh</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <copyright>moozeh</copyright>
    <lastBuildDate>Fri, 31 Jan 2025 22:39:35 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/backend/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Spring JPA] JPA에 대해 알아보자</title>
      <link>http://localhost:1313/posts/2025-01-31-spring-jpa%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/</link>
      <pubDate>Fri, 31 Jan 2025 22:39:35 +0900</pubDate>
      <guid>http://localhost:1313/posts/2025-01-31-spring-jpa%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/</guid>
      <description>&lt;!-- draft 값을 false 혹은 제거해야 게시됩니다!!! --&gt;
&lt;p&gt;JPA 에 대해 기본적인 내용을 훑는다. 기본적인 내용을 알고 있다면 무시해도 좋다.&lt;/p&gt;
&lt;!-- more --&gt; 
&lt;h2 id=&#34;jpa-를-사용하는-이유&#34;&gt;JPA 를 사용하는 이유&lt;/h2&gt;
&lt;p&gt;JPA를 사용하는 이유는 쿼리를 수행하는 테이블의 개수가 복잡해질수록 간단하게 코드 구현이 가능하기 때문이다.&lt;/p&gt;
&lt;h2 id=&#34;entity의-정의&#34;&gt;Entity의 정의&lt;/h2&gt;
&lt;p&gt;JPA를 사용하면, Bean 데이터를 직접 테이블로 매핑할 수 있는데, 이때 이 Bean을 엔티티 라고 부르게 된다. 즉, &lt;code&gt;Entity&lt;/code&gt; 는 &lt;code&gt;Bean&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;추가적으로 더 나아가면 Nest.js 에서 엔티티를 어떻게 정의할지 생각해볼 수 있을 것이다.&lt;/strong&gt;  꼭 Database 코드에 있어야하는 이유가 없고, &lt;code&gt;Bean&lt;/code&gt; 을 어떻게 활용할지 생각해보면 엔티티를 사용하는데 있어서 이해가 빠를 것이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>명세서를 현명하게 바꾸려면</title>
      <link>http://localhost:1313/posts/2024/2024-12-29-%EB%AA%85%EC%84%B8%EC%84%9C%EB%A5%BC-%ED%98%84%EB%AA%85%ED%95%98%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%A0%A4%EB%A9%B4/</link>
      <pubDate>Sun, 29 Dec 2024 13:42:48 +0900</pubDate>
      <guid>http://localhost:1313/posts/2024/2024-12-29-%EB%AA%85%EC%84%B8%EC%84%9C%EB%A5%BC-%ED%98%84%EB%AA%85%ED%95%98%EA%B2%8C-%EB%B0%94%EA%BE%B8%EB%A0%A4%EB%A9%B4/</guid>
      <description>&lt;p&gt;![[Pasted image 20241229134612.webp]]&lt;/p&gt;
&lt;h2 id=&#34;문제-상황&#34;&gt;문제 상황&lt;/h2&gt;
&lt;p&gt;웹소켓의 이벤트 명세를 바꾸게 되었는데, 프론트 - 백 간의 연동 과정에서 엄청난 실수를 저지르고 말았습니다. 바로 반환되는 데이터를 바꿔버린 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;반환되는 데이터만 바뀌면, 그냥 알려주면 되는 것 아닌가?&lt;/code&gt; 라는 생각이 드실 수 있습니다. 그런데 문제는, &lt;code&gt;반환되는 데이터의 기준&lt;/code&gt; 을 바꿔버렸던 것입니다.&lt;/p&gt;
&lt;p&gt;API를 정의할때 &lt;code&gt;입력&lt;/code&gt; 과 &lt;code&gt;출력&lt;/code&gt; 값만 나오면 된다곤 하지만, 결국엔 어떤 값을 넣으면 서버에 저장되는 데이터가 어떻게 바뀌는지에 대해서는 명세가 안되었던 것 입니다.&lt;/p&gt;
&lt;p&gt;“바뀐 명세를 확인해주세요!” 라고 말하고 너무 프론트 분에게 맡겼던 것이 큰 실책이었던 것입니다. 바뀐 명세가 제대로 작동되지 않거나, 충분히 설명되지 않았습니다. 글을 쓰는 것이 많이 어려웠는데, 계속된 문서화랑 코딩으로 인해 체력이 바닥이 나서 제대로 글을 못쓴 것도 원인 같습니다. 이런 상황에서도 문서를 잘 쓸 수 있어야 개발자일까.. 고민하게 됐습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The redirect_uri is not associated with this application 오류 해결</title>
      <link>http://localhost:1313/posts/2024/2024-12-28-the-redirect_uri-is-not-associated-with-this-application-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/</link>
      <pubDate>Sat, 28 Dec 2024 23:04:54 +0900</pubDate>
      <guid>http://localhost:1313/posts/2024/2024-12-28-the-redirect_uri-is-not-associated-with-this-application-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/</guid>
      <description>&lt;p&gt;블로그 설명 글 등에서 OAuth 앱에서 &lt;code&gt;URI&lt;/code&gt; 를 설정할 때  왜 &lt;a href=&#34;http://localhost:8080&#34;&gt;&lt;code&gt;localhost:8080&lt;/code&gt;&lt;/a&gt; 등으로 로컬 호스트로 설정을 해두었는지 알 수 있게 된 문제 해결 과정이었습니다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;URI&lt;/code&gt; 설정을 잠깐 바꾸었다가 &lt;code&gt;OAuth&lt;/code&gt; 요청을 보냈는데, 해당 오류페이지로 리다이렉팅되는 문제가 있었다. 이는 실제로 &lt;code&gt;callback&lt;/code&gt; uri와 실제 리디렉션 URI 가 일치하지 않을때 발생하는 문제였습니다.&lt;/p&gt;
&lt;p&gt;이는 OAuth 에서는 XSS 등의 웹 공격을 방지하기 위해 깃허브로부터 OAuth 요청을 할 때, 우리 사이트를 통해 OAuth 를 한 후 어떤 사이트 (혹시나 해킹사이트로 가지진 않을지)에 대한 방어책이었습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Custom Passport 로 Github OAuth 로직을 직접 구현하기</title>
      <link>http://localhost:1313/posts/2024/2024-12-21-custom-passport-%EB%A1%9C-github-oauth-%EB%A1%9C%EC%A7%81%EC%9D%84-%EC%A7%81%EC%A0%91-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/</link>
      <pubDate>Sat, 21 Dec 2024 12:36:32 +0900</pubDate>
      <guid>http://localhost:1313/posts/2024/2024-12-21-custom-passport-%EB%A1%9C-github-oauth-%EB%A1%9C%EC%A7%81%EC%9D%84-%EC%A7%81%EC%A0%91-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/</guid>
      <description>&lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;OAuth&lt;/code&gt; 가 조금 어렵다고 해서 솔직히 하루 걸릴 줄 알았습니다. 하지만 차근차근 진행해보니 수월하게 진행할 수 있었는데, 그 과정을 개발일지로 남겨주는게 좋을 것 같아 미리 남겨봅니다.&lt;/p&gt;
&lt;p&gt;실제로 OAuth 를 예제로 만들어보는 &lt;code&gt;블로그 글&lt;/code&gt; 들이 상당 수 존재하였으며, 이것들을 바탕으로 단순히 따라가기만 하면 될 것 같았습니다. 하지만 그 과정에서 이해되지 않는 부분이 존재하였고, 이 부분에서 트러블 슈팅이 조금 있었습니다.&lt;/p&gt;
&lt;p&gt;제가 &lt;code&gt;어떻게 OAuth를 하는지 알려주어야 앞으로 OAuth 관련 기능 구현에 있어서 도움이 될 수 있을 것이라 판단하였기에 문서로 기록하고자 합니다.&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Nest.js] Nest.js 에서의 DTO</title>
      <link>http://localhost:1313/posts/2024/2024-10-23-nestjs-nestjs-%EC%97%90%EC%84%9C%EC%9D%98-dto/</link>
      <pubDate>Wed, 23 Oct 2024 18:46:23 +0900</pubDate>
      <guid>http://localhost:1313/posts/2024/2024-10-23-nestjs-nestjs-%EC%97%90%EC%84%9C%EC%9D%98-dto/</guid>
      <description>&lt;h2 id=&#34;dto-란&#34;&gt;DTO 란?&lt;/h2&gt;
&lt;p&gt;이전에 계층 간 데이터 교환을 위한 객체라고 배웠다.&lt;/p&gt;
&lt;p&gt;여기에 더 나아가서, &lt;code&gt;DTO&lt;/code&gt;란, &lt;code&gt;네트워크&lt;/code&gt; 를 통해 전송되는 방법 또한 정의할 수 있다.&lt;/p&gt;
&lt;p&gt;말 그대로 데이터 전송 객체이다.&lt;/p&gt;
&lt;h3 id=&#34;nestjs-에서의-dto&#34;&gt;Nest.js 에서의 DTO&lt;/h3&gt;
&lt;p&gt;Nest.js 에서는 &lt;code&gt;Class&lt;/code&gt; 를 이용하여 정의하는 것을 추천하고 있으며, &lt;code&gt;interface&lt;/code&gt; 로도 가능하다.&lt;/p&gt;
&lt;p&gt;그 이유는 &lt;code&gt;class&lt;/code&gt; 는 &lt;code&gt;interface&lt;/code&gt; 와 달리, 런타임 내에 정의 되어 있기 때문에 &lt;code&gt;pipe&lt;/code&gt; 등의 기능도 활용 가능하다고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이는 &lt;strong&gt;반대로 얘기하면, 굳이 상태를 보존할 이유가 없다면 인터페이스를 쓰는게 낫다는 뜻으로도 해석할 수 있겠다.&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
