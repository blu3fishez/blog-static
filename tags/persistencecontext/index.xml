<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>PersistenceContext on blog.moozeh</title>
    <link>http://localhost:1313/tags/persistencecontext/</link>
    <description>Recent content in PersistenceContext on blog.moozeh</description>
    <image>
      <title>blog.moozeh</title>
      <url>http://localhost:1313/images/papermod-cover.png</url>
      <link>http://localhost:1313/images/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.148.2</generator>
    <language>en</language>
    <copyright>moozeh</copyright>
    <lastBuildDate>Fri, 07 Mar 2025 17:00:36 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/persistencecontext/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Spring JPA] 영속성 컨텍스트 시리즈 (2) - N:M 관계 엔티티로 풀어내기</title>
      <link>http://localhost:1313/posts/2025-03-07-spring-jpa-nm-%EA%B4%80%EA%B3%84-%ED%92%80%EC%96%B4%EB%82%B4%EA%B8%B0-1-%EC%97%94%ED%8B%B0%ED%8B%B0%EC%97%90-%EA%B1%B8%EB%A6%B0-%EA%B4%80%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%84-%ED%92%80%EC%96%B4%EB%82%B4%EA%B8%B0/</link>
      <pubDate>Fri, 07 Mar 2025 17:00:36 +0900</pubDate>
      <guid>http://localhost:1313/posts/2025-03-07-spring-jpa-nm-%EA%B4%80%EA%B3%84-%ED%92%80%EC%96%B4%EB%82%B4%EA%B8%B0-1-%EC%97%94%ED%8B%B0%ED%8B%B0%EC%97%90-%EA%B1%B8%EB%A6%B0-%EA%B4%80%EA%B3%84-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%84-%ED%92%80%EC%96%B4%EB%82%B4%EA%B8%B0/</guid>
      <description>&lt;p&gt;&lt;code&gt;Porring&lt;/code&gt; 프로젝트를 하면서 다대다 관계를 만들 때 관계에 대한 엔티티를 만들지 말지를 고민했는데, 결국엔 만들었다.&lt;/p&gt;
&lt;p&gt;왜냐하면, 관계 자체를 검색할 일이 많았으니까 관계가 주를 이룬다고 생각했기 때문에 그렇게 생각했다.&lt;/p&gt;
&lt;p&gt;하지만 다대다 관계에서는 만들 수도 있고, 만들지 않을 수도 있다. &lt;code&gt;@ManyToMany&lt;/code&gt;  어노테이션을 사용하면 만들 수 있다고 들었다.&lt;/p&gt;
&lt;p&gt;하지만, 실무에서는 왠만해선 사용하지 말라는 의견이 많은데 그 이유를 알아보자.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;물론! 이 부분은 &lt;code&gt;JPA&lt;/code&gt; 에 준하는 이야기다. 왜냐하면 &lt;code&gt;JPA&lt;/code&gt; 의 엔티티의 영속성 컨텍스트를 살펴봐야하기 때문이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>[Spring JPA] 영속성 컨텍스트 시리즈 (1) - 영속성 컨텍스트와 1차 캐시</title>
      <link>http://localhost:1313/posts/2025-02-22-spring-jpa-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%80%EC%9E%A5%EB%90%A0%EA%B9%8C-1/</link>
      <pubDate>Sat, 22 Feb 2025 16:55:04 +0900</pubDate>
      <guid>http://localhost:1313/posts/2025-02-22-spring-jpa-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%80%EC%9E%A5%EB%90%A0%EA%B9%8C-1/</guid>
      <description>&lt;!-- draft 값을 false 혹은 제거해야 게시됩니다!!! --&gt;
&lt;p&gt;&lt;code&gt;JOINED&lt;/code&gt; 를 이용해 상속받은 &lt;code&gt;JPA Entity&lt;/code&gt; 는 어떻게 저장될까라는 궁금증으로 시작했다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Repository&lt;/code&gt; 에서 저장 될 때 기본적인 엔티티가 어떻게 저장되는지가 궁금했고, 이왕 알아보는 김에 &lt;code&gt;Hibernate&lt;/code&gt; 에서 정확하게 어떻게 구현이 되었는지 살펴보는 것까지 목표로 한다.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;서론&#34;&gt;서론&lt;/h2&gt;
&lt;p&gt;![[2025-02-22-spring-jpa-상속받은-엔티티는-어떻게-저장될까-20250222165542877.webp]]&lt;/p&gt;
&lt;p&gt;결국 문제는 단순 휴먼 에러였다. 왜냐하면, 보이는 것처럼 추측되는 &lt;code&gt;Account&lt;/code&gt; 엔티티를 저장하지 않은 채로,  &lt;code&gt;AUTO INCREMENT&lt;/code&gt; 값을 불러오지 않은채 바로 다른 곳에 사용했기 때문에 일어난 일이었다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
